<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm Interface · Boscia.jl</title><meta name="title" content="Algorithm Interface · Boscia.jl"/><meta property="og:title" content="Algorithm Interface · Boscia.jl"/><meta property="twitter:title" content="Algorithm Interface · Boscia.jl"/><meta name="description" content="Documentation for Boscia.jl."/><meta property="og:description" content="Documentation for Boscia.jl."/><meta property="twitter:description" content="Documentation for Boscia.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Boscia.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../basics/">How does it work?</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/docs-01-network-design/">Network Design Problem</a></li><li><a class="tocitem" href="../../examples/docs-02-graph-isomorphism/">Graph Isomorphism Problem</a></li><li><a class="tocitem" href="../../examples/docs-03-optimal-design/">Optimal Design of Experiments</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Algorithm Interface</a><ul class="internal"><li><a class="tocitem" href="#Optional-settings"><span>Optional settings</span></a></li><li><a class="tocitem" href="#Definitions"><span>Definitions</span></a></li></ul></li><li><a class="tocitem" href="../2_blmo_build/">The Bounded Linear Minimization Oracle (BLMO)</a></li><li><a class="tocitem" href="../custom/">Branch-and-Bound tree functionality</a></li><li><a class="tocitem" href="../fw_variant/">Frank-Wolfe Variants</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Algorithm Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/Boscia.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/Boscia.jl/blob/main/docs/src/reference/1_algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithm-Interface"><a class="docs-heading-anchor" href="#Algorithm-Interface">Algorithm Interface</a><a id="Algorithm-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Interface" title="Permalink"></a></h1><p>Boscia&#39;s <code>solve</code> function only requires the oracles of the objective function <code>f</code> and its gradient <code>g</code> as well as the BLMO encoding the feasible region. For the possible settings, see further down the page.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.postsolve-NTuple{5, Any}" href="#Boscia.postsolve-NTuple{5, Any}"><code>Boscia.postsolve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">postsolve(tree, result, time_ref, verbose, max_iteration_post)</code></pre><p>Runs the post solve to optimize for the continuous variables if present. Is called if <code>use_post_solve</code> is enabled in the <code>solve</code> function. Prints solution statistics if verbose is set to <code>true</code>.        </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/interface.jl#L300-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.solve-Tuple{Any, Any, LinearMinimizationOracle}" href="#Boscia.solve-Tuple{Any, Any, LinearMinimizationOracle}"><code>Boscia.solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(f, g, lmo::LinearMinimizationOracle; ...)</code></pre><p>Requires</p><ul><li><code>f</code> oracle of the objective function.</li><li><code>g</code> oracle of the gradient of the objective</li><li><code>lmo</code> encodes the feasible region and can handle additional bound constraints. This can either be a MIP solver instance (e.g., SCIP) or be a custom type (see <code>polytope_blmos.jl</code>). Has to be of type <code>FrankWolfe.LinearMinimizationOracle</code> (see <code>blmo_interface.jl</code>).</li></ul><p>Returns</p><ul><li><code>x</code> the best solution found.</li><li><code>tlmo</code> the LMO wrapped in a TimeTrackingLMO instance.</li><li><code>result</code> a dictionary containg the statistics like number of nodes, total solving etc. It also contains information for plotting progress plots like the lower and upper bound progress.</li></ul><p>Optional settings</p><ul><li><code>settings_bnb</code> dictionary of settings for the branch-and-bound algorithm. Created via <code>settings_bnb()</code>.</li><li><code>settings_frank_wolfe</code> dictionary of settings for the Frank-Wolfe algorithm. Created via <code>settings_frank_wolfe()</code>.</li><li><code>settings_tolerances</code> dictionary of settings for the tolerances. Created via <code>settings_tolerances()</code>.</li><li><code>settings_postprocessing</code> dictionary of settings for the postprocessing. Created via <code>settings_postprocessing()</code>.</li><li><code>settings_heuristic</code> dictionary of settings for the heuristics. Created via <code>settings_heuristic()</code>.</li><li><code>settings_tightening</code> dictionary of settings for the tightening. Created via <code>settings_tightening()</code>.</li><li><code>settings_domain</code> dictionary of settings for the domain. Created via <code>settings_domain()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/interface.jl#L3-L27">source</a></section></article><h2 id="Optional-settings"><a class="docs-heading-anchor" href="#Optional-settings">Optional settings</a><a id="Optional-settings-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-settings" title="Permalink"></a></h2><p>Boscia has a lot of settings to customize the solving process. These are grouped by </p><ul><li>general Branch-and-Bound settings </li><li>settings specific for Frank-Wolfe </li><li>tolerances settings for both the tree as well as the Frank-Wolfe algorithm </li><li>settings for the heuristics</li><li>bound tightenings settings</li><li>postprocessing settings</li><li>parameters for the case of a non-trivial domain, i.e. the objective cannot be evaluated at all points of the feasible region</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.create_default_settings-Tuple{}" href="#Boscia.create_default_settings-Tuple{}"><code>Boscia.create_default_settings</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create default settings depending on the mode.</p><p>Only requires the mode, if no mode is provided, the default mode is used. Returns a NamedTuple of dictionaries for the different group of settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.settings_bnb-Tuple{}" href="#Boscia.settings_bnb-Tuple{}"><code>Boscia.settings_bnb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">settings_bnb(mode::Mode;...)</code></pre><p>Set the settings for the branch-and-bound algorithm.</p><p>Requires:</p><ul><li><code>mode</code> the mode of the algorithm. See the <code>Boscia.Mode</code> enum for the available modes. If no mode is provided, the default mode is used.</li></ul><p>Returns:</p><ul><li><code>Dict</code> of settings for the branch-and-bound algorithm.</li></ul><p>Available settings:</p><ul><li><code>traverse_strategy</code> encodes how to choose the next node for evaluation. By default the node with the best lower bound is picked.</li><li><code>branching_strategy</code> fixes the branching strategy. By default, weuse <code>MOST_INFEASIBLE</code>, i.e. we branch on the entry which is the farthest away from being an integer.</li><li><code>verbose</code> if <code>true</code>, logs and solution statistics are printed. Per default, this is <code>false</code>.</li><li><code>node_limit</code> maximum number of nodes to be evaluated. In DEFAULT mode, there is no limit. In HEURISTIC mode, the default is set to 1000.</li><li><code>time_limit</code> algorithm will stop if the time limit is reached. Depending on the problem it is possible that no feasible solution has been found yet. In DEFAULT mode, there is no time limit. In HEURISTIC mode, the default is set to 300 seconds (5 minutes).</li><li><code>print_iter</code> encodes after how many processed nodes the current node and solution status is printed. The logs are always printed if a new integral solution has been found. Per default, <code>print_iter</code> is set to <code>100</code>`.</li><li><code>bnb_callback</code> optional callback function that is called after every node evaluation. It will be called before the Boscia internal callback handling the printing of the logs. It receives the tree, the node and the following keyword arguments: <code>worse_than_incumbent=false</code>, <code>node_infeasible=false</code>, <code>lb_update=false</code>.</li><li><code>branch_callback</code> an optional callback called before branching. Receives the tree, the node and the branching variable index as input. Expected output is a pair of boolean values indicating whether the left and right child should be pruned. <code>false</code>indicates prune the child, <code>true</code> indicates keep the child.</li><li><code>no_pruning</code> if <code>true</code>, no pruning of nodes is performed. Per default, nodes are pruned if they have a lower bound which is worse than the best known solution. Per default, this is <code>true</code> for the <code>HEURISTIC</code> mode and <code>false</code> for the <code>OPTIMAL</code> mode.</li><li><code>ignore_lower_bound</code> if <code>true</code>, the lower bound obtain by Frank-Wolfe is ignored and in the logs, only Inf will be printed. Per default, this is <code>true</code> for the <code>HEURISTIC</code> mode and <code>false</code> for the <code>OPTIMAL</code> mode.</li><li><code>start_solution</code> an initial solution can be provided if known. It will be used as the initial incumbent.</li><li><code>use_shadow_set</code> the shadow set is the set of discarded vertices which is inherited by the children nodes. It is used to avoid recomputing of vertices in case the LMO is expensive. In case of a cheap LMO, performance might improve by disabling this option. Per default, this is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L20-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.settings_domain-Tuple{}" href="#Boscia.settings_domain-Tuple{}"><code>Boscia.settings_domain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">settings_domain(mode::Mode;...)</code></pre><p>To set settings for a non-trivial domain, i.e. if not all points of the feasible region are domain feasible.</p><p>Requires:</p><ul><li><code>mode</code> the mode of the algorithm. See the <code>Boscia.Mode</code> enum for the available modes. If no mode is provided, the default mode is used.</li></ul><p>Returns:</p><ul><li><code>Dict</code> of settings for the domain.</li></ul><p>Available settings:</p><ul><li><code>domain_oracle</code> given a point <code>x</code>: returns <code>true</code> if <code>x</code> is in the domain of <code>f</code>, else false. Per default, it always returns <code>true</code>. In case of the non-trivial domain oracle, the initial point has to be domain feasible for <code>f</code> and can be set via the <code>active_set</code><code>. Additionally, the user has to provide a function</code>domain_point`, see below. Also, depending on the line search method, you might have to provide the domain oracle to it, too. The default line search Secant, for example, requires the domain oracle.</li><li><code>find_domain_point</code> given the current node bounds return a domain feasible point respecting the bounds. If no such point can be found, return <code>nothing</code>. Only necessary for a non-trivial domain oracle.</li><li><code>active_set</code> can be used to specify a starting point. By default, the direction (1,..,n) where n is the size of the problem is used to find a start vertex. This has to be of the type <code>FrankWolfe.ActiveSet</code>. Beware that the active set may only contain actual vertices of the feasible region.</li><li><code>depth_domain</code> The domain point is used to generate new starting points after branching by solving a projection problem. This parameter is used to control how far we move into the domain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L379-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.settings_frank_wolfe-Tuple{}" href="#Boscia.settings_frank_wolfe-Tuple{}"><code>Boscia.settings_frank_wolfe</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">settings_frank_wolfe(mode::Mode;...)</code></pre><p>Options for the Frank-Wolfe algorithm used as node solver.</p><p>Requires:</p><ul><li><code>mode</code> the mode of the algorithm. See the <code>Boscia.Mode</code> enum for the available modes. If no mode is provided, the default mode is used.</li></ul><p>Returns:</p><ul><li><code>Dict</code> of settings for the Frank-Wolfe algorithm.</li></ul><p>Available settings:</p><ul><li><code>variant</code> the Frank-Wolfe variant to be used to solve the node problem. Options currently available are <code>AwayFrankWolfe</code>, <code>BlendedConditionalGradient</code>, <code>BlendedPairwiseConditionalGradient</code>, <code>DecompositionInvariantConditionalGradient</code> and <code>StandardFrankWolfe</code>. Per default, this is set to <code>BlendedPairwiseConditionalGradient</code>.</li><li><code>line_search</code> specifies the line search method used in the FrankWolfe variant. Default is the <code>FrankWolfe.Secant</code> line search. For other available types, check the FrankWolfe.jl package.</li><li><code>max_fw_iter</code> maximum number of iterations in a Frank-Wolfe run. Per default, this is set to <code>10000</code>.</li><li><code>fw_timeout</code> time limit for the Frank-Wolfe runs. Per default, there is no time limit. It is preferred to set the iteration limit but this can be used as a fallback and/or if the LMO call is time consuming.</li><li><code>min_fw_iterations</code> the minimum number of Frank-Wolfe iterations performed in the node evaluation. Per default, this is set to <code>5</code>.</li><li><code>fw_verbose</code> if <code>true</code>, the Frank-Wolfe logs are printed at each node. Mostly meant for debugging. Per default, this is <code>false</code>.</li><li><code>lazy</code> flag specifies whether the lazification of the Frank-Wolfe variant should be used. Per default <code>true</code>. Note that it has no effect on standard Frank-Wolfe.</li><li><code>lazy_tolerance</code> decides how much progress is deemed enough to not have to call the LMO. Only used if the <code>lazy</code> flag is activated. Per default, this is set to <code>2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L94-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.settings_heuristic-Tuple{}" href="#Boscia.settings_heuristic-Tuple{}"><code>Boscia.settings_heuristic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">settings_heuristic(mode::Mode;...)</code></pre><p>Set the settings for the heuristics.</p><p>Requires:</p><ul><li><code>mode</code> the mode of the algorithm. See the <code>Boscia.Mode</code> enum for the available modes. If no mode is provided, the default mode is used.</li></ul><p>Returns:</p><ul><li><code>Dict</code> of settings for the heuristics.</li></ul><p>Available settings:</p><ul><li><code>custom_heuristics</code> list of custom heuristics from the user. Heuristics can be created via the <code>Boscia.Heuristic</code> constructor. It requires a function, a probability and an identifier (symbol). Note that the heuristics defined in Boscia themselves don&#39;t have to be added here and can be set via the probability parameters below.</li><li><code>post_heuristics_callback</code> callback function called whenever a new solution is found and added to the tree. </li><li><code>prob_rounding</code> the probability for calling the simple rounding heuristic. Since the feasibility has to be checked, it might be expensive to do this for every node. Per default, this is activated for every node.</li><li><code>follow_gradient_prob</code> the probability for calling the follow-the-gradient heuristic. Per default, this is <code>0.0</code>.</li><li><code>follow_gradient_steps</code> the number of steps for the follow-the-gradient heuristic. Per default, this is <code>10</code>.</li><li><code>rounding_lmo_01_prob</code> the probability for calling the rounding-LMO-01 heuristic. Per default, this is <code>0.0</code>.</li><li><code>probability_rounding_prob</code> the probability for calling the probability-rounding heuristic. Per default, this is <code>0.0</code>.</li><li><code>hyperplane_aware_rounding_prob</code> the probability for calling the hyperplane-aware-rounding heuristic. Per default, this is <code>0.0</code>.</li><li><code>add_all_solutions</code> if <code>true</code>, all solutions found by the heuristics, Frank-Wolfe or the LMO are added to the tree. Per default, this is <code>true</code> for the <code>HEURISTIC</code> mode and <code>false</code> for the <code>OPTIMAL</code> mode.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L216-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.settings_postprocessing-Tuple{}" href="#Boscia.settings_postprocessing-Tuple{}"><code>Boscia.settings_postprocessing</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">settings_postprocessing(mode::Mode;...)</code></pre><p>Set the settings for the postprocessing.</p><p>Requires:</p><ul><li><code>mode</code> the mode of the algorithm. See the <code>Boscia.Mode</code> enum for the available modes. If no mode is provided, the default mode is used.</li></ul><p>Returns:</p><ul><li><code>Dict</code> of settings for the postprocessing.</li></ul><p>Available settings:</p><ul><li><code>use_postsolve</code> if <code>true</code>, runs the specified Frank-Wolfe variant on the problem with the integral variables fixed to the solution, i.e. it only optimizes over the continuous variables. This might improve the solution if one has many continuous variables. Per default, this is <code>true</code>.</li><li><code>max_iteration_post</code> maximum number of iterations in the Frank-Wolfe run during postsolve. Per default, this is set to <code>10000</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L180-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.settings_tightening-Tuple{}" href="#Boscia.settings_tightening-Tuple{}"><code>Boscia.settings_tightening</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">settings_tightening(mode::Mode;...)</code></pre><p>Set the tightening parameters.</p><p>Requires:</p><ul><li><code>mode</code> the mode of the algorithm. See the <code>Boscia.Mode</code> enum for the available modes. If no mode is provided, the default mode is used.</li></ul><p>Returns:</p><ul><li><code>Dict</code> of settings for the tightening.</li></ul><p>Available settings:</p><ul><li><code>dual_tightening</code> flag to decide  whether to use dual tightening techniques at node level. Note that this only porvides valid tightenings if your function is convex! Per default, this is <code>true</code>.</li><li><code>global_dual_tightening</code> flag to decide whether to generate dual tightenings from new solutions that are gloablly valid. Per default, this is <code>true</code>.</li><li><code>strong_convexity</code> strong convexity parameter of the objective <code>f</code>, used for tightening the dual bound at every node. Per default, this is set to <code>0.0</code>.</li><li><code>sharpness_constant</code> - the constant <code>M &gt; 0</code> for <code>(θ, M)</code>-sharpness. <code>f</code> is <code>(θ, M)</code>-sharpness: <code>f</code> satisfies <code>min_{x^* ∈ X^*} || x - x^* || ≤ M (f(x) - f^(x^*))^θ</code> where <code>X^*</code> is the set of minimizer of <code>f</code>. Note that tightenings using sharpness are only valid if the problem has a unique minimizer, i.e. <code>f</code> is stricly convex! Per default, this is set to <code>0.0</code>.</li><li><code>sharpness_exponent</code> - the exponent <code>θ ∈ [0, 1/2]</code> for <code>(θ, M)</code>-sharpness. Per default, this is set to <code>Inf</code>.</li><li><code>propagate_bounds</code> optional function that allows the user to propagate and tighten bounds depending on the node. Receives the tree and the node as input.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L339-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.settings_tolerances-Tuple{}" href="#Boscia.settings_tolerances-Tuple{}"><code>Boscia.settings_tolerances</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">settings_tolerances(mode::Mode;...)</code></pre><p>Set the tolerances for the Frank-Wolfe algorithm. These are tolerances both for the Branch-and-Bound tree as well as for the Frank-Wolfe variant used as node solver.</p><p>Requires:</p><ul><li><code>mode</code> the mode of the algorithm. See the <code>Boscia.Mode</code> enum for the available modes. If no mode is provided, the default mode is used.</li></ul><p>Returns:</p><ul><li><code>Dict</code> of tolerances for the Frank-Wolfe algorithm.</li></ul><p>Available settings:</p><ul><li><code>fw_epsilon</code> the solving precision of Frank-Wolfe at the root node.</li><li><code>dual_gap</code> absolute dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to <code>1e-6</code>.</li><li><code>rel_dual_gap</code> relative dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to <code>1e-2</code>.</li><li><code>dual_gap_decay_factor</code> the FrankWolfe tolerance at a given level <code>i</code> in the tree is given by <code>fw_epsilon * dual_gap_decay_factor^i</code> until we reach the <code>min_node_fw_epsilon</code>. Per default, this is set to <code>0.8</code>.</li><li><code>min_number_lower</code> if not <code>Inf</code>, evaluation of a node is stopped if at least <code>min_number_lower</code> open nodes have a better lower bound. Per default, this is set to <code>Inf</code>.</li><li><code>min_node_fw_epsilon</code> smallest fw epsilon tolerance, see also <code>dual_gap_decay_factor</code>. Per default, this is set to <code>1e-6</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/8e4c53cdc887c5ff0c390fe6496d1a7153e3ef2e/src/settings.jl#L140-L161">source</a></section></article><h2 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h2><p>Boscia defines its own solving state.  Additionally, Boscia has different modes, like the <code>DEFAULT_MODE</code> and <code>HEURISTIC_MODE</code>. These have their own default settings for the optional parameters.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/docs-03-optimal-design/">« Optimal Design of Experiments</a><a class="docs-footer-nextpage" href="../2_blmo_build/">The Bounded Linear Minimization Oracle (BLMO) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 09:29">Wednesday 12 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
