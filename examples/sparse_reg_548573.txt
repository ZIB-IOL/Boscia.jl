[ Info: primal >= tree.incumbent
ERROR: LoadError: UndefVarError: str not defined
Stacktrace:
 [1] top-level scope
   @ ~/git/Boscia.jl/examples/run_sparse_reg_setup.jl:11
in expression starting at /home/htc/htroppen/git/Boscia.jl/examples/run_sparse_reg_setup.jl:7

caused by: AssertionError: primal <= tree.incumbent + 0.01 || isapprox(primal, tree.incumbent, atol = 1.0e-6, rtol = 0.01)
Stacktrace:
 [1] postsolve(tree::BnBTree{Boscia.FrankWolfeNode{FrankWolfe.ActiveSet{Vector{Float64}, Float64, Vector{Float64}}, FrankWolfe.DeletedVertexStorage{Vector{Float64}}, Boscia.IntegerBounds}, NamedTuple{(:problem, :current_node_id, :updated_incumbent, :global_tightening_rhs, :global_tightening_root_info, :global_tightenings, :options), Tuple{Boscia.SimpleOptimizationProblem{var"#f#9"{Vector{Float64}, Matrix{Float64}, Float64, Float64, Int64}, var"#grad!#10"{Vector{Float64}, Matrix{Float64}, Float64, Float64, Int64}, Boscia.TimeTrackingLMO{FrankWolfe.MathOptLMO{SCIP.Optimizer}}, Boscia.IntegerBounds}, Base.RefValue{Int64}, Base.RefValue{Bool}, Base.RefValue{Float64}, NamedTuple{(:lower_bounds, :upper_bounds), Tuple{Dict{Int64, Tuple{Float64, MathOptInterface.GreaterThan{Float64}}}, Dict{Int64, Tuple{Float64, MathOptInterface.LessThan{Float64}}}}}, Boscia.IntegerBounds, Dict{Symbol, Any}}}, Vector{Float64}, Boscia.FrankWolfeSolution{Boscia.FrankWolfeNode{FrankWolfe.ActiveSet{Vector{Float64}, Float64, Vector{Float64}}, FrankWolfe.DeletedVertexStorage{Vector{Float64}}, Boscia.IntegerBounds}, Vector{Float64}}}, result::Dict{Symbol, Any}, time_ref::DateTime, verbose::Bool, use_postsolve::Bool, max_iteration_post::Int64)
   @ Boscia ~/git/Boscia.jl/src/interface.jl:599
 [2] solve(f::var"#f#9"{Vector{Float64}, Matrix{Float64}, Float64, Float64, Int64}, grad!::var"#grad!#10"{Vector{Float64}, Matrix{Float64}, Float64, Float64, Int64}, lmo::FrankWolfe.MathOptLMO{SCIP.Optimizer}; traverse_strategy::Bonobo.BestFirstSearch, branching_strategy::Bonobo.MOST_INFEASIBLE, fw_epsilon::Float64, verbose::Bool, dual_gap::Float64, rel_dual_gap::Float64, time_limit::Int64, print_iter::Int64, dual_gap_decay_factor::Float64, max_fw_iter::Int64, min_number_lower::Float64, min_node_fw_epsilon::Float64, warmstart_shadow_set::Bool, warmstart_active_set::Bool, afw::Bool, use_postsolve::Bool, min_fw_iterations::Int64, max_iteration_post::Int64, dual_tightening::Bool, global_dual_tightening::Bool, bnb_callback::Nothing, strong_convexity::Float64, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}})
   @ Boscia ~/git/Boscia.jl/src/interface.jl:261
 [3] sparse_reg_shot(seed::Int64, n::Int64; print_models::Bool, time_limit::Int64)
   @ Main ~/git/Boscia.jl/examples/sparse_reg.jl:794
 [4] sparse_reg_shot(seed::Int64, n::Int64)
   @ Main ~/git/Boscia.jl/examples/sparse_reg.jl:745
 [5] top-level scope
   @ ~/git/Boscia.jl/examples/run_sparse_reg_setup.jl:8
(seed, dimension) = (5, 28)
objective_sense(m) = MathOptInterface.MIN_SENSE
(termination_shot, solution_shot) = ("LOCALLY_SOLVED", 5.176891131084281)
Away FW: false
(primal, tree.incumbent) = (5.176891131084282, 5.124249112980191)
AssertionError("primal <= tree.incumbent + 0.01 || isapprox(primal, tree.incumbent, atol = 1.0e-6, rtol = 0.01)")
