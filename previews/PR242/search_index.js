var documenterSearchIndex = {"docs":
[{"location":"reference/custom/#Branch-and-Bound-tree-functionality","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"The functionality of the Branch-and-Bound implementation extended from Bonobo.jl and some extended features like strong branching and the callbacks.","category":"page"},{"location":"reference/custom/#Problem","page":"Branch-and-Bound tree functionality","title":"Problem","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"The main problem structure as stored in the Branch-and-Bound tree.","category":"page"},{"location":"reference/custom/#Boscia.SimpleOptimizationProblem","page":"Branch-and-Bound tree functionality","title":"Boscia.SimpleOptimizationProblem","text":"Represents an optimization problem of the form:\n\nmin_x f(x)\ns.t.  x ∈ X (given by the LMO)\n      x_j ∈ Z ∀ j in integer_variables\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.get_branching_indices-Tuple{Boscia.SimpleOptimizationProblem}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_indices","text":"Returns the indices of the discrete variables for the branching in Bonobo.BnBTree\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.indicator_present-Tuple{Boscia.TimeTrackingLMO}","page":"Branch-and-Bound tree functionality","title":"Boscia.indicator_present","text":"Are indicator constraints present\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_integer_feasible-Tuple{AbstractVector{<:Integer}, AbstractVector}","page":"Branch-and-Bound tree functionality","title":"Boscia.is_integer_feasible","text":"Checks if a given vector is valid integral solution. Specifically for mixed problems.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_linear_feasible-Tuple{Boscia.TimeTrackingLMO, AbstractVector}","page":"Branch-and-Bound tree functionality","title":"Boscia.is_linear_feasible","text":"Checks if x is valid for all linear and variable bound constraints \n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Customized-Bonobo-structures-and-functions","page":"Branch-and-Bound tree functionality","title":"Customized Bonobo structures and functions","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Our adaptations to the functions in Bonobo.jl. ","category":"page"},{"location":"reference/custom/#Bonobo.optimize!-Tuple{Bonobo.BnBTree{var\"#s23\", Root, Value, Solution} where {var\"#s23\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s23\", Value}}}","page":"Branch-and-Bound tree functionality","title":"Bonobo.optimize!","text":"optimize!(tree::BnBTree; callback=(args...; kwargs...)->())\n\nOptimize the problem using a branch and bound approach.  The steps, repeated until terminated is true, are the following:\n\n# 1. get the next open node depending on the traverse strategy\nnode = get_next_node(tree, tree.options.traverse_strategy)\n# 2. evaluate the current node and return the lower and upper bound\n# if the problem is infeasible both values should be set to NaN\nlb, ub = evaluate_node!(tree, node)\n# 3. update the upper and lower bound of the node struct\nset_node_bound!(tree.sense, node, lb, ub)\n# 4. update the best solution\nupdated = update_best_solution!(tree, node)\nupdated && bound!(tree, node.id)\n# 5. remove the current node\nclose_node!(tree, node)\n# 6. compute the node children and adds them to the tree\n# internally calls get_branching_variable and branch_on_variable!\nbranch!(tree, node)\n\nA callback function can be provided which will be called whenever a node is closed. It always has the arguments tree and node and is called after the node is closed.  Additionally the callback function must accept additional keyword arguments (kwargs)  which are set in the following ways:\n\nIf the node is infeasible the kwarg node_infeasible is set to true.\nIf the node has a higher lower bound than the incumbent the kwarg worse_than_incumbent is set to true.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Node-Evaluation","page":"Branch-and-Bound tree functionality","title":"Node Evaluation","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Evaluation of the nodes and handling of branching.","category":"page"},{"location":"reference/custom/#Boscia.AbstractFrankWolfeNode","page":"Branch-and-Bound tree functionality","title":"Boscia.AbstractFrankWolfeNode","text":"AbtractFrankWolfeNode <: Bonobo.AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Boscia.FrankWolfeNode","page":"Branch-and-Bound tree functionality","title":"Boscia.FrankWolfeNode","text":"FrankWolfeNode <: AbstractFrankWolfeNode\n\nA node in the branch-and-bound tree storing information for a Frank-Wolfe subproblem.\n\nstd stores the id, lower and upper bound of the node. active_set store the active set structure. local_bounds instead of storing the complete LMO, it just stores the bounds specific to THIS node.     All other integer bounds are stored in the root. 'level' stores the level in the tree 'fwdualgaplimit' set the tolerance for the dual gap in the FW algorithms 'precomputedset' stores specifically the extreme points computed in DICG for warm-start. 'parentlowerboundbase' contains lower bound value of the parent node.  Needed     for updating pseudocosts. 'branchedon' contains the index of the parent. Required for updating pseudocosts. 'branchedright' Boolean value specifying if node resulted from a left or right branch. Needed     for updating pseudocosts. 'distancetoint' Stores information on the rounding amount at branching. Required     for correct scaling of pseudocosts.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Boscia.NodeInfo","page":"Branch-and-Bound tree functionality","title":"Boscia.NodeInfo","text":"NodeInfo\n\nHolds the necessary information of every node. This needs to be added by every AbstractNode as std::NodeInfo\n\nThis variant is more flexibel than Bonobo.BnBNodeInfo.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.evaluate_node!-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode}","page":"Branch-and-Bound tree functionality","title":"Bonobo.evaluate_node!","text":"Computes the relaxation at that node\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Bonobo.get_branching_nodes_info-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode, Int64}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_nodes_info","text":"Create the information of the new branching nodes  based on their parent and the index of the branching variable\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Bonobo.get_relaxed_values-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_relaxed_values","text":"Returns the solution vector of the relaxed problem at the node\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Callbacks","page":"Branch-and-Bound tree functionality","title":"Callbacks","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"There are two callbacks.  One for the Branch-and-Bound tree that records progress data, checks the time limit and prints the logs. The other is a callback for the Frank-Wolfe runs that runs some checks in each iteration.  Additionally, the computed vertices are added to the solution pool. Lastly, the Frank-Wolfe solve can be interrupted if either the dual bound has reached the current incumbent or  there are enough more promising nodes open.","category":"page"},{"location":"reference/custom/#Boscia.build_FW_callback-Tuple{Any, Any, Bool, Vararg{Any, 4}}","page":"Branch-and-Bound tree functionality","title":"Boscia.build_FW_callback","text":"Frank-Wolfe Callback.\n\nIs called in every Frank-Wolfe iteration. Node evaluation can be dynamically stopped here. Time limit is checked. If the vertex is providing a better incumbent, it is added as solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.build_bnb_callback-NTuple{22, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.build_bnb_callback","text":"Branch-and-Bound Callback. Collects statistics and prints logs if verbose is turned on.\n\nOutput of Boscia:     iter :          current iteration of Boscia     node id :       current node id     lower bound :   treelb(tree)     incumbent :     tree.incumbent     gap :           tree.incumbent-treelb(tree)     rel. gap :      dualgap/tree.incumbent     time :          total time of Boscia     time/nodes :    average time per node     FW time :       time spent in FW      LMO time :      time used by LMO     LMO calls :     number of computeextreme_point calls in FW     FW iterations : number of iterations in FW\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Tightenings","page":"Branch-and-Bound tree functionality","title":"Tightenings","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Tightenings are performed on node level and can be used either just for the node in question or globally. If the obejctive is strongly convex and/or sharp, this can also be used to tighten the lower bound at the current node. ","category":"page"},{"location":"reference/custom/#Boscia.dual_tightening-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.dual_tightening","text":"Tightening of the bounds at node level. Children node inherit the updated bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.global_tightening-Tuple{Any, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.global_tightening","text":"Use the gradient of the root node to tighten the global bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.prune_children-NTuple{5, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.prune_children","text":"Use strong convexity and/or sharpness to potentially remove one of the children nodes. If both sharpness and strong convexity parameters are provided, strong convexity is preferred.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.store_data_global_tightening-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.store_data_global_tightening","text":"Save the gradient of the root solution (i.e. the relaxed solution) and the  corresponding lower and upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.tightening_lowerbound-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.tightening_lowerbound","text":"Tighten the lower bound using strong convexity and/or sharpness of the objective.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Strong-and-Hybrid-Branching","page":"Branch-and-Bound tree functionality","title":"Strong and Hybrid Branching","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"We provide a strong branching strategy consisting of running Frank-Wolfe for only a few iterations to get an estimate of the bound increase. Due to the cost of strong branching, it is usually not advisable to run strong branching through the whole tree. Hence, we provide a hybrid branching which performs strong branching until a user specified depth and then switches to most-infeasible branching. ","category":"page"},{"location":"reference/custom/#Boscia.HybridStrongBranching","page":"Branch-and-Bound tree functionality","title":"Boscia.HybridStrongBranching","text":"Hybrid between partial strong branching and another strategy. perform_strong_branch(tree, node) -> Bool decides whether to perform strong branching or not.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.get_branching_variable-Union{Tuple{BLMO}, Tuple{Bonobo.BnBTree, Boscia.PartialStrongBranching{BLMO}, Bonobo.AbstractNode}} where BLMO<:Boscia.BoundedLinearMinimizationOracle","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_variable","text":"Get branching variable using strong branching. Create all possible subproblems, solve them and pick the one with the most progress.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.strong_up_to_depth","page":"Branch-and-Bound tree functionality","title":"Boscia.strong_up_to_depth","text":"strongupto_depth performs strong branching on nodes up to a predetermined depth, and the falls back to another rule\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"This section contain some utility function ","category":"page"},{"location":"reference/utilities/#Bonobo.terminated-Tuple{Bonobo.BnBTree{var\"#s1028\", Root, Value, Solution} where {var\"#s1028\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s1028\", Value}}}","page":"Utilities","title":"Bonobo.terminated","text":"Checks if the branch and bound can be stopped. By default (in Bonobo) stops then the priority queue is empty. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.build_active_set_by_domain_oracle-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Boscia.IntegerBounds, Any}} where {T, R}","page":"Utilities","title":"Boscia.build_active_set_by_domain_oracle","text":"Build a new start point and active set in case the split active set does not lead to a domain feasible iterate. First, try filtering the active set by the domain oracle. If all vertices are domain infeasible, solve the projection problem 1/2 * ||x - x||_2^2  where x is a domain- and bound-feasible point provided by the user.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.check_feasibility-Tuple{Boscia.TimeTrackingLMO}","page":"Utilities","title":"Boscia.check_feasibility","text":"Check feasibility and boundedness\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.has_integer_constraint-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.has_integer_constraint","text":"Check if at a given index we have an integer constraint respectivily.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_bound_feasible-Tuple{Boscia.IntegerBounds, Any}","page":"Utilities","title":"Boscia.is_bound_feasible","text":"Check if a given point v satisfies the given bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.is_valid_split","text":"Check wether a split is valid. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.min_via_enum","page":"Utilities","title":"Boscia.min_via_enum","text":"Naive optimization by enumeration. Default uses binary values. Otherwise, third argument should be a vector of n sets of possible values for the variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Boscia.relative_gap-Tuple{Any, Any}","page":"Utilities","title":"Boscia.relative_gap","text":"Compute relative gap consistently everywhere\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.restart_active_set-Tuple{Boscia.FrankWolfeNode, FrankWolfe.LinearMinimizationOracle, Int64}","page":"Utilities","title":"Boscia.restart_active_set","text":"Call this if the active set is empty after splitting. Remark: This should not happen when using a MIP solver for the nodes!\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Int64, Boscia.IntegerBounds}} where {T, R}","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split an active set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{T}, Tuple{FrankWolfe.DeletedVertexStorage{T}, Any, Int64, Any, Boscia.IntegerBounds}} where T","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split a discarded vertices set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.trivial_build_dicg_start_point-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"Utilities","title":"Boscia.trivial_build_dicg_start_point","text":"Default starting point function which generates a random vertex\n\n\n\n\n\n","category":"method"},{"location":"reference/fw_variant/#Frank-Wolfe-Variants","page":"Frank-Wolfe Variants","title":"Frank-Wolfe Variants","text":"","category":"section"},{"location":"reference/fw_variant/","page":"Frank-Wolfe Variants","title":"Frank-Wolfe Variants","text":"Here is the list with the currently supported Frank-Wolfe variants.","category":"page"},{"location":"reference/fw_variant/#Boscia.AwayFrankWolfe","page":"Frank-Wolfe Variants","title":"Boscia.AwayFrankWolfe","text":"Away-Frank-Wolfe\n\nIn every iteration, it computes the worst performing vertex, called away vertex, in the active set with regard to the gradient. If enough local progress can be made, weight is shifted from the away vertex to all other vertices. \n\nIn case lazification is activated, the FW vertex is only computed if not enough local progress can be guaranteed.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.BlendedConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.BlendedConditionalGradient","text":"Blended Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.BlendedPairwiseConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.BlendedPairwiseConditionalGradient","text":"Blended Pairwise Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.DecompositionInvariantConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.DecompositionInvariantConditionalGradient","text":"DICG-Frank-Wolfe\n\nThe Decomposition-invariant Frank-Wolfe. \n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.FrankWolfeVariant","page":"Frank-Wolfe Variants","title":"Boscia.FrankWolfeVariant","text":"Frank-Wolfe variant used to compute the problems at node level. A FrankWolfeVariant must implement\n\nsolve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\n\tadded_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace))\n\nIt may also implement build_frank_wolfe_workspace(x) which creates a workspace structure that is passed as last argument to solve_frank_wolfe.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.StandardFrankWolfe","page":"Frank-Wolfe Variants","title":"Boscia.StandardFrankWolfe","text":"Vanilla-Frank-Wolfe\n\nThe standard variant of Frank-Wolfe. In each iteration, the vertex v minimizing ∇f * (x-v) is computed. \n\nLazification cannot be used in this setting.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.solve_frank_wolfe","page":"Frank-Wolfe Variants","title":"Boscia.solve_frank_wolfe","text":"solve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\nadded_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace)\n\nReturns the optimal solution x to the node problem, its primal and dual gap and the active set. \n\n\n\n\n\n","category":"function"},{"location":"basics/#How-does-it-work?","page":"How does it work?","title":"How does it work?","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Boscia.jl is aimed at mixed-integer convex problems where the nonlinearity stems mostly from the objective function:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nmin    f(x)  \ntextst   xin C  x_I in mathbbZ^I\nendaligned text where  x in X subset mathbbR  x_I in mathbbZ^I","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where C is a compact, nonconvex set admitting a boundable linear minimization oracle (BLMO), i.e., a set over which optimizing a linear function can be done efficiently (comparatively to the original problem), even when bounds are added or modified.  Taking lower bounds l and upper bounds u, the oracle solves","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nv in argmin   langle x d rangle \ntextst   xin C \n  x_I in mathbbZ^I cap lu   text where  x in X subset mathbbR  x_I in mathbbZ^I\nendaligned","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where d will usually be the gradient of f evaluated at a given point x_t, nabla f(x_t).","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The new algorithmic framework is a branch-and-bound approach utilizing Frank-Wolfe (FW), also called Conditional Gradient (CG), methods as the node solver. A new aspect is that we solve the continuous sub problems in the nodes over the integer hull, i.e. the convex hull of the integer feasible points. Additionally, we exploit both general properties of the FW methods as well as the recent developments in the field of FW methods to speed up the solution process. ","category":"page"},{"location":"basics/#Frank-Wolfe-variants","page":"How does it work?","title":"Frank-Wolfe variants","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Frank-Wolfe algorithms used in Boscia.jl are implemented in FrankWolfe.jl.  The variants currently available in Boscia.jl are Vanilla Frank-Wolfe, Away-Frank-Wolfe (AFW), Blended Conditional Gradient (BCG) and Blended Pairwise Conditional Gradient (BPCG). The latter is set as the default variant.","category":"page"},{"location":"basics/#Branch-and-Bound-techniques","page":"How does it work?","title":"Branch-and-Bound techniques","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In this section, we present the techniques derived from Frank Wolfe that can be used in our framework .","category":"page"},{"location":"basics/#Dual-gap-based-termination","page":"How does it work?","title":"Dual gap based termination","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Frank-Wolfe methods produce primal feasible iterates and an FW gap, offering many inexpensive iterations with a gradually increasing dual bound.  This allows early termination of nodes when the dual bound reaches the best incumbent's objective value, avoiding unnecessary computations.  Nodes can be stopped anytime to produce a useful dual bound, aiding overall progress.  This flexibility contrasts with other nonlinear solvers, enabling more efficient optimization.","category":"page"},{"location":"basics/#Tree-state-dependent-termination-and-evolving-error","page":"How does it work?","title":"Tree state-dependent termination and evolving error","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"We implement different termination criteria in the node processing to reduce iterations, prioritizing nodes with promising lower bounds.  The dual bound provided by Frank-Wolfe is always valid, even if the dual gap is large. Thus, we solve nodes high in the tree, like the root node, with a coarse precision  and increase the precision with which a node is solved depending on its depth in the tree.  This approach balances efficiency and accuracy in solving optimization problems.","category":"page"},{"location":"basics/#Warm-starting-via-the-active-set","page":"How does it work?","title":"Warm-starting via the active set","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Many Frank-Wolfe variants provide a so-called active set, the convex combination of vertices representing the solution.  This can be used to warm start the children nodes by partitioning the active set of the parent.","category":"page"},{"location":"basics/#Branching","page":"How does it work?","title":"Branching","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"As default, we use most-infeasible branching which has shown good performance for many problems. Also, implemented are strong branching and the so-called hybrid branching which performs strong branching until a specific depth and afterwards switches to most-infeasible. It should be noted that strong branching is only adviseable for problems with very cheap LMO.  Otherwise, most-infeasible or hybrid branching with a shallow depth is to be preferred.","category":"page"},{"location":"basics/#Dual-fixing-and-tightening","page":"How does it work?","title":"Dual fixing and tightening","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In subproblems where variables are at bounds, our approach utilizes convexity and primal solutions to tighten dual bounds effectively.  Drawing from methods pioneered by Dantzig and extended in various contexts, we leverage Frank-Wolfe methods and FW gaps, adaptable to scenarios without explicit dual solutions, such as those involving MIP-based LMOs. We can also exploit strong convexity and sharpness to tighten the lowerbound of the tree.","category":"page"},{"location":"basics/#The-Bounded-Linear-Minimization-Oracles-(BLMO)","page":"How does it work?","title":"The Bounded Linear Minimization Oracles (BLMO)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Bounded Linear Minimization Oracle (BLMO) represent the feasible region C with the integrality constraints and handles the computation of mixed-integer linear sub-problems.  The bound management is also handled by the BLMO.  There are two options for the BLMO.","category":"page"},{"location":"basics/#Mixed-Integer-Linear-Solver-via-JuMP","page":"How does it work?","title":"Mixed Integer Linear Solver via JuMP","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The first option is a MIP solver like SCIP via the MathOptInterface or JuMP package.  For examples, see the Poisson Regression in poisson_reg.jl, the Sparse Regression with a grouped lasso in lasso.jl. In mps-example.jl, the feasible region is encoded in an MPS file.","category":"page"},{"location":"basics/#Customized-BLMO's","page":"How does it work?","title":"Customized BLMO's","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In addition, we have implemented some specific BLMOs like the hypercube, the probability and unit simplex. For examples, see approx_planted_point.jl.  In cube_blmo.jl, there is an example on how to implement Boscia's BLMO interface from scratch.","category":"page"},{"location":"reference/1_algorithms/#Algorithm-Interface","page":"Algorithm Interface","title":"Algorithm Interface","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia's solve function only requires the oracles of the objective function f and its gradient g as well as the BLMO encoding the feasible region.","category":"page"},{"location":"reference/1_algorithms/#Boscia.postsolve-NTuple{5, Any}","page":"Algorithm Interface","title":"Boscia.postsolve","text":"postsolve(tree, result, time_ref, verbose, max_iteration_post)\n\nRuns the post solve to optimize for the continuous variables if present. Is called if use_post_solve is enabled in the solve function. Prints solution statistics if verbose is set to true.        \n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.solve-Tuple{Any, Any, Boscia.BoundedLinearMinimizationOracle}","page":"Algorithm Interface","title":"Boscia.solve","text":"solve(f, g, blmo::BoundedLinearMinimizationOracle; ...)\n\nRequires\n\nf oracle of the objective function.\ng oracle of the gradient of the objective\nblmo encodes the feasible region and can handle additional bound constraints. This can either be a MIP solver instance (e.g., SCIP) or be a custom type (see polytope_blmos.jl). Has to be of type BoundedLinearMinimizationOracle (see blmo_interface.jl).\n\nReturns\n\nx the best solution found.\ntlmo the BLMO wrapped in a TimeTrackingLMO instance.\nresult a dictionary containg the statistics like number of nodes, total solving etc. It also contains information for plotting progress plots like the lower and upper bound progress.\n\nOptional settings\n\nsettings_bnb dictionary of settings for the branch-and-bound algorithm. Created via settings_bnb().\nsettings_frank_wolfe dictionary of settings for the Frank-Wolfe algorithm. Created via settings_frank_wolfe().\nsettings_tolerances dictionary of settings for the tolerances. Created via settings_tolerances().\nsettings_postprocessing dictionary of settings for the postprocessing. Created via settings_postprocessing().\nsettings_heuristic dictionary of settings for the heuristics. Created via settings_heuristic().\nsettings_tightening dictionary of settings for the tightening. Created via settings_tightening().\nsettings_domain dictionary of settings for the domain. Created via settings_domain().\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Optional-settings","page":"Algorithm Interface","title":"Optional settings","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia has a lot of settings to customize the solving process. These are grouped by general Branch-and-Bound settings, settings specific for Frank-Wolfe, tolerances settings for both the tree as well as Frank-Wolfe.  Furthermore, there are settings for the heuristics, for bound tightenings, postprocessing and for the case of a non-trivial domain, i.e. the objective cannot be evaluated at all points of the feasible region.","category":"page"},{"location":"reference/1_algorithms/#Boscia.settings_bnb-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_bnb","text":"settings_bnb(mode::Mode;...)\n\nSet the settings for the branch-and-bound algorithm.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the branch-and-bound algorithm.\n\nAvailable settings:\n\ntraverse_strategy encodes how to choose the next node for evaluation. By default the node with the best lower bound is picked.\nbranching_strategy fixes the branching strategy. By default, weuse MOST_INFEASIBLE, i.e. we branch on the entry which is the farthest away from being an integer.\nverbose if true, logs and solution statistics are printed. Per default, this is false.\nnode_limit maximum number of nodes to be evaluated. Per default, there is no limit.\ntime_limit algorithm will stop if the time limit is reached. Depending on the problem it is possible that no feasible solution has been found yet. On default, there is no time limit.\nprint_iter encodes after how many processed nodes the current node and solution status is printed. The logs are always printed if a new integral solution has been found. Per default, print_iter is set to 100`.\nbnb_callback optional callback function that is called after every node evaluation. It will be called before the Boscia internal callback handling the printing of the logs. It receives the tree, the node and the following keyword arguments: worse_than_incumbent=false, node_infeasible=false, lb_update=false.\nno_pruning if true, no pruning of nodes is performed. Per default, nodes are pruned if they have a lower bound which is worse than the best known solution. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\nignore_lower_bound if true, the lower bound obtain by Frank-Wolfe is ignored and in the logs, only Inf will be printed. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\nstart_solution an initial solution can be provided if known. It will be used as the initial incumbent.\nuse_shadow_set the shadow set is the set of discarded vertices which is inherited by the children nodes. It is used to avoid recomputing of vertices in case the BLMO is expensive. In case of a cheap BLMO, performance might improve by disabling this option. Per default, this is true.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_domain-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_domain","text":"settings_domain(mode::Mode;...)\n\nTo set settings for a non-trivial domain, i.e. if not all points of the feasible region are domain feasible.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the domain.\n\nAvailable settings:\n\ndomain_oracle given a point x: returns true if x is in the domain of f, else false. Per default, it always returns true. In case of the non-trivial domain oracle, the initial point has to be domain feasible for f and can be set via the active_set. Additionally, the user has to provide a functiondomain_point`, see below. Also, depending on the line search method, you might have to provide the domain oracle to it, too. The default line search Secant, for example, requires the domain oracle.\nfind_domain_point given the current node bounds return a domain feasible point respecting the bounds. If no such point can be found, return nothing. Only necessary for a non-trivial domain oracle.\nactive_set can be used to specify a starting point. By default, the direction (1,..,n) where n is the size of the problem is used to find a start vertex. This has to be of the type FrankWolfe.ActiveSet. Beware that the active set may only contain actual vertices of the feasible region.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_frank_wolfe-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_frank_wolfe","text":"settings_frank_wolfe(mode::Mode;...)\n\nOptions for the Frank-Wolfe algorithm used as node solver.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the Frank-Wolfe algorithm.\n\nAvailable settings:\n\nvariant the Frank-Wolfe variant to be used to solve the node problem. Options currently available are AwayFrankWolfe, BlendedConditionalGradient, BlendedPairwiseConditionalGradient, DecompositionInvariantConditionalGradient and StandardFrankWolfe. Per default, this is set to BlendedPairwiseConditionalGradient.\nline_search specifies the line search method used in the FrankWolfe variant. Default is the FrankWolfe.Secant line search. For other available types, check the FrankWolfe.jl package.\nmax_fw_iter maximum number of iterations in a Frank-Wolfe run. Per default, this is set to 10000.\nfw_timeout time limit for the Frank-Wolfe runs. Per default, there is no time limit. It is preferred to set the iteration limit but this can be used as a fallback and/or if the BLMO call is time consuming.\nmin_fw_iterations the minimum number of Frank-Wolfe iterations performed in the node evaluation. Per default, this is set to 5.\nfw_verbose if true, the Frank-Wolfe logs are printed at each node. Mostly meant for debugging. Per default, this is false.\nlazy flag specifies whether the lazification of the Frank-Wolfe variant should be used. Per default true. Note that it has no effect on standard Frank-Wolfe.\nlazy_tolerance decides how much progress is deemed enough to not have to call the LMO. Only used if the lazy flag is activated. Per default, this is set to 2.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_heuristic-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_heuristic","text":"settings_heuristic(mode::Mode;...)\n\nSet the settings for the heuristics.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the heuristics.\n\nAvailable settings:\n\ncustom_heuristics list of custom heuristics from the user. Heuristics can be created via the Boscia.Heuristic constructor. It requires a function, a probability and an identifier (symbol). Note that the heuristics defined in Boscia themselves don't have to be added here and can be set via the probability parameters below.\npost_heuristics_callback callback function called whenever a new solution is found and added to the tree. \nprob_rounding the probability for calling the simple rounding heuristic. Since the feasibility has to be checked, it might be expensive to do this for every node. Per default, this is activated for every node.\nfollow_gradient_prob the probability for calling the follow-the-gradient heuristic. Per default, this is 0.0.\nfollow_gradient_steps the number of steps for the follow-the-gradient heuristic. Per default, this is 10.\nrounding_lmo_01_prob the probability for calling the rounding-LMO-01 heuristic. Per default, this is 0.0.\nprobability_rounding_prob the probability for calling the probability-rounding heuristic. Per default, this is 0.0.\nhyperplane_aware_rounding_prob the probability for calling the hyperplane-aware-rounding heuristic. Per default, this is 0.0.\nadd_all_solutions if true, all solutions found by the heuristics, Frank-Wolfe or the BLMO are added to the tree. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_postprocessing-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_postprocessing","text":"settings_postprocessing(mode::Mode;...)\n\nSet the settings for the postprocessing.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the postprocessing.\n\nAvailable settings:\n\nuse_postsolve if true, runs the specified Frank-Wolfe variant on the problem with the integral variables fixed to the solution, i.e. it only optimizes over the continuous variables. This might improve the solution if one has many continuous variables. Per default, this is true.\nmax_iteration_post maximum number of iterations in the Frank-Wolfe run during postsolve. Per default, this is set to 10000.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_tightening-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_tightening","text":"settings_tightening(mode::Mode;...)\n\nSet the tightening parameters.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the tightening.\n\nAvailable settings:\n\ndual_tightening flag to decide  whether to use dual tightening techniques at node level. Note that this only porvides valid tightenings if your function is convex! Per default, this is true.\nglobal_dual_tightening flag to decide whether to generate dual tightenings from new solutions that are gloablly valid. Per default, this is true.\nstrong_convexity strong convexity parameter of the objective f, used for tightening the dual bound at every node. Per default, this is set to 0.0.\nsharpness_constant - the constant M > 0 for (θ, M)-sharpness. f is (θ, M)-sharpness: f satisfies min_{x^* ∈ X^*} || x - x^* || ≤ M (f(x) - f^(x^*))^θ where X^* is the set of minimizer of f. Note that tightenings using sharpness are only valid if the problem has a unique minimizer, i.e. f is stricly convex! Per default, this is set to 0.0.\nsharpness_exponent - the exponent θ ∈ [0, 1/2] for (θ, M)-sharpness. Per default, this is set to Inf.\npropagate_bounds optional function that allows the user to propagate and tighten bounds depending on the node. Receives the tree and the node as input.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_tolerances-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_tolerances","text":"settings_tolerances(mode::Mode;...)\n\nSet the tolerances for the Frank-Wolfe algorithm. These are tolerances both for the Branch-and-Bound tree as well as for the Frank-Wolfe variant used as node solver.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of tolerances for the Frank-Wolfe algorithm.\n\nAvailable settings:\n\nfw_epsilon the solving precision of Frank-Wolfe at the root node.\ndual_gap absolute dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to 1e-6.\nrel_dual_gap relative dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to 1e-2.\ndual_gap_decay_factor the FrankWolfe tolerance at a given level i in the tree is given by fw_epsilon * dual_gap_decay_factor^i until we reach the min_node_fw_epsilon. Per default, this is set to 0.8.\nmin_number_lower if not Inf, evaluation of a node is stopped if at least min_number_lower open nodes have a better lower bound. Per default, this is set to Inf.\nmin_node_fw_epsilon smallest fw epsilon tolerance, see also dual_gap_decay_factor. Per default, this is set to 1e-6.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Definitions","page":"Algorithm Interface","title":"Definitions","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia defines its own solving state.  Additionally, Boscia has different modes, like the DEFAULT_MODE and HEURISTIC_MODE. These have their own default settings for the optional parameters.","category":"page"},{"location":"reference/2_blmo_build/#The-Bounded-Linear-Minimization-Oracle-(BLMO)","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"The Bounded Linear Minimization Oracle (BLMO) is an oracle solving the problem","category":"page"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"beginaligned\nv in argmin   langle x d rangle \ntextst   xin C \n  x_I in mathbbZ^I cap lu   text where  x in X subset mathbbR  x_I in mathbbZ^I\nendaligned","category":"page"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"where the direction d is usually the gradient evaluated at a certain point. The bounds are specified at the node level and correspond to bounds obtained by branching.","category":"page"},{"location":"reference/2_blmo_build/#General-BLMO-Interface","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"General BLMO Interface","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"In the following, the functions for the general BLMO interface are listed. Functions without signature needs to be implemented by a new BLMO type. Functions with signature are optional and are usually for statistics and additional safety checks.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.BLMOStatus","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.BLMOStatus","text":"Enum encoding the status of the Bounded Linear Minimization Oracle. Currently available: OPTIMAL, INFEASIBLE and UNBOUNDED.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.BoundedLinearMinimizationOracle","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.BoundedLinearMinimizationOracle","text":"BLMO\n\nSupertype for the Bounded Linear Minimization Oracles\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.add_bound_constraint!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.add_bound_constraint!","text":"Add bound constraint.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.build_LMO_correct-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO_correct","text":"build_LMO_correct(blmo::BoundedLinearMinimizationOracle, node_bounds)\n\nCheck if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_global_bounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_global_bounds","text":"Read global bounds from the problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.check_feasibility-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_feasibility","text":"check_feasibility(blmo::BoundedLinearMinimizationOracle)\n\nCheck if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_infeasible_vertex-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_infeasible_vertex","text":"check_infeasible_vertex(blmo::BoundedLinearMinimizationOracle, tree)\n\nDeal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.delete_bounds!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.delete_bounds!","text":"Delete bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, Boscia.BoundedLinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"find_best_solution(f::Function, blmo::BoundedLinearMinimizationOracle, vars, domain_oracle)\n\nFind best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.free_model-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.free_model","text":"free_model(blmo::BoundedLinearMinimizationOracle)\n\nFree model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_BLMO_solve_data-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_BLMO_solve_data","text":"get_BLMO_solve_data(blmo::BoundedLinearMinimizationOracle)\n\nGet solve time, number of nodes and number of iterations, if applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_bound","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_bound","text":"Read bound value for c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_int_var","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_int_var","text":"Get the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_integer_variables","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_integer_variables","text":"Get list of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_list_of_variables","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_list_of_variables","text":"Get list of variables indices.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_lower_bound_list","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_lower_bound_list","text":"Get the list of lower bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_tol-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_tol","text":"get_tol(blmo::BoundedLinearMinimizationOracle)\n\nGet solving tolerance for the BLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_upper_bound_list","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_upper_bound_list","text":"Get the list of upper bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_variables_pointers-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_variables_pointers","text":"get_variables_pointers(blmo::BoundedLinearMinimizationOracle, tree)\n\nList of all variable pointers. Depends on how you save your variables internally. In the easy case, this is simply collect(1:N). Is used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_integer_constraint","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_integer_constraint","text":"Has variable an integer constraint?\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.indicator_present-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.indicator_present","text":"indicator_present(blmo::BoundedLinearMinimizationOracle)\n\nAre indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_bound_in","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_bound_in","text":"To check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_constraint_on_int_var","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_constraint_on_int_var","text":"Check if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_indicator_feasible-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_indicator_feasible","text":"is_indicator_feasible(blmo::BoundedLinearMinimizationOracle, v; atol=1e-6, rtol=1e-6)\n\nIs a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_inface_feasible-Tuple{Boscia.BoundedLinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_inface_feasible","text":"Is a given point a on the minimal face containing the given x?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_linear_feasible","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_linear_feasible","text":"Is a given point v linear feasible for the model? That means does v satisfy all bounds and other linear constraints?\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Boscia.BoundedLinearMinimizationOracle, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_valid_split","text":"is_valid_split(tree::Bonobo.BnBTree, blmo::BoundedLinearMinimizationOracle, vidx::Int)\n\nCheck whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.set_bound!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.set_bound!","text":"Change the value of the bound c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#FrankWolfe.compute_extreme_point","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.compute_extreme_point","text":"Implement FrankWolfe.compute_extreme_point\n\nGiven a direction d solves the problem     min_x d^T x where x has to be an integer feasible point\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#FrankWolfe.compute_inface_extreme_point-Tuple{Boscia.BoundedLinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.compute_inface_extreme_point","text":"Implement FrankWolfe.compute_inface_extreme_point\n\nGiven a direction d and feasible point x solves the problem     min_a d^T a where a has to be an integer feasible point and on the minimal face containing x\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#FrankWolfe.dicg_maximum_step-Tuple{Boscia.BoundedLinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.dicg_maximum_step","text":"Implement FrankWolfe.dicg_maximum_step\n\nGiven a direction d and feasible point x solves the problem     argmax_γ (x - γ * d) ∈ P where P is feasible set\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#FrankWolfe.is_decomposition_invariant_oracle-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.is_decomposition_invariant_oracle","text":"Implement FrankWolfe.is_decomposition_invariant_oracle\n\nCheck if necessary DICG-specific orcales are implemented.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#MathOptInterface-(MOI)-BLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"MathOptInterface (MOI) BLMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"With this BLMO type, any (MIP) solver that provides an interface to MathOptInterface and JuMP can be used in Boscia. Note that we only require the feasible region, i.e. no objective has to be set.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.MathOptBLMO-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.MathOptBLMO","text":"MathOptBLMO(lmo::FrankWolfe.MathOptLMO)\n\nBuild an instance of MathOptBLMO from a FrankWolfe.MathOptLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Base.convert-Tuple{Type{Boscia.MathOptBLMO}, FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Base.convert","text":"Convert object of Type FrankWolfe.MathOptLMO into Boscia.MathOptBLMO and viceversa.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Bonobo.get_branching_variable-Union{Tuple{OT}, Tuple{Bonobo.BnBTree, Boscia.PartialStrongBranching{Boscia.MathOptBLMO{OT}}, Bonobo.AbstractNode}} where OT<:MathOptInterface.AbstractOptimizer","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Bonobo.get_branching_variable","text":"Bonobo.get_branching_variable(tree::Bonobo.BnBTree, branching::PartialStrongBranching{MathOptBLMO{OT}}, node::Bonobo.AbstractNode,) where {OT<:MOI.AbstractOptimizer}\n\nBehavior for strong branching.  Note that in constrast to the ManagedBLMO type, we filter out the integer and binary constraints as solving general MIP in strong branching would be very expensive.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.add_bound_constraint!-Tuple{Boscia.MathOptBLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.add_bound_constraint!","text":"add_bound_constraint!(blmo::MathOptBLMO, key, value, sense::Symbol)\n\nAdd bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_LMO_correct-Tuple{Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO_correct","text":"build_LMO_correct(blmo, node_bounds)\n\nCheck if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_global_bounds-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_global_bounds","text":"build_global_bounds(blmo::MathOptBLMO, integer_variables)\n\nRead global bounds from the problem\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_feasibility-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_feasibility","text":"check_feasibility(blmo::MathOptBLMO)\n\nCheck if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_infeasible_vertex-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_infeasible_vertex","text":" check_infeasible_vertex(blmo::MathOptBLMO, tree)\n\nDeal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.delete_bounds!-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.delete_bounds!","text":"delete_bounds!(blmo::MathOptBLMO, cons_delete)\n\nDelete bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.explicit_bounds_binary_var-Tuple{Boscia.MathOptBLMO, Boscia.IntegerBounds}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.explicit_bounds_binary_var","text":"explicit_bounds_binary_var(blmo::MathOptBLMO, global_bounds::IntegerBounds)\n\nAdd explicit bounds for binary variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, Boscia.MathOptBLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"find_best_solution(f::Function, blmo::MathOptBLMO, vars, domain_oracle)\n\nFind best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, MathOptInterface.AbstractOptimizer, Vector{MathOptInterface.VariableIndex}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":" function find_best_solution(f::Function, o::MOI.AbstractOptimizer, vars::Vector{MOI.VariableIndex}, domain_oracle,)\n\nFinds the best solution in the Optimizer's solution storage, based on the objective function f. Returns the solution vector and the corresponding best value.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.free_model-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.free_model","text":" free_model(blmo::MathOptBLMO)\n\nFree model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_BLMO_solve_data-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_BLMO_solve_data","text":"get_BLMO_solve_data(blmo::MathOptBLMO)\n\nGet solve time, number of nodes and number of simplex iterations.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_binary_variables-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_binary_variables","text":"get_binary_variables(blmo::MathOptBLMO)\n\nGet list of binary variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_bound-Tuple{Boscia.MathOptBLMO, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_bound","text":"get_bound(blmo::MathOptBLMO, c_idx, sense::Symbol)\n\nRead bound value for c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_int_var-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_int_var","text":" get_int_var(blmo::MathOptBLMO, c_idx)\n\nGet the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_integer_variables-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_integer_variables","text":" get_integer_variables(blmo::MathOptBLMO)\n\nGet list of integer variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_list_of_variables-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_list_of_variables","text":"get_list_of_variables(blmo::MathOptBLMO)\n\nGet list of variables indices and the total number of variables.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_lower_bound_list-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_lower_bound_list","text":"get_lower_bound_list(blmo::MathOptBLMO)\n\nGet the list of lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_tol-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_tol","text":" get_tol(blmo::MathOptBLMO)\n\nGet solving tolerance for the BLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_upper_bound_list-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_upper_bound_list","text":"get_upper_bound_list(blmo::MathOptBLMO)\n\nGet the list of upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_variables_pointers-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_variables_pointers","text":"get_variables_pointers(blmo, tree)\n\nList of all variable pointers. Depends on how you save your variables internally. Is used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_binary_constraint-Tuple{Boscia.MathOptBLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_binary_constraint","text":"has_binary_constraint(blmo::MathOptBLMO, idx::Int)\n\nHas variable a binary constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_integer_constraint-Tuple{Boscia.MathOptBLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_integer_constraint","text":"has_integer_constraint(blmo::MathOptBLMO, idx::Int)\n\nDoes the variable have an integer constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.indicator_present-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.indicator_present","text":"indicator_present(blmo::MathOptBLMO)\n\nAre indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_bound_in-Tuple{Boscia.MathOptBLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_bound_in","text":"is_bound_in(blmo::MathOptBLMO, c_idx, bounds)\n\nTo check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_constraint_on_int_var-Tuple{Boscia.MathOptBLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_constraint_on_int_var","text":"is_constraint_on_int_var(blmo::MathOptBLMO, c_idx, int_vars)\n\nCheck if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_indicator_feasible-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_indicator_feasible","text":"is_indicator_feasible(blmo::MathOptBLMO, v; atol=1e-6, rtol=1e-6)\n\nIs a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_inface_feasible-Tuple{Boscia.MathOptBLMO, AbstractVector, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_inface_feasible","text":"Is a given point v inface feasible for the model?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_linear_feasible-Tuple{Boscia.MathOptBLMO, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_linear_feasible","text":"is_linear_feasible(blmo::MathOptBLMO, v::AbstractVector)\n\nIs a given point v linear feasible for the model?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Boscia.MathOptBLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_valid_split","text":"is_valid_split(tree::Bonobo.BnBTree, blmo::MathOptBLMO, vidx::Int)\n\nCheck whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.set_bound!-Tuple{Boscia.MathOptBLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.set_bound!","text":"set_bound!(blmo::MathOptBLMO, c_idx, value, sense::Symbol)\n\nChange the value of the bound c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.solve-Tuple{Any, Any, FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.solve","text":"The solve  function receiving a FrankWolfe.MathOptLMO.  Converts the lmo into an instance of Boscia.MathOptBLMO and calls the main solve function.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#FrankWolfe.compute_extreme_point-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.compute_extreme_point","text":"compute_extreme_point(blmo::MathOptBLMO, d; kwargs...)\n\nIs implemented in the FrankWolfe package in file \"moi_oracle.jl\".\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Managed-BLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Managed BLMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Sometimes the linear problem over the feasible region can be computed via a combinatorial algorithm that is more efficient than formulating the problem as a MIP. If one does not want to implement the BLMO interface from scratch which requires multiple methods to be provided, we provide the ManagedBLMO. It handles the bound management, so that the user has to implement only a few methods.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.ManagedBoundedLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ManagedBoundedLMO","text":"ManagedBoundedLMO{SBLMO<:SimpleBoundableLMO} <: BoundedLinearMinimizationOracle\n\nA Bounded Linear Minimization Oracle that manages the bounds.\n\nsimple_lmo an LMO of type Simple Boundable LMO.  \nlower_bounds list of lower bounds for the integer variables recorded in int_vars. If there is no specific lower bound, set corresponding entry to -Inf.\nupper_bounds list of upper bounds for the integer variables recorded in int_vars. If there is no specific upper bound, set corresponding entry to Inf.\nn total number of variables.\nint_vars list of indices of the integer variables.\nsolving_time the time to evaluate compute_extreme_point.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.SimpleBoundableLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.SimpleBoundableLMO","text":"SimpleBoundableLinearMinimizationOracle\n\nA \"simple\" BLMO that computes the extreme point given a linear objective and the node specific bounds on the integer variables. Can be stateless since all of the bound management is done by the ManagedBoundedLMO.   \n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point\n\nComputes the extreme point given an direction d, the current lower and upper bounds on the integer variables, and the set of indices of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_simple_linear_feasible","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_simple_linear_feasible","text":"is_simple_linear_feasible\n\nChecks whether a given point v is satisfying the constraints on the problem. Note that the bounds on the integer variables are being checked by the ManagedBoundedLMO and do not have to be check here. \n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Polytopes","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Polytopes","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Here are some preimplemented polytopes. We have the hypercube, the unit simplex and the probability simplex.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.BirkhoffBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.BirkhoffBLMO","text":"BirkhoffBLMO\n\nA simple LMO that computes the extreme point given the node specific bounds on the integer variables. Can be stateless since all of the bound management is done by the ManagedBoundedLMO.   \n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.CubeSimpleBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.CubeSimpleBLMO","text":"CubeSimpleBLMO{T}(lower_bounds, upper_bounds)\n\nHypercube with lower and upper bounds implementing the SimpleBoundableLMO interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.ProbabilitySimplexSimpleBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ProbabilitySimplexSimpleBLMO","text":"ProbablitySimplexSimpleBLMO(N)\n\nThe scaled probability simplex with ∑ x = N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.ReverseKnapsackBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ReverseKnapsackBLMO","text":"ReverseKnapsackBLMO(N, upper_bounds)\n\nBLMO denotes the reverse Knapsack constraint: ∑ x ≥ N. We assume x ≥ 0.  Explicit upper bounds are needed, otherwise the feasible region is unbounded.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.UnitSimplexSimpleBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.UnitSimplexSimpleBLMO","text":"UnitSimplexSimpleBLMO(N)\n\nThe scaled unit simplex with ∑ x ≤ N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.BirkhoffBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"Computes the extreme point given an direction d, the current lower and upper bounds on the integer variables, and the set of integer variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.CubeSimpleBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":" bounded_compute_extreme_point(sblmo::CubeSimpleBLMO, d, lb, ub, int_vars; kwargs...)\n\nIf the entry is positve, choose the lower bound. Else, choose the upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.ProbabilitySimplexSimpleBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(sblmo::ProbabilitySimplexSimpleBLMO, d, lb, ub, int_vars; kwargs...)\n\nAssign the largest possible values to the entries corresponding to the smallest entries of d.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.ReverseKnapsackBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"Entries corresponding to non positive entries in d, are assigned their upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.UnitSimplexSimpleBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(sblmo::UnitSimplexSimpleBLMO, d, lb, ub, int_vars; kwargs...)\n\nFor all positive entries of d, assign the corresponding lower bound. For non-positive entries, assign largest possible value in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.BirkhoffBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"Computes the inface extreme point given an direction d, x, the current lower and upper bounds on the integer variables, and the set of integer variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.CubeSimpleBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"If the entry in x is at the boundary, choose the corresponding bound. Otherwise, if the entry in direction is positve, choose the lower bound. Else, choose the upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.ProbabilitySimplexSimpleBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"Fix the corresponding entries to the boudary based on the given x. Assign the largest possible values to the unfixed entries corresponding to the smallest entries of d.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.UnitSimplexSimpleBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"For boundary entries of x, assign the corresponding boudary. For all positive entries of d, assign the corresponding lower bound. For non-positive entries, assign largest possible value in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.BirkhoffBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"LMO-like operation which computes a vertex minimizing in direction on the face defined by the current fixings. Fixings are maintained by the oracle (or deduced from x itself).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.CubeSimpleBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.ProbabilitySimplexSimpleBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.UnitSimplexSimpleBLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and the sum of entries should satisfy inequality constraint. Return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_simple_linear_feasible-Tuple{Boscia.BirkhoffBLMO, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_simple_linear_feasible","text":"The sum of each row and column has to be equal to 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedBoundedLMO{Boscia.ProbabilitySimplexSimpleBLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":" rounding_hyperplane_heuristic(tree::Bonobo.BnBTree, tlmo::TimeTrackingLMO{ManagedBoundedLMO{ProbabilitySimplexSimpleBLMO}}, x)\n\nHyperplane-aware rounding for the probability simplex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedBoundedLMO{Boscia.ReverseKnapsackBLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"Hyperplane-aware rounding for the reverse knapsack constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedBoundedLMO{Boscia.UnitSimplexSimpleBLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"rounding_hyperplane_heuristic(tree::Bonobo.BnBTree, tlmo::TimeTrackingLMO{ManagedBoundedLMO{UnitSimplexSimpleBLMO}}, x)\n\nHyperplane-aware rounding for the unit simplex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Time-Tracking-BLMO-Wrapper","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Time Tracking BLMO Wrapper","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"This wrapper keeps track of the statistics like solving time of the BLMO, the number of calls etc.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO{BLMO<:BoundedLinearMinimizationOracle} <: FrankWolfe.LinearMinimizationOracle\n\nA wrapper for the BLMO tracking the solving time, number of calls etc. Is created in Boscia itself.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO-Tuple{Boscia.BoundedLinearMinimizationOracle, Any, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO(blmo::BoundedLinearMinimizationOracle, int_vars)\n\nConstructor with just the blmo.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO-Tuple{Boscia.BoundedLinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO(blmo::BoundedLinearMinimizationOracle)\n\nConstructor with just the blmo.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.reset!-Tuple{Boscia.TimeTrackingLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.reset!","text":"reset!(tlmo::TimeTrackingLMO)\n\nIf we want to reset the info between nodes in the Branch-and-Bound tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#FrankWolfe.compute_extreme_point-Tuple{Boscia.TimeTrackingLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.compute_extreme_point","text":"FrankWolfe.compute_extreme_point(tlmo::TimeTrackingLMO, d; kwargs...)\n\nCompute the extreme point and collect statistics.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Build-LMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Build LMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Given the global bounds on the integer variables and the bounds at the node level, this builds the BLMO instance for the specific node. This way, the BLMO can be stored in the tree as opposed to every node having a copy of it.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.build_LMO-Tuple{Boscia.BoundedLinearMinimizationOracle, Boscia.IntegerBounds, Boscia.IntegerBounds, Vector{Int64}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO","text":"Build node LMO from global LMO\n\nFour action can be taken:\n\nKEEP   constraint is as saved in the global bounds\nCHANGE lower/upper bound is changed to the node specific one\nDELETE custom bound from the previous node that is invalid at current node and has to be deleted\nADD    bound has to be added for this node because it does not exist in the global bounds (e.g. variable bound is a half open interval globally) \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Integer-Bounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Integer Bounds","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"The data structure that records the bounds on the integer/binary variables.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.IntegerBounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.IntegerBounds","text":"IntegerBounds\n\nKeeps track of the bounds of the integer (binary) variables.\n\nlower_bounds dictionary of Float64, index is the key.\nupper_bounds dictionary of Float64, index is the key.\n\n\n\n\n\n","category":"type"},{"location":"#Boscia.jl","page":"Home","title":"Boscia.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Dev) (Image: Stable) (Image: Coverage) (Image: DOI) (Image: Aqua QA)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A solver for Mixed-Integer Convex Optimization that uses Frank-Wolfe methods for convex relaxations and a branch-and-bound algorithm.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Boscia.jl solver combines (a variant of) the Frank-Wolfe algorithm with a branch-and-bound-like algorithm to solve mixed-integer convex optimization problems of the form min_x  C x_I  mathbbZ^n f(x), where f is a differentiable convex function, C is a convex and compact set, and I is a set of indices of integral variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approach is especially effective when we have a method to optimize a linear function over C and the integrality constraints in a computationally efficient way. The set C can modelled using the Julia package MathOptInterface (or JuMP).  We also implemented simple polytopes like the hypercube, the unit simplex and the probability simplex. Also, we intend to extend this list by combinatorial polytopes, e.g. the matching polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The paper presenting the package with mathematical explanations and numerous examples can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convex mixed-integer optimization with Frank-Wolfe methods: 2208.11010","category":"page"},{"location":"","page":"Home","title":"Home","text":"Boscia.jl uses FrankWolfe.jl for solving the convex subproblems, Bonobo.jl for managing the search tree, and oracles optimizing linear functions over the feasible set, for instance calling SCIP or any MOI-compatible solver to solve MIP subproblems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add the Boscia stable release with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Boscia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or get the latest master branch with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/ZIB-IOL/Boscia.jl\", rev=\"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the installation of SCIP.jl, see here. Note, for Windows users, you do not need to download the SCIP binaries, you can also use the installer provided by SCIP.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example to get started. For more examples, see the examples folder in the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Boscia\nusing FrankWolfe\nusing Random\nusing SCIP\nusing LinearAlgebra\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nn = 6\n\nconst diffw = 0.5 * ones(n)\no = SCIP.Optimizer()\n\nMOI.set(o, MOI.Silent(), true)\n\nx = MOI.add_variables(o, n)\n\nfor xi in x\n    MOI.add_constraint(o, xi, MOI.GreaterThan(0.0))\n    MOI.add_constraint(o, xi, MOI.LessThan(1.0))\n    MOI.add_constraint(o, xi, MOI.ZeroOne())\nend\n\nlmo = FrankWolfe.MathOptLMO(o)\n\nfunction f(x)\n    return sum(0.5*(x.-diffw).^2)\nend\n\nfunction grad!(storage, x)\n    @. storage = x-diffw\nend\n\nx, _, result = Boscia.solve(f, grad!, lmo, settings_bnb=Boscia.settings_bnb(verbose = true))\n\nBoscia Algorithm.\n\nParameter settings.\n\t Tree traversal strategy: Move best bound\n\t Branching strategy: Most infeasible\n\t FrankWolfe variant: Blended Pairwise Conditional Gradient\n\t Line Search Method: Secant\n\t Lazification: true\n\t Lazification Tolerance: 2\n\t Absolute dual gap tolerance: 1.000000e-06\n\t Relative dual gap tolerance: 1.000000e-02\n\t Frank-Wolfe subproblem tolerance: 1.000000e-02\n\t Frank-Wolfe dual gap decay factor: 8.000000e-01\n\t Additional kwargs: \n\t Total number of variables: 6\n\t Number of integer variables: 6\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n   Iter  Open          Bound      Incumbent      Gap (abs)      Gap (rel)       Time (s)      Nodes/sec      FW (ms)   LMO (ms)  LMO (calls c)   FW (its) #activeset  #shadow\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n*     1     2   0.000000e+00   7.500000e-01   7.500000e-01            Inf   2.000000e-03   1.500000e+03            1          1              4          2        1        0\n    100    27   6.250000e-01   7.500000e-01   1.250000e-01   2.000000e-01   6.400000e-02   1.984375e+03            0          0            326          0        1        0\n    127     0   7.500000e-01   7.500000e-01   0.000000e+00   0.000000e+00   7.300000e-02   1.739726e+03            0          0            380          0        1        0\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nSolution Statistics.\n\t Solution Status: Optimal (tree empty)\n\t Primal Objective: 0.75\n\t Dual Bound: 0.75\n\t Dual Gap (relative): 0.0\n\nSearch Statistics.\n\t Total number of nodes processed: 127\n\t Total number of lmo calls: 380\n\t Total time (s): 0.074\n\t LMO calls / sec: 5135.135135135135\n\t Nodes / sec: 1716.2162162162163\n\t LMO calls / node: 2.9921259842519685\n\n\t Total number of global tightenings: 0\n\t Global tightenings / node: 0.0\n\t Total number of local tightenings: 0\n\t Local tightenings / node: 0.0\n\t Total number of potential local tightenings: 0","category":"page"},{"location":"reference/0_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/0_reference/","page":"API Reference","title":"API Reference","text":"In this section we present the algorithm interface and the possible settings.","category":"page"}]
}
