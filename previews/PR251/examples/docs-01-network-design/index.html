<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Network Design Problem · Boscia.jl</title><meta name="title" content="Network Design Problem · Boscia.jl"/><meta property="og:title" content="Network Design Problem · Boscia.jl"/><meta property="twitter:title" content="Network Design Problem · Boscia.jl"/><meta name="description" content="Documentation for Boscia.jl."/><meta property="og:description" content="Documentation for Boscia.jl."/><meta property="twitter:description" content="Documentation for Boscia.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Boscia.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../basics/">How does it work?</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Network Design Problem</a><ul class="internal"><li><a class="tocitem" href="#Problem-Description"><span>Problem Description</span></a></li><li><a class="tocitem" href="#Key-Difference-Between-Approaches"><span>Key Difference Between Approaches</span></a></li><li><a class="tocitem" href="#Data-Structure"><span>Data Structure</span></a></li><li><a class="tocitem" href="#Load-Network"><span>Load Network</span></a></li><li><a class="tocitem" href="#Shortest-Path-Dijkstra-Implementation"><span>Shortest Path Dijkstra Implementation</span></a></li><li><a class="tocitem" href="#Custom-LMO-using-Shortest-Path"><span>Custom LMO using Shortest Path</span></a></li><li><a class="tocitem" href="#MOI-Model-Setup"><span>MOI Model Setup</span></a></li><li><a class="tocitem" href="#Objective-Function-and-Gradient"><span>Objective Function and Gradient</span></a></li><li><a class="tocitem" href="#Helper-Functions-for-Results"><span>Helper Functions for Results</span></a></li><li><a class="tocitem" href="#Example-Execution"><span>Example Execution</span></a></li><li><a class="tocitem" href="#Solve-with-MOI-based-LMO"><span>Solve with MOI-based LMO</span></a></li><li><a class="tocitem" href="#Solve-with-Custom-LMO"><span>Solve with Custom LMO</span></a></li><li><a class="tocitem" href="#Comparison-of-Results"><span>Comparison of Results</span></a></li></ul></li><li><a class="tocitem" href="../docs-02-graph-isomorphism/">Graph Isomorphism Problem</a></li><li><a class="tocitem" href="../docs-03-optimal-design/">Optimal Design of Experiments</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../reference/1_algorithms/">Algorithm Interface</a></li><li><a class="tocitem" href="../../reference/2_blmo_build/">The Bounded Linear Minimization Oracle (BLMO)</a></li><li><a class="tocitem" href="../../reference/custom/">Branch-and-Bound tree functionality</a></li><li><a class="tocitem" href="../../reference/fw_variant/">Frank-Wolfe Variants</a></li><li><a class="tocitem" href="../../reference/utilities/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Network Design Problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Network Design Problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/Boscia.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/Boscia.jl/blob/main/examples/docs-01-network-design.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>Network Design Problem Example</p><p>This example demonstrates solving a network design problem using Boscia.jl with two approaches:</p><ol><li>MOI-based LMO: Using MathOptInterface to model the feasible region</li><li>Custom LMO: Using a customized Linear Minimization Oracle based on shortest path algorithms</li></ol><h2 id="Problem-Description"><a class="docs-heading-anchor" href="#Problem-Description">Problem Description</a><a id="Problem-Description-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Description" title="Permalink"></a></h2><p>We solve a transportation network design problem where:</p><ul><li>Some edges have been removed from the network</li><li>We decide which edges to restore (binary decision y[e])</li><li>Traffic flows are routed to minimize total travel time (with BPR congestion)</li><li>Flow conservation constraints must be satisfied</li><li>Linking constraints: x[e] &lt;= M * y<a href="flow on removed edges only if restored">e</a></li></ul><h2 id="Key-Difference-Between-Approaches"><a class="docs-heading-anchor" href="#Key-Difference-Between-Approaches">Key Difference Between Approaches</a><a id="Key-Difference-Between-Approaches-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Difference-Between-Approaches" title="Permalink"></a></h2><p><strong>IMPORTANT</strong>: The two approaches solve DIFFERENT formulations of the same problem!</p><h3 id="MOI-based-LMO"><a class="docs-heading-anchor" href="#MOI-based-LMO">MOI-based LMO</a><a id="MOI-based-LMO-1"></a><a class="docs-heading-anchor-permalink" href="#MOI-based-LMO" title="Permalink"></a></h3><ul><li>Enforces linking constraints x[e] &lt;= M*y[e] as HARD constraints in the MOI model</li><li>Objective: minimize BPR<em>cost(x) + restoration</em>cost(y)</li><li>Finds feasible solution satisfying all constraints exactly</li></ul><h3 id="Custom-LMO"><a class="docs-heading-anchor" href="#Custom-LMO">Custom LMO</a><a id="Custom-LMO-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-LMO" title="Permalink"></a></h3><ul><li>Cannot encode linking constraints x[e] &lt;= M*y[e] in the shortest-path oracle</li><li>Instead, adds PENALTY TERMS to the objective function</li><li>Objective: minimize BPR<em>cost(x) + restoration</em>cost(y) + ρ·∑max(0, x[e] - M*y[e])²</li><li>Uses penalty method to discourage constraint violations</li></ul><p>Because they optimize different objective functions, they may find different solutions! The penalty weight ρ controls the tradeoff between optimality and feasibility.</p><pre><code class="language- hljs">using Boscia
using FrankWolfe
using Graphs
using SparseArrays
using LinearAlgebra
import MathOptInterface
const MOI = MathOptInterface
using HiGHS

println(&quot;\nDocumentation Example 01: Network Design Problem&quot;)</code></pre><h2 id="Data-Structure"><a class="docs-heading-anchor" href="#Data-Structure">Data Structure</a><a id="Data-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structure" title="Permalink"></a></h2><p>Simple graph structure with edge weights and demands</p><pre><code class="language-julia hljs">mutable struct NetworkData
    num_nodes::Int
    num_edges::Int
    init_nodes::Vector{Int}
    term_nodes::Vector{Int}
    free_flow_time::Vector{Float64}
    capacity::Vector{Float64}
    b::Vector{Float64}  # BPR function parameter
    power::Vector{Float64}  # BPR function exponent
    travel_demand::Matrix{Float64}
    num_zones::Int
end</code></pre><h2 id="Load-Network"><a class="docs-heading-anchor" href="#Load-Network">Load Network</a><a id="Load-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Network" title="Permalink"></a></h2><p>Transportation network matching the purchasable edge diagram 2 sources (S1, S2) → 5 intermediate nodes → 1 destination (D) Total: 8 nodes</p><p>IMPORTANT: Node numbering is constrained by the code structure The code requires zones 1..num<em>zones to BE nodes 1..num</em>zones So: Node 1=S1 (zone 1), Node 2=S2 (zone 2), Node 3=D (zone 3) Nodes 4-8 are the 5 intermediate nodes from the diagram</p><p>Mapping from diagram to code: Diagram -&gt; Code numbering S1 -&gt; 1, S2 -&gt; 2, D -&gt; 3 intermediate nodes 1,2,3,4,5 -&gt; 4,5,6,7,8</p><p>Network topology from your description: S1(1) → node<em>1(4) S2(2) → node</em>3(6) node<em>1(4) → node</em>3(6) node<em>2(5) → node</em>1(4), D(3) node<em>3(6) → node</em>1(4), node<em>4(7) node</em>4(7) → node<em>3(6), node</em>5(8) node<em>5(8) → node</em>4(7), D(3) Optional edge: node<em>1(4) → node</em>2(5) [the purchasable dashed edge]</p><pre><code class="language-julia hljs">function load_braess_network()
    init_nodes = [1, 2, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4]
    term_nodes = [4, 6, 6, 4, 3, 4, 7, 6, 8, 7, 3, 5]
    free_flow_time = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
    capacity = [10.0, 10.0, 10.0, 10.0, 1.5, 10.0, 10.0, 10.0, 10.0, 10.0, 1.5, 10.0]
    b = [0.1, 0.1, 0.1, 0.1, 3.0, 0.1, 0.1, 0.1, 0.1, 0.1, 3.0, 0.1]
    power = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
    travel_demand = [0.0 0.0 1.0; 0.0 0.0 1.0; 0.0 0.0 0.0]
    return NetworkData(8, length(init_nodes), init_nodes, term_nodes, free_flow_time,
                      capacity, b, power, travel_demand, 3)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">load_braess_network (generic function with 1 method)</code></pre><h2 id="Shortest-Path-Dijkstra-Implementation"><a class="docs-heading-anchor" href="#Shortest-Path-Dijkstra-Implementation">Shortest Path Dijkstra Implementation</a><a id="Shortest-Path-Dijkstra-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Shortest-Path-Dijkstra-Implementation" title="Permalink"></a></h2><p>Custom Dijkstra implementation for traffic assignment</p><pre><code class="language-julia hljs">function traffic_dijkstra(graph, travel_time, origin, link_dic)
    state = Graphs.dijkstra_shortest_paths(graph, origin)
    return state
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">traffic_dijkstra (generic function with 1 method)</code></pre><p>Add demand to flow vector following shortest path</p><pre><code class="language-julia hljs">function add_demand_to_path!(x, demand, state, origin, destination, link_dic, edge_list, num_zones)
    current = destination
    parent = -1
    edge_count = length(edge_list)
    agg_start = edge_count * num_zones

    while parent != origin &amp;&amp; origin != destination &amp;&amp; current != 0
        parent = state.parents[current]
        if parent != 0
            link_idx = link_dic[parent, current]
            if link_idx != 0
                x[(destination - 1) * edge_count + link_idx] += demand
                x[agg_start + link_idx] += demand
            end
        end
        current = parent
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">add_demand_to_path! (generic function with 1 method)</code></pre><p>All-or-nothing assignment: route all flow on shortest paths</p><pre><code class="language-julia hljs">function all_or_nothing_assignment(travel_time_vector, net_data, graph, link_dic, edge_list)
    num_zones = net_data.num_zones
    edge_count = net_data.num_edges
    travel_time = travel_time_vector[num_zones * edge_count + 1 : (num_zones + 1) * edge_count]
    x = zeros(length(travel_time_vector))

    for origin in 1:num_zones
        state = Graphs.dijkstra_shortest_paths(graph, origin)

        for destination in 1:num_zones
            demand = net_data.travel_demand[origin, destination]
            if demand &gt; 0
                add_demand_to_path!(x, demand, state, origin, destination,
                                  link_dic, edge_list, num_zones)
            end
        end
    end

    return x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">all_or_nothing_assignment (generic function with 1 method)</code></pre><h2 id="Custom-LMO-using-Shortest-Path"><a class="docs-heading-anchor" href="#Custom-LMO-using-Shortest-Path">Custom LMO using Shortest Path</a><a id="Custom-LMO-using-Shortest-Path-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-LMO-using-Shortest-Path" title="Permalink"></a></h2><p>Custom Linear Minimization Oracle using shortest path computations</p><pre><code class="language- hljs">struct ShortestPathLMO &lt;: FrankWolfe.LinearMinimizationOracle
    graph::Graphs.SimpleDiGraph{Int}
    net_data::NetworkData
    link_dic::SparseMatrixCSC{Int, Int}
    edge_list::Vector{Tuple{Int, Int}}
end

function Boscia.bounded_compute_extreme_point(lmo::ShortestPathLMO, direction,
                                               lower_bounds, upper_bounds, int_vars)
    x = all_or_nothing_assignment(direction, lmo.net_data, lmo.graph,
                                  lmo.link_dic, lmo.edge_list)
    for (i, var_idx) in enumerate(int_vars)
        if direction[var_idx] &lt; 0
            x[var_idx] = upper_bounds[i]
        else
            x[var_idx] = lower_bounds[i]
        end
    end
    return x
end

function Boscia.is_simple_linear_feasible(lmo::ShortestPathLMO, x)
    num_zones = lmo.net_data.num_zones
    num_edges = lmo.net_data.num_edges
    return all(x .&gt;= -1e-6)
end</code></pre><h2 id="MOI-Model-Setup"><a class="docs-heading-anchor" href="#MOI-Model-Setup">MOI Model Setup</a><a id="MOI-Model-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#MOI-Model-Setup" title="Permalink"></a></h2><p>Build MOI model with flow conservation and network design constraints Big-M formulation: x[dest, edge] &lt;= M * y[edge] When y=1 (restore), flow can be up to M When y=0 (closed), flow must be 0 Indicator constraint: y[edge] = 0 =&gt; x[dest, edge] = 0 Note: Indicator constraints may not be supported by all solvers</p><pre><code class="language-julia hljs">function build_moi_model(net_data, removed_edges, use_big_m=true)
    optimizer = HiGHS.Optimizer()
    MOI.set(optimizer, MOI.Silent(), true)
    num_zones = net_data.num_zones
    num_edges = net_data.num_edges
    num_removed = length(removed_edges)
    num_flow_vars = num_zones * num_edges  # x[dest, edge]
    num_agg_vars = num_edges  # x_agg[edge]
    num_design_vars = num_removed  # y[removed_edge] binary
    total_vars = num_flow_vars + num_agg_vars + num_design_vars
    x = MOI.add_variables(optimizer, num_flow_vars)
    x_agg = MOI.add_variables(optimizer, num_agg_vars)
    y = MOI.add_variables(optimizer, num_design_vars)
    for i in 1:num_flow_vars
        MOI.add_constraint(optimizer, x[i], MOI.GreaterThan(0.0))
    end
    for i in 1:num_agg_vars
        MOI.add_constraint(optimizer, x_agg[i], MOI.GreaterThan(0.0))
    end
    for i in 1:num_design_vars
        MOI.add_constraint(optimizer, y[i], MOI.ZeroOne())
    end
    edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i]) for i in 1:num_edges]
    edge_dict = Dict(edge_list[i] =&gt; i for i in eachindex(edge_list))
    incoming = Dict{Int, Vector{Int}}()
    outgoing = Dict{Int, Vector{Int}}()

    for (idx, (src, dst)) in enumerate(edge_list)
        if !haskey(outgoing, src)
            outgoing[src] = Int[]
        end
        push!(outgoing[src], idx)

        if !haskey(incoming, dst)
            incoming[dst] = Int[]
        end
        push!(incoming[dst], idx)
    end
    for dest in 1:num_zones
        for node in 1:net_data.num_nodes
            terms = MOI.ScalarAffineTerm{Float64}[]
            if haskey(outgoing, node)
                for edge_idx in outgoing[node]
                    push!(terms, MOI.ScalarAffineTerm(1.0, x[(dest-1)*num_edges + edge_idx]))
                end
            end
            if haskey(incoming, node)
                for edge_idx in incoming[node]
                    push!(terms, MOI.ScalarAffineTerm(-1.0, x[(dest-1)*num_edges + edge_idx]))
                end
            end
            if node == dest
                rhs = -sum(net_data.travel_demand[:, dest])
            elseif node &lt;= num_zones
                rhs = net_data.travel_demand[node, dest]
            else
                rhs = 0.0
            end
            MOI.add_constraint(optimizer,
                             MOI.ScalarAffineFunction(terms, 0.0),
                             MOI.EqualTo(rhs))
        end
    end
    for edge_idx in 1:num_edges
        terms = [MOI.ScalarAffineTerm(1.0, x_agg[edge_idx])]
        for dest in 1:num_zones
            push!(terms, MOI.ScalarAffineTerm(-1.0, x[(dest-1)*num_edges + edge_idx]))
        end
        MOI.add_constraint(optimizer,
                         MOI.ScalarAffineFunction(terms, 0.0),
                         MOI.EqualTo(0.0))
    end
    max_flow = 1.5 * sum(net_data.travel_demand)
    for (y_idx, edge) in enumerate(removed_edges)
        edge_idx = edge_dict[edge]
        for dest in 1:num_zones
            var_idx = (dest - 1) * num_edges + edge_idx
            if use_big_m
                terms = [
                    MOI.ScalarAffineTerm(1.0, x[var_idx]),
                    MOI.ScalarAffineTerm(-max_flow, y[y_idx])
                ]
                MOI.add_constraint(optimizer,
                                 MOI.ScalarAffineFunction(terms, 0.0),
                                 MOI.LessThan(0.0))
            else
                indicator_func = MOI.VectorAffineFunction(
                    [
                        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, y[y_idx])),
                        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x[var_idx]))
                    ],
                    [0.0, 0.0]
                )
                MOI.add_constraint(optimizer, indicator_func,
                                 MOI.Indicator{MOI.ACTIVATE_ON_ZERO}(MOI.EqualTo(0.0)))
            end
        end
    end
    return optimizer, edge_list
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">build_moi_model (generic function with 2 methods)</code></pre><h2 id="Objective-Function-and-Gradient"><a class="docs-heading-anchor" href="#Objective-Function-and-Gradient">Objective Function and Gradient</a><a id="Objective-Function-and-Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function-and-Gradient" title="Permalink"></a></h2><p>BPR (Bureau of Public Roads) travel time function and gradient (for MOI-based LMO)</p><p>This function builds the objective function and gradient for the MOI-based approach. The objective function computes:</p><ul><li>BPR travel time: t = t0 * (flow + b * flow^(power+1) / capacity^power / (power+1))</li><li>Design cost: sum of cost<em>per</em>edge[i] * y[i] for each restored edge</li><li>No penalty terms needed - constraints are enforced by the MOI model</li></ul><p>The gradient function computes derivatives of the objective with respect to:</p><ul><li>Aggregate flows: d/d(flow) of BPR function</li><li>Design variables: cost<em>per</em>edge[i] for each restored edge</li></ul><p>Returns: (f, grad!) where f is the objective function and grad! is the gradient function</p><pre><code class="language-julia hljs">function build_objective_and_gradient(net_data, removed_edges, cost_per_edge)
    num_zones = net_data.num_zones
    num_edges = net_data.num_edges
    num_removed = length(removed_edges)
    function f(x)
        x = max.(x, 0.0)
        total = 0.0
        agg_start = num_zones * num_edges + 1
        agg_end = num_zones * num_edges + num_edges
        x_agg = @view x[agg_start:agg_end]
        for i in 1:num_edges
            flow = x_agg[i]
            t0 = net_data.free_flow_time[i]
            b = net_data.b[i]
            cap = net_data.capacity[i]
            p = net_data.power[i]
            total += t0 * (flow + b * flow^(p + 1) / cap^p / (p + 1))
        end
        design_start = num_zones * num_edges + num_edges + 1
        for i in 1:num_removed
            total += cost_per_edge[i] * x[design_start + i - 1]
        end
        return total
    end
    function grad!(storage, x)
        x = max.(x, 0.0)
        fill!(storage, 0.0)
        agg_start = num_zones * num_edges + 1
        agg_end = num_zones * num_edges + num_edges
        x_agg = @view x[agg_start:agg_end]
        for i in 1:num_edges
            flow = x_agg[i]
            t0 = net_data.free_flow_time[i]
            b = net_data.b[i]
            cap = net_data.capacity[i]
            p = net_data.power[i]
            storage[agg_start + i - 1] = t0 * (1 + b * flow^p / cap^p)
        end
        for dest in 1:num_zones
            for edge in 1:num_edges
                storage[(dest - 1) * num_edges + edge] = storage[agg_start + edge - 1]
            end
        end
        design_start = num_zones * num_edges + num_edges + 1
        for i in 1:num_removed
            storage[design_start + i - 1] = cost_per_edge[i]
        end
        return storage
    end
    return f, grad!
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">build_objective_and_gradient (generic function with 1 method)</code></pre><p>BPR objective WITH penalty terms for linking constraints (for Custom LMO)</p><p>This function builds the objective function and gradient for the Custom LMO approach. Since the shortest-path oracle cannot enforce linking constraints x[dest,edge] &lt;= M * y[edge] as hard constraints, we add penalty terms to the objective function to discourage violations.</p><p>The objective function computes:</p><ul><li>BPR travel time: t = t0 * (flow + b * flow^(power+1) / capacity^power / (power+1))</li><li>Design cost: sum of cost<em>per</em>edge[i] * y[i] for each restored edge</li><li>Penalty terms: penalty<em>weight * sum</em>i sum<em>dest max(0, x[dest,removed</em>edge<em>i] - M * y[i])^penalty</em>exponent</li></ul><p>The gradient function computes derivatives of the objective with respect to:</p><ul><li>Aggregate flows: d/d(flow) of BPR function + penalty gradient w.r.t. flows</li><li>Design variables: cost<em>per</em>edge[i] + penalty gradient w.r.t. design variables</li></ul><p>Parameters:</p><ul><li>penalty_weight: Weight of the penalty term (default: 1e6)</li><li>penalty_exponent: Exponent for the penalty term (default: 2.0)<ul><li>penalty_exponent = 1: Linear penalty (L1)</li><li>penalty_exponent = 2: Quadratic penalty (L2, most common)</li><li>penalty_exponent &gt; 2: Higher order penalties (stronger enforcement)</li></ul></li></ul><p>Returns: (f, grad!) where f is the objective function and grad! is the gradient function</p><pre><code class="language-julia hljs">function build_objective_and_gradient_with_penalty(net_data, removed_edges, cost_per_edge,
                                                    penalty_weight=1e6, penalty_exponent=2.0)
    num_zones = net_data.num_zones
    num_edges = net_data.num_edges
    num_removed = length(removed_edges)
    edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i]) for i in 1:num_edges]
    removed_edge_indices = [findfirst(e -&gt; e == removed_edge, edge_list)
                            for removed_edge in removed_edges]
    max_flow = 1.5 * sum(net_data.travel_demand)
    function f(x)
        x = max.(x, 0.0)
        total = 0.0
        agg_start = num_zones * num_edges + 1
        agg_end = num_zones * num_edges + num_edges
        x_agg = @view x[agg_start:agg_end]
        for i in 1:num_edges
            flow = x_agg[i]
            t0 = net_data.free_flow_time[i]
            b = net_data.b[i]
            cap = net_data.capacity[i]
            p = net_data.power[i]
            total += t0 * (flow + b * flow^(p + 1) / cap^p / (p + 1))
        end
        design_start = num_zones * num_edges + num_edges + 1
        for i in 1:num_removed
            total += cost_per_edge[i] * x[design_start + i - 1]
        end
        for (y_idx, edge_idx) in enumerate(removed_edge_indices)
            if edge_idx !== nothing
                y_val = x[design_start + y_idx - 1]
                for dest in 1:num_zones
                    flow_idx = (dest - 1) * num_edges + edge_idx
                    flow_val = x[flow_idx]
                    violation = max(0.0, flow_val - max_flow * y_val)
                    total += penalty_weight * violation^penalty_exponent
                end
            end
        end
        return total
    end
    function grad!(storage, x)
        x = max.(x, 0.0)
        fill!(storage, 0.0)
        agg_start = num_zones * num_edges + 1
        agg_end = num_zones * num_edges + num_edges
        x_agg = @view x[agg_start:agg_end]
        for i in 1:num_edges
            flow = x_agg[i]
            t0 = net_data.free_flow_time[i]
            b = net_data.b[i]
            cap = net_data.capacity[i]
            p = net_data.power[i]
            storage[agg_start + i - 1] = t0 * (1 + b * flow^p / cap^p)
        end
        for dest in 1:num_zones
            for edge in 1:num_edges
                storage[(dest - 1) * num_edges + edge] = storage[agg_start + edge - 1]
            end
        end
        design_start = num_zones * num_edges + num_edges + 1
        for i in 1:num_removed
            storage[design_start + i - 1] = cost_per_edge[i]
        end
        for (y_idx, edge_idx) in enumerate(removed_edge_indices)
            if edge_idx !== nothing
                y_val = x[design_start + y_idx - 1]
                for dest in 1:num_zones
                    flow_idx = (dest - 1) * num_edges + edge_idx
                    flow_val = x[flow_idx]
                    violation = max(0.0, flow_val - max_flow * y_val)
                    if violation &gt; 1e-10
                        grad_coeff = penalty_weight * penalty_exponent * violation^(penalty_exponent - 1)
                        storage[flow_idx] += grad_coeff
                        storage[design_start + y_idx - 1] += grad_coeff * (-max_flow)
                    end
                end
            end
        end
        return storage
    end
    return f, grad!
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">build_objective_and_gradient_with_penalty (generic function with 3 methods)</code></pre><h2 id="Helper-Functions-for-Results"><a class="docs-heading-anchor" href="#Helper-Functions-for-Results">Helper Functions for Results</a><a id="Helper-Functions-for-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions-for-Results" title="Permalink"></a></h2><pre><code class="language-julia hljs">function print_solution(x, net_data, removed_edges, edge_list, method_name)
    println(&quot;\n&quot; * &quot;-&quot;^70)
    println(&quot;Solution using $method_name&quot;)
    println(&quot;-&quot;^70)
    num_zones = net_data.num_zones
    num_edges = net_data.num_edges
    num_removed = length(removed_edges)
    function node_label(node)
        if node == 1
            return &quot;S1&quot;
        elseif node == 2
            return &quot;S2&quot;
        elseif node == 3
            return &quot;D&quot;
        elseif node == 4
            return &quot;1&quot;
        elseif node == 5
            return &quot;2&quot;
        elseif node == 6
            return &quot;3&quot;
        elseif node == 7
            return &quot;4&quot;
        elseif node == 8
            return &quot;5&quot;
        else
            return string(node)
        end
    end
    design_start = num_zones * num_edges + num_edges + 1
    design_vars = x[design_start:end]

    println(&quot;\nEdges to restore:&quot;)
    for (i, edge) in enumerate(removed_edges)
        status = design_vars[i] &gt; 0.5 ? &quot;RESTORE&quot; : &quot;KEEP CLOSED&quot;
        from_label = node_label(edge[1])
        to_label = node_label(edge[2])
        println(&quot;  Edge ($from_label → $to_label): y = $(round(design_vars[i], digits=3)) → $status&quot;)
    end
    agg_start = num_zones * num_edges + 1
    println(&quot;\nAggregate flows on edges:&quot;)
    for i in 1:num_edges
        flow = x[agg_start + i - 1]
        if flow &gt; 1e-6
            from_label = node_label(edge_list[i][1])
            to_label = node_label(edge_list[i][2])
            println(&quot;  Edge ($from_label → $to_label): flow = $(round(flow, digits=3))&quot;)
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">print_solution (generic function with 1 method)</code></pre><h2 id="Example-Execution"><a class="docs-heading-anchor" href="#Example-Execution">Example Execution</a><a id="Example-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Execution" title="Permalink"></a></h2><p>Load network</p><pre><code class="language-julia hljs">net_data = load_braess_network()
println(&quot;\nNetwork: Two-Source Network with Purchasable Edge&quot;)
println(&quot;  Nodes: $(net_data.num_nodes) (2 sources, 5 intermediate, 1 destination)&quot;)
println(&quot;  Edges: $(net_data.num_edges)&quot;)
println(&quot;  Sources: S1 (node 1), S2 (node 2)&quot;)
println(&quot;  Destination: D (node 3)&quot;)
println(&quot;  Intermediate nodes: 4, 5, 6, 7, 8&quot;)
println(&quot;  Demand: 1 unit from each source (2 units total)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Network: Two-Source Network with Purchasable Edge
  Nodes: 8 (2 sources, 5 intermediate, 1 destination)
  Edges: 12
  Sources: S1 (node 1), S2 (node 2)
  Destination: D (node 3)
  Intermediate nodes: 4, 5, 6, 7, 8
  Demand: 1 unit from each source (2 units total)</code></pre><p>Define potentially purchasable edges (edges that need design decision)</p><pre><code class="language-julia hljs">removed_edges = [(4, 5)]  # Optional edge from node_1 (intermediate node 4) to node_2 (intermediate node 5)
cost_per_edge = [0.5]  # Cost to purchase the edge

println(&quot;\nPurchasable edges (need design decision): $removed_edges&quot;)
println(&quot;Cost to restore: $cost_per_edge&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Purchasable edges (need design decision): [(4, 5)]
Cost to restore: [0.5]</code></pre><p>Build edge list for display</p><pre><code class="language-julia hljs">edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i])
             for i in 1:net_data.num_edges]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12-element Vector{Tuple{Int64, Int64}}:
 (1, 4)
 (2, 6)
 (4, 6)
 (5, 4)
 (5, 3)
 (6, 4)
 (6, 7)
 (7, 6)
 (7, 8)
 (8, 7)
 (8, 3)
 (4, 5)</code></pre><h2 id="Solve-with-MOI-based-LMO"><a class="docs-heading-anchor" href="#Solve-with-MOI-based-LMO">Solve with MOI-based LMO</a><a id="Solve-with-MOI-based-LMO-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-with-MOI-based-LMO" title="Permalink"></a></h2><pre><code class="language-julia hljs">println(&quot;\n&quot; * &quot;=&quot;^70)
println(&quot;Solving with MOI-based LMO (MIP solver models feasible region)&quot;)
println(&quot;=&quot;^70)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
======================================================================
Solving with MOI-based LMO (MIP solver models feasible region)
======================================================================</code></pre><p>Build MOI model</p><pre><code class="language- hljs">optimizer, _ = build_moi_model(net_data, removed_edges, true)</code></pre><p>Create Boscia LMO from MOI model</p><pre><code class="language- hljs">lmo_moi = FrankWolfe.MathOptLMO(optimizer)</code></pre><p>Build objective</p><pre><code class="language-julia hljs">f_moi, grad_moi! = build_objective_and_gradient(net_data, removed_edges, cost_per_edge)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Main.var&quot;Main&quot;.var&quot;#f#5&quot;{Main.var&quot;Main&quot;.NetworkData, Vector{Float64}, Int64, Int64, Int64}(Main.var&quot;Main&quot;.NetworkData(8, 12, [1, 2, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4], [4, 6, 6, 4, 3, 4, 7, 6, 8, 7, 3, 5], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [10.0, 10.0, 10.0, 10.0, 1.5, 10.0, 10.0, 10.0, 10.0, 10.0, 1.5, 10.0], [0.1, 0.1, 0.1, 0.1, 3.0, 0.1, 0.1, 0.1, 0.1, 0.1, 3.0, 0.1], [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], [0.0 0.0 1.0; 0.0 0.0 1.0; 0.0 0.0 0.0], 3), [0.5], 1, 12, 3), Main.var&quot;Main&quot;.var&quot;#grad!#6&quot;{Main.var&quot;Main&quot;.NetworkData, Vector{Float64}, Int64, Int64, Int64}(Main.var&quot;Main&quot;.NetworkData(8, 12, [1, 2, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4], [4, 6, 6, 4, 3, 4, 7, 6, 8, 7, 3, 5], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [10.0, 10.0, 10.0, 10.0, 1.5, 10.0, 10.0, 10.0, 10.0, 10.0, 1.5, 10.0], [0.1, 0.1, 0.1, 0.1, 3.0, 0.1, 0.1, 0.1, 0.1, 0.1, 3.0, 0.1], [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], [0.0 0.0 1.0; 0.0 0.0 1.0; 0.0 0.0 0.0], 3), [0.5], 1, 12, 3))</code></pre><p>Configure settings</p><pre><code class="language-julia hljs">settings_moi = Boscia.create_default_settings()
settings_moi.branch_and_bound[:verbose] = true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Solve with Boscia</p><pre><code class="language- hljs">x_moi, _, result_moi = Boscia.solve(f_moi, grad_moi!, lmo_moi, settings=settings_moi)

print_solution(x_moi, net_data, removed_edges, edge_list, &quot;MOI-based LMO&quot;)</code></pre><h2 id="Solve-with-Custom-LMO"><a class="docs-heading-anchor" href="#Solve-with-Custom-LMO">Solve with Custom LMO</a><a id="Solve-with-Custom-LMO-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-with-Custom-LMO" title="Permalink"></a></h2><pre><code class="language-julia hljs">println(&quot;\n&quot; * &quot;=&quot;^70)
println(&quot;Solving with Custom LMO (shortest path oracle)&quot;)
penalty_weight = 1e3
penalty_exponent = 1.5
println(&quot;Penalty weight: $penalty_weight, Penalty exponent: $penalty_exponent&quot;)
println(&quot;=&quot;^70)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
======================================================================
Solving with Custom LMO (shortest path oracle)
Penalty weight: 1000.0, Penalty exponent: 1.5
======================================================================</code></pre><p>Build graph</p><pre><code class="language- hljs">graph = Graphs.SimpleDiGraph(net_data.num_nodes)
edge_list_custom = Tuple{Int,Int}[]
for i in 1:net_data.num_edges
    Graphs.add_edge!(graph, net_data.init_nodes[i], net_data.term_nodes[i])
    push!(edge_list_custom, (net_data.init_nodes[i], net_data.term_nodes[i]))
end</code></pre><p>Build sparse link dictionary</p><pre><code class="language- hljs">link_dic = sparse(net_data.init_nodes, net_data.term_nodes,
                 collect(1:net_data.num_edges))</code></pre><p>Create custom LMO for continuous variables</p><pre><code class="language- hljs">custom_lmo = ShortestPathLMO(graph, net_data, link_dic, edge_list_custom)</code></pre><p>Set up integer bounds for Boscia</p><pre><code class="language-julia hljs">num_zones = net_data.num_zones
num_edges = net_data.num_edges
num_removed = length(removed_edges)
total_vars = num_zones * num_edges + num_edges + num_removed</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">49</code></pre><p>Binary variables for network design (last num_removed variables)</p><pre><code class="language-julia hljs">int_vars = collect((num_zones * num_edges + num_edges + 1):total_vars)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Int64}:
 49</code></pre><p>Create bounds vectors for integer variables</p><pre><code class="language-julia hljs">lower_bounds = zeros(Float64, num_removed)  # Binary: lower bound = 0
upper_bounds = ones(Float64, num_removed)   # Binary: upper bound = 1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Float64}:
 1.0</code></pre><p>Wrap LMO with integer handling</p><pre><code class="language- hljs">bounded_lmo = Boscia.ManagedLMO(custom_lmo, lower_bounds, upper_bounds, int_vars, total_vars)</code></pre><p>Build objective WITH PENALTY TERMS for linking constraints</p><pre><code class="language-julia hljs">f_custom, grad_custom! = build_objective_and_gradient_with_penalty(net_data, removed_edges, cost_per_edge,
                                                      penalty_weight, penalty_exponent)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(Main.var&quot;Main&quot;.var&quot;#f#13&quot;{Main.var&quot;Main&quot;.NetworkData, Vector{Float64}, Float64, Float64, Float64, Vector{Int64}, Int64, Int64, Int64}(Main.var&quot;Main&quot;.NetworkData(8, 12, [1, 2, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4], [4, 6, 6, 4, 3, 4, 7, 6, 8, 7, 3, 5], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [10.0, 10.0, 10.0, 10.0, 1.5, 10.0, 10.0, 10.0, 10.0, 10.0, 1.5, 10.0], [0.1, 0.1, 0.1, 0.1, 3.0, 0.1, 0.1, 0.1, 0.1, 0.1, 3.0, 0.1], [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], [0.0 0.0 1.0; 0.0 0.0 1.0; 0.0 0.0 0.0], 3), [0.5], 1000.0, 1.5, 3.0, [12], 1, 12, 3), Main.var&quot;Main&quot;.var&quot;#grad!#14&quot;{Main.var&quot;Main&quot;.NetworkData, Vector{Float64}, Float64, Float64, Float64, Vector{Int64}, Int64, Int64, Int64}(Main.var&quot;Main&quot;.NetworkData(8, 12, [1, 2, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4], [4, 6, 6, 4, 3, 4, 7, 6, 8, 7, 3, 5], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [10.0, 10.0, 10.0, 10.0, 1.5, 10.0, 10.0, 10.0, 10.0, 10.0, 1.5, 10.0], [0.1, 0.1, 0.1, 0.1, 3.0, 0.1, 0.1, 0.1, 0.1, 0.1, 3.0, 0.1], [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0], [0.0 0.0 1.0; 0.0 0.0 1.0; 0.0 0.0 0.0], 3), [0.5], 1000.0, 1.5, 3.0, [12], 1, 12, 3))</code></pre><p>Configure settings</p><pre><code class="language-julia hljs">settings_custom = Boscia.create_default_settings()
settings_custom.branch_and_bound[:verbose] = true</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Solve with Boscia</p><pre><code class="language- hljs">x_custom, _, result_custom = Boscia.solve(f_custom, grad_custom!, bounded_lmo, settings=settings_custom)

print_solution(x_custom, net_data, removed_edges, edge_list, &quot;Custom Shortest-Path LMO&quot;)</code></pre><h2 id="Comparison-of-Results"><a class="docs-heading-anchor" href="#Comparison-of-Results">Comparison of Results</a><a id="Comparison-of-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Comparison-of-Results" title="Permalink"></a></h2><pre><code class="language- hljs">println(&quot;\n&quot; * &quot;=&quot;^70)
println(&quot;Comparison of Results&quot;)
println(&quot;=&quot;^70)
println(&quot;MOI-based LMO (Hard Constraints):&quot;)
println(&quot;  Objective: $(result_moi[:primal_objective])&quot;)
println(&quot;  Time: $(result_moi[:total_time_in_sec]) seconds&quot;)
println(&quot;  Formulation: min BPR_cost(x) + restoration_cost(y)&quot;)
println(&quot;               s.t. x[e] &lt;= M*y[e] (hard constraints)&quot;)

println(&quot;\nCustom LMO (Penalty Method):&quot;)
println(&quot;  Objective: $(result_custom[:primal_objective])&quot;)
println(&quot;  Time: $(result_custom[:total_time_in_sec]) seconds&quot;)
println(&quot;  Formulation: min BPR_cost(x) + restoration_cost(y) + penalties&quot;)
println(&quot;               (penalties for violating x[e] &lt;= M*y[e])&quot;)

println(&quot;\n&quot; * &quot;-&quot;^70)
println(&quot;IMPORTANT: These are DIFFERENT objective functions!&quot;)
println(&quot;The Custom LMO uses a penalized formulation because the shortest-path&quot;)
println(&quot;oracle cannot enforce the linking constraints x[e] &lt;= M*y[e] directly.&quot;)
println(&quot;Different formulations → different solutions → different objectives.&quot;)
println(&quot;=&quot;^70)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../basics/">« How does it work?</a><a class="docs-footer-nextpage" href="../docs-02-graph-isomorphism/">Graph Isomorphism Problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Thursday 6 November 2025 09:24">Thursday 6 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
