var documenterSearchIndex = {"docs":
[{"location":"reference/fw_variant/#Frank-Wolfe-Variants","page":"Frank-Wolfe Variants","title":"Frank-Wolfe Variants","text":"","category":"section"},{"location":"reference/fw_variant/","page":"Frank-Wolfe Variants","title":"Frank-Wolfe Variants","text":"Here is the list with the currently supported Frank-Wolfe variants.","category":"page"},{"location":"reference/fw_variant/#Boscia.AwayFrankWolfe","page":"Frank-Wolfe Variants","title":"Boscia.AwayFrankWolfe","text":"Away-Frank-Wolfe\n\nIn every iteration, it computes the worst performing vertex, called away vertex, in the active set with regard to the gradient. If enough local progress can be made, weight is shifted from the away vertex to all other vertices. \n\nIn case lazification is activated, the FW vertex is only computed if not enough local progress can be guaranteed.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.BlendedConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.BlendedConditionalGradient","text":"Blended Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.BlendedPairwiseConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.BlendedPairwiseConditionalGradient","text":"Blended Pairwise Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.DecompositionInvariantConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.DecompositionInvariantConditionalGradient","text":"DICG-Frank-Wolfe\n\nThe Decomposition-invariant Frank-Wolfe. \n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.FrankWolfeVariant","page":"Frank-Wolfe Variants","title":"Boscia.FrankWolfeVariant","text":"Frank-Wolfe variant used to compute the problems at node level. A FrankWolfeVariant must implement\n\nsolve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\n\tadded_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace))\n\nIt may also implement build_frank_wolfe_workspace(x) which creates a workspace structure that is passed as last argument to solve_frank_wolfe.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.StandardFrankWolfe","page":"Frank-Wolfe Variants","title":"Boscia.StandardFrankWolfe","text":"Vanilla-Frank-Wolfe\n\nThe standard variant of Frank-Wolfe. In each iteration, the vertex v minimizing ∇f * (x-v) is computed. \n\nLazification cannot be used in this setting.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.solve_frank_wolfe","page":"Frank-Wolfe Variants","title":"Boscia.solve_frank_wolfe","text":"solve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\nadded_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace)\n\nReturns the optimal solution x to the node problem, its primal and dual gap and the active set. \n\n\n\n\n\n","category":"function"},{"location":"basics/#How-does-it-work?","page":"How does it work?","title":"How does it work?","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Boscia.jl is aimed at mixed-integer convex problems where the nonlinearity stems mostly from the objective function:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nmin    f(x)  \ntextst   xin C  x_I in mathbbZ^I\nendaligned text where  x in X subset mathbbR  x_I in mathbbZ^I","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where C is a compact, nonconvex set admitting a boundable linear minimization oracle (BLMO), i.e., a set over which optimizing a linear function can be done efficiently (comparatively to the original problem), even when bounds are added or modified.  Taking lower bounds l and upper bounds u, the oracle solves","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nv in argmin   langle x d rangle \ntextst   xin C \n  x_I in mathbbZ^I cap lu   text where  x in X subset mathbbR  x_I in mathbbZ^I\nendaligned","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where d will usually be the gradient of f evaluated at a given point x_t, nabla f(x_t).","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The new algorithmic framework is a branch-and-bound approach utilizing Frank-Wolfe (FW), also called Conditional Gradient (CG), methods as the node solver. A new aspect is that we solve the continuous sub problems in the nodes over the integer hull, i.e. the convex hull of the integer feasible points. Additionally, we exploit both general properties of the FW methods as well as the recent developments in the field of FW methods to speed up the solution process. ","category":"page"},{"location":"basics/#Frank-Wolfe-variants","page":"How does it work?","title":"Frank-Wolfe variants","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Frank-Wolfe algorithms used in Boscia.jl are implemented in FrankWolfe.jl.  The variants currently available in Boscia.jl are Vanilla Frank-Wolfe, Away-Frank-Wolfe (AFW), Blended Conditional Gradient (BCG) and Blended Pairwise Conditional Gradient (BPCG). The latter is set as the default variant.","category":"page"},{"location":"basics/#Branch-and-Bound-techniques","page":"How does it work?","title":"Branch-and-Bound techniques","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In this section, we present the techniques derived from Frank Wolfe that can be used in our framework .","category":"page"},{"location":"basics/#Dual-gap-based-termination","page":"How does it work?","title":"Dual gap based termination","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Frank-Wolfe methods produce primal feasible iterates and an FW gap, offering many inexpensive iterations with a gradually increasing dual bound.  This allows early termination of nodes when the dual bound reaches the best incumbent's objective value, avoiding unnecessary computations.  Nodes can be stopped anytime to produce a useful dual bound, aiding overall progress.  This flexibility contrasts with other nonlinear solvers, enabling more efficient optimization.","category":"page"},{"location":"basics/#Tree-state-dependent-termination-and-evolving-error","page":"How does it work?","title":"Tree state-dependent termination and evolving error","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"We implement different termination criteria in the node processing to reduce iterations, prioritizing nodes with promising lower bounds.  The dual bound provided by Frank-Wolfe is always valid, even if the dual gap is large. Thus, we solve nodes high in the tree, like the root node, with a coarse precision  and increase the precision with which a node is solved depending on its depth in the tree.  This approach balances efficiency and accuracy in solving optimization problems.","category":"page"},{"location":"basics/#Warm-starting-via-the-active-set","page":"How does it work?","title":"Warm-starting via the active set","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Many Frank-Wolfe variants provide a so-called active set, the convex combination of vertices representing the solution.  This can be used to warm start the children nodes by partitioning the active set of the parent.","category":"page"},{"location":"basics/#Branching","page":"How does it work?","title":"Branching","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"As default, we use most-infeasible branching which has shown good performance for many problems. Also, implemented are strong branching and the so-called hybrid branching which performs strong branching until a specific depth and afterwards switches to most-infeasible. It should be noted that strong branching is only adviseable for problems with very cheap LMO.  Otherwise, most-infeasible or hybrid branching with a shallow depth is to be preferred.","category":"page"},{"location":"basics/#Dual-fixing-and-tightening","page":"How does it work?","title":"Dual fixing and tightening","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In subproblems where variables are at bounds, our approach utilizes convexity and primal solutions to tighten dual bounds effectively.  Drawing from methods pioneered by Dantzig and extended in various contexts, we leverage Frank-Wolfe methods and FW gaps, adaptable to scenarios without explicit dual solutions, such as those involving MIP-based LMOs. We can also exploit strong convexity and sharpness to tighten the lowerbound of the tree.","category":"page"},{"location":"basics/#The-Bounded-Linear-Minimization-Oracles-(BLMO)","page":"How does it work?","title":"The Bounded Linear Minimization Oracles (BLMO)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Bounded Linear Minimization Oracle (BLMO) represent the feasible region C with the integrality constraints and handles the computation of mixed-integer linear sub-problems.  The bound management is also handled by the BLMO.  There are two options for the BLMO.","category":"page"},{"location":"basics/#Mixed-Integer-Linear-Solver-via-JuMP","page":"How does it work?","title":"Mixed Integer Linear Solver via JuMP","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The first option is a MIP solver like SCIP via the MathOptInterface or JuMP package.  For examples, see the Poisson Regression in poisson_reg.jl, the Sparse Regression with a grouped lasso in lasso.jl. In mps-example.jl, the feasible region is encoded in an MPS file.","category":"page"},{"location":"basics/#Customized-BLMO's","page":"How does it work?","title":"Customized BLMO's","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In addition, we have implemented some specific BLMOs like the hypercube, the probability and unit simplex. For examples, see approx_planted_point.jl.  In cube_blmo.jl, there is an example on how to implement Boscia's BLMO interface from scratch.","category":"page"},{"location":"reference/2_blmo_build/#The-Bounded-Linear-Minimization-Oracle-(BLMO)","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"The Bounded Linear Minimization Oracle (BLMO) is an oracle solving the problem","category":"page"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"beginaligned\nv in argmin   langle x d rangle \ntextst   xin C \n  x_I in mathbbZ^I cap lu   text where  x in X subset mathbbR  x_I in mathbbZ^I\nendaligned","category":"page"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"where the direction d is usually the gradient evaluated at a certain point. The bounds are specified at the node level and correspond to bounds obtained by branching.","category":"page"},{"location":"reference/2_blmo_build/#General-BLMO-Interface","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"General BLMO Interface","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"In the following, the functions for the general BLMO interface are listed. Functions without signature needs to be implemented by a new BLMO type. Functions with signature are optional and are usually for statistics and additional safety checks.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.BoundedLinearMinimizationOracle","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.BoundedLinearMinimizationOracle","text":"BLMO\n\nSupertype for the Bounded Linear Minimization Oracles,\n\nWILL BE DEPRECATED in favor of simply extending the FrankWolfe.LinearMinimizationOracle type.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.LMOStatus","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.LMOStatus","text":"Enum encoding the status of the Linear Minimization Oracle. Currently available: OPTIMAL, INFEASIBLE and UNBOUNDED.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.add_bound_constraint!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.add_bound_constraint!","text":"Add bound constraint.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.build_LMO_correct-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO_correct","text":"build_LMO_correct(lmo::LinearMinimizationOracle, node_bounds)\n\nCheck if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_global_bounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_global_bounds","text":"Read global bounds from the problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.check_feasibility-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_feasibility","text":"check_feasibility(lmo::LinearMinimizationOracle)\n\nCheck if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_infeasible_vertex-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_infeasible_vertex","text":"check_infeasible_vertex(lmo::LinearMinimizationOracle, tree)\n\nDeal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.delete_bounds!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.delete_bounds!","text":"Delete bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, LinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"find_best_solution(f::Function, lmo::LinearMinimizationOracle, vars, domain_oracle)\n\nFind best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.free_model-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.free_model","text":"free_model(lmo::LinearMinimizationOracle)\n\nFree model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_LMO_solve_data-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_LMO_solve_data","text":"get_LMO_solve_data(lmo::LinearMinimizationOracle)\n\nGet solve time, number of nodes and number of iterations, if applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_bound","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_bound","text":"Read bound value for c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_int_var","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_int_var","text":"Get the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_integer_variables","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_integer_variables","text":"Get list of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_list_of_variables","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_list_of_variables","text":"Get list of variables indices.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_lower_bound_list","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_lower_bound_list","text":"Get the list of lower bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_tol-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_tol","text":"get_tol(lmo::LinearMinimizationOracle)\n\nGet solving tolerance for the LMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_upper_bound_list","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_upper_bound_list","text":"Get the list of upper bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_variables_pointers-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_variables_pointers","text":"get_variables_pointers(lmo::LinearMinimizationOracle, tree)\n\nList of all variable pointers. Depends on how you save your variables internally. In the easy case, this is simply collect(1:N). Is used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_integer_constraint","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_integer_constraint","text":"Has variable an integer constraint?\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.indicator_present-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.indicator_present","text":"indicator_present(lmo::LinearMinimizationOracle)\n\nAre indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_bound_in","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_bound_in","text":"To check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_constraint_on_int_var","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_constraint_on_int_var","text":"Check if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_indicator_feasible-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_indicator_feasible","text":"is_indicator_feasible(lmo::LinearMinimizationOracle, v; atol=1e-6, rtol=1e-6)\n\nIs a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_linear_feasible","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_linear_feasible","text":"Is a given point v linear feasible for the model? That means does v satisfy all bounds and other linear constraints?\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, LinearMinimizationOracle, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_valid_split","text":"is_valid_split(tree::Bonobo.BnBTree, lmo::LinearMinimizationOracle, vidx::Int)\n\nCheck whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.set_bound!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.set_bound!","text":"Change the value of the bound c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#MathOptInterface-(MOI)-BLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"MathOptInterface (MOI) BLMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"With this BLMO type, any (MIP) solver that provides an interface to MathOptInterface and JuMP can be used in Boscia. Note that we only require the feasible region, i.e. no objective has to be set.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.MathOptBLMO-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.MathOptBLMO","text":"MathOptBLMO(lmo::FrankWolfe.MathOptLMO)\n\nBuild an instance of MathOptBLMO from a FrankWolfe.MathOptLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Base.convert-Tuple{Type{Boscia.MathOptBLMO}, FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Base.convert","text":"Convert object of Type FrankWolfe.MathOptLMO into Boscia.MathOptBLMO and viceversa.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Bonobo.get_branching_variable-Union{Tuple{OT}, Tuple{Bonobo.BnBTree, Boscia.PartialStrongBranching{FrankWolfe.MathOptLMO{OT}}, Bonobo.AbstractNode}} where OT<:MathOptInterface.AbstractOptimizer","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Bonobo.get_branching_variable","text":"Bonobo.get_branching_variable(tree::Bonobo.BnBTree, branching::PartialStrongBranching{MathOptBLMO{OT}}, node::Bonobo.AbstractNode,) where {OT<:MOI.AbstractOptimizer}\n\nBehavior for strong branching.  Note that in constrast to the ManagedBLMO type, we filter out the integer and binary constraints as solving general MIP in strong branching would be very expensive.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.add_bound_constraint!-Tuple{FrankWolfe.MathOptLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.add_bound_constraint!","text":"add_bound_constraint!(blmo::MathOptBLMO, key, value, sense::Symbol)\n\nAdd bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_LMO_correct-Tuple{Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO_correct","text":"build_LMO_correct(blmo, node_bounds)\n\nCheck if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_global_bounds-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_global_bounds","text":"build_global_bounds(blmo::MathOptBLMO, integer_variables)\n\nRead global bounds from the problem\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_feasibility-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_feasibility","text":"check_feasibility(blmo::MathOptBLMO)\n\nCheck if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_infeasible_vertex-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_infeasible_vertex","text":" check_infeasible_vertex(lmo::FrankWolfe.MathOptLMO, tree)\n\nDeal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.delete_bounds!-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.delete_bounds!","text":"delete_bounds!(blmo::MathOptBLMO, cons_delete)\n\nDelete bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.explicit_bounds_binary_var-Tuple{FrankWolfe.MathOptLMO, Boscia.IntegerBounds}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.explicit_bounds_binary_var","text":"explicit_bounds_binary_var(blmo::MathOptBLMO, global_bounds::IntegerBounds)\n\nAdd explicit bounds for binary variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, FrankWolfe.MathOptLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"find_best_solution(f::Function, lmo::FrankWolfe.MathOptLMO, vars, domain_oracle)\n\nFind best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, MathOptInterface.AbstractOptimizer, Vector{MathOptInterface.VariableIndex}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":" function find_best_solution(f::Function, o::MOI.AbstractOptimizer, vars::Vector{MOI.VariableIndex}, domain_oracle,)\n\nFinds the best solution in the Optimizer's solution storage, based on the objective function f. Returns the solution vector and the corresponding best value.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.free_model-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.free_model","text":" free_model(blmo::MathOptBLMO)\n\nFree model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_LMO_solve_data-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_LMO_solve_data","text":"get_LMO_solve_data(blmo::MathOptBLMO)\n\nGet solve time, number of nodes and number of simplex iterations.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_binary_variables-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_binary_variables","text":"get_binary_variables(blmo::MathOptBLMO)\n\nGet list of binary variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_bound-Tuple{FrankWolfe.MathOptLMO, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_bound","text":"get_bound(blmo::MathOptBLMO, c_idx, sense::Symbol)\n\nRead bound value for c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_int_var-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_int_var","text":" get_int_var(blmo::MathOptBLMO, c_idx)\n\nGet the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_integer_variables-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_integer_variables","text":" get_integer_variables(blmo::MathOptBLMO)\n\nGet list of integer variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_list_of_variables-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_list_of_variables","text":"get_list_of_variables(blmo::MathOptBLMO)\n\nGet list of variables indices and the total number of variables.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_lower_bound_list-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_lower_bound_list","text":"get_lower_bound_list(blmo::MathOptBLMO)\n\nGet the list of lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_tol-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_tol","text":" get_tol(blmo::MathOptBLMO)\n\nGet solving tolerance for the BLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_upper_bound_list-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_upper_bound_list","text":"get_upper_bound_list(blmo::MathOptBLMO)\n\nGet the list of upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_variables_pointers-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_variables_pointers","text":"get_variables_pointers(blmo, tree)\n\nList of all variable pointers. Depends on how you save your variables internally. Is used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_binary_constraint-Tuple{FrankWolfe.MathOptLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_binary_constraint","text":"has_binary_constraint(blmo::MathOptBLMO, idx::Int)\n\nHas variable a binary constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_integer_constraint-Tuple{FrankWolfe.MathOptLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_integer_constraint","text":"has_integer_constraint(blmo::MathOptBLMO, idx::Int)\n\nDoes the variable have an integer constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.indicator_present-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.indicator_present","text":"indicator_present(blmo::MathOptBLMO)\n\nAre indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_bound_in-Tuple{FrankWolfe.MathOptLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_bound_in","text":"is_bound_in(blmo::MathOptBLMO, c_idx, bounds)\n\nTo check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_constraint_on_int_var-Tuple{FrankWolfe.MathOptLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_constraint_on_int_var","text":"is_constraint_on_int_var(blmo::MathOptBLMO, c_idx, int_vars)\n\nCheck if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_indicator_feasible-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_indicator_feasible","text":"is_indicator_feasible(lmo::FrankWolfe.MathOptLMO, v; atol=1e-6, rtol=1e-6)\n\nIs a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_inface_feasible-Tuple{FrankWolfe.MathOptLMO, AbstractVector, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_inface_feasible","text":"Is a given point v inface feasible for the model?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_linear_feasible-Tuple{FrankWolfe.MathOptLMO, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_linear_feasible","text":"is_linear_feasible(blmo::MathOptBLMO, v::AbstractVector)\n\nIs a given point v linear feasible for the model?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, FrankWolfe.MathOptLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_valid_split","text":"is_valid_split(tree::Bonobo.BnBTree, blmo::MathOptBLMO, vidx::Int)\n\nCheck whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.set_bound!-Tuple{FrankWolfe.MathOptLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.set_bound!","text":"set_bound!(blmo::MathOptBLMO, c_idx, value, sense::Symbol)\n\nChange the value of the bound c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.solve-Tuple{Any, Any, Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.solve","text":"The solve  function receiving a Boscia.MathOptBLMO.  Converts the lmo into an instance of FrankWolfe.MathOptLMO and calls the main solve function.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Managed-BLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Managed BLMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Sometimes the linear problem over the feasible region can be computed via a combinatorial algorithm that is more efficient than formulating the problem as a MIP. If one does not want to implement the BLMO interface from scratch which requires multiple methods to be provided, we provide the ManagedBLMO. It handles the bound management, so that the user has to implement only a few methods.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.ManagedLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ManagedLMO","text":"ManagedLMO{LMO<:FrankWolfe.LinearMinimizationOracle} <: FrankWolfe.LinearMinimizationOracle\n\nA Linear Minimization Oracle wrapper that manages the bounds.\n\nlmo a FrankWolfe.LinearMinimizationOracle.  \nlower_bounds list of lower bounds for the integer variables recorded in int_vars. If there is no specific lower bound, set corresponding entry to -Inf.\nupper_bounds list of upper bounds for the integer variables recorded in int_vars. If there is no specific upper bound, set corresponding entry to Inf.\nn total number of variables.\nint_vars list of indices of the integer variables.\nsolving_time the time to evaluate compute_extreme_point.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.SimpleBoundableLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.SimpleBoundableLMO","text":"SimpleBoundableLinearMinimizationOracle\n\nA \"simple\" LMO that computes the extreme point given a linear objective and the node specific bounds on the integer variables. Can be stateless since all of the bound management is done by the ManagedBoundedLMO. \n\nWILL BE DEPRECATED!\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(lmo::LinearMinimizationOracle, d, lb, ub, int_vars; kwargs...)\n\nComputes the extreme point given an direction d, the current lower and upper bounds on the integer variables, and the set of indices of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_simple_linear_feasible","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_simple_linear_feasible","text":"is_simple_linear_feasible(lmo::LinearMinimizationOracle, v::AbstractVector)\n\nChecks whether a given point v is satisfying the constraints on the problem. Note that the bounds on the integer variables are being checked by the ManagedBoundedLMO and do not have to be check here. \n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Polytopes","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Polytopes","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Here are some preimplemented polytopes. We have the hypercube, the unit simplex and the probability simplex.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.CubeLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.CubeLMO","text":"CubeSimpleLMO{T}(lower_bounds, upper_bounds, int_vars)\n\nHypercube with lower and upper bounds implementing the SimpleBoundableLMO interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.ProbabilitySimplexLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ProbabilitySimplexLMO","text":"ProbablitySimplexSimpleLMO(N)\n\nThe scaled probability simplex with ∑ x = N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.ReverseKnapsackLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ReverseKnapsackLMO","text":"ReverseKnapsackLMO(N, upper_bounds)\n\nBLMO denotes the reverse Knapsack constraint: ∑ x ≥ N. We assume x ≥ 0.  Explicit upper bounds are needed, otherwise the feasible region is unbounded.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.UnitSimplexLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.UnitSimplexLMO","text":"UnitSimplexLMO(N)\n\nThe scaled unit simplex with ∑ x ≤ N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.CubeLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":" bounded_compute_extreme_point(sblmo::CubeSimpleLMO, d, lb, ub, int_vars; kwargs...)\n\nIf the entry is positve, choose the lower bound. Else, choose the upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.ProbabilitySimplexLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(lmo::ProbabilitySimplexLMO, d, lb, ub, int_vars; kwargs...)\n\nAssign the largest possible values to the entries corresponding to the smallest entries of d.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.ReverseKnapsackLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"Entries corresponding to non positive entries in d, are assigned their upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.UnitSimplexLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(lmo::UnitSimplexSimpleLMO, d, lb, ub, int_vars; kwargs...)\n\nFor all positive entries of d, assign the corresponding lower bound. For non-positive entries, assign largest possible value in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.CubeLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"If the entry in x is at the boundary, choose the corresponding bound. Otherwise, if the entry in direction is positve, choose the lower bound. Else, choose the upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.ProbabilitySimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"Fix the corresponding entries to the boudary based on the given x. Assign the largest possible values to the unfixed entries corresponding to the smallest entries of d.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.UnitSimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"For boundary entries of x, assign the corresponding boudary. For all positive entries of d, assign the corresponding lower bound. For non-positive entries, assign largest possible value in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.CubeLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.ProbabilitySimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.UnitSimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and the sum of entries should satisfy inequality constraint. Return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedLMO{Boscia.ProbabilitySimplexLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":" rounding_hyperplane_heuristic(tree::Bonobo.BnBTree, tlmo::TimeTrackingLMO{ManagedBoundedLMO{ProbabilitySimplexLMO}}, x)\n\nHyperplane-aware rounding for the probability simplex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedLMO{Boscia.ReverseKnapsackLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"Hyperplane-aware rounding for the reverse knapsack constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedLMO{Boscia.UnitSimplexLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"rounding_hyperplane_heuristic(tree::Bonobo.BnBTree, tlmo::TimeTrackingLMO{ManagedBoundedLMO{UnitSimplexLMO}}, x)\n\nHyperplane-aware rounding for the unit simplex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Time-Tracking-BLMO-Wrapper","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Time Tracking BLMO Wrapper","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"This wrapper keeps track of the statistics like solving time of the BLMO, the number of calls etc.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO{LMO<:LinearMinimizationOracle} <: FrankWolfe.LinearMinimizationOracle\n\nA wrapper for the BLMO tracking the solving time, number of calls etc. Is created in Boscia itself.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO-Tuple{LinearMinimizationOracle, Any, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO(lmo::LinearMinimizationOracle, int_vars)\n\nConstructor with just the blmo.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO-Tuple{LinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO(lmo::LinearMinimizationOracle)\n\nConstructor with just the blmo.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.reset!-Tuple{Boscia.TimeTrackingLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.reset!","text":"reset!(tlmo::TimeTrackingLMO)\n\nIf we want to reset the info between nodes in the Branch-and-Bound tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#FrankWolfe.compute_extreme_point-Tuple{Boscia.TimeTrackingLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.compute_extreme_point","text":"FrankWolfe.compute_extreme_point(tlmo::TimeTrackingLMO, d; kwargs...)\n\nCompute the extreme point and collect statistics.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Build-LMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Build LMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Given the global bounds on the integer variables and the bounds at the node level, this builds the BLMO instance for the specific node. This way, the BLMO can be stored in the tree as opposed to every node having a copy of it.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.build_LMO-Tuple{LinearMinimizationOracle, Boscia.IntegerBounds, Boscia.IntegerBounds, Vector{Int64}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO","text":"Build node LMO from global LMO\n\nFour action can be taken:\n\nKEEP   constraint is as saved in the global bounds\nCHANGE lower/upper bound is changed to the node specific one\nDELETE custom bound from the previous node that is invalid at current node and has to be deleted\nADD    bound has to be added for this node because it does not exist in the global bounds (e.g. variable bound is a half open interval globally) \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Integer-Bounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Integer Bounds","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"The data structure that records the bounds on the integer/binary variables.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.IntegerBounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.IntegerBounds","text":"IntegerBounds\n\nKeeps track of the bounds of the integer (binary) variables.\n\nlower_bounds dictionary of Float64, index is the key.\nupper_bounds dictionary of Float64, index is the key.\n\n\n\n\n\n","category":"type"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Graph Isomorphism Problem","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"This example shows how to use Boscia to certify whether two graphs are isomorphic. We encode graph isomorphism via a permutation matrix X that reorders the vertices. Given adjacency matrices A and B, the graphs are isomorphic iff there exists a permutation matrix X such that:   X * A = B * X Equivalently, we consider the smooth objective","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"  f(X) =  X A - B X _F^2","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"which attains the value 0 exactly at an isomorphism. We solve over the Birkhoff polytope (convex hull of permutation matrices) with a branch-and-bound scheme plus Frank–Wolfe in the nodes; the lower bound allows pruning, and a zero incumbent certifies isomorphism.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We also add a simple neighborhood heuristic that (randomly) swaps two rows' 1-positions in a permutation matrix to explore nearby vertices.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"using Boscia\nusing Random\nusing SparseArrays\nusing FrankWolfe\nusing Bonobo\nusing CSV\nusing StableRNGs\nusing CombinatorialLinearOracles\nconst CLO = CombinatorialLinearOracles\n\nprintln(\"\\nDocumentation Example 02: Graph Isomorphism Problem\")\n\nseed = rand(UInt64)\n@show seed\nrng = StableRNG(seed)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Generate-a-random-isomorphic-graph","page":"Graph Isomorphism Problem","title":"Generate a random isomorphic graph","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Given an adjacency matrix A, this function creates a random permutation matrix P and returns the permuted adjacency matrix B = P * A * P'. The resulting graphs A and B are isomorphic, and P encodes the vertex relabeling between them.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function randomIsomorphic(A)\n    n = size(A, 1)\n    p = randperm(n)\n    P = sparse(1:n, p, ones(Float64, n), n, n)\n    B = P * A * P'\n    return B, P\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Generate-a-random-non-isomorphic-graph","page":"Graph Isomorphism Problem","title":"Generate a random non-isomorphic graph","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Given an adjacency matrix A, this function randomly toggles one edge (adds or removes it) to create a new graph B. The resulting graph B is symmetric and typically non-isomorphic to A.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function randomNonIsomorphic(A::AbstractMatrix)\n    B = copy(A)\n    n = size(B, 1)\n    i = rand(1:(n-1))\n    j = rand((i+1):n)\n    B[i, j] = 1 - B[i, j]\n    B[j, i] = B[i, j]\n    return B\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Neighborhood-heuristic-over-the-Birkhoff-polytope","page":"Graph Isomorphism Problem","title":"Neighborhood heuristic over the Birkhoff polytope","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We implement a simple k-swap heuristic that takes the current incumbent permutation, selects two distinct rows i≠j, finds the 1-entry in each row, and swaps their column positions—producing a neighboring permutation matrix. Repeating k times yields k candidate neighbors.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function random_k_neighbor_matrix(\n    tree::Bonobo.BnBTree,\n    blmo::Boscia.TimeTrackingLMO,\n    x,\n    k::Int,\n    use_mip = false,\n)\n    P = tree.incumbent_solution.solution\n    n0 = size(P, 1)\n    n = Int(sqrt(n0))\n    P = reshape(P, n, n)\n    new_P = copy(P)\n    Ps = []\n    for _ = 1:k\n        i, j = rand(1:n, 2)\n        while i == j\n            j = rand(1:n)\n        end\n        col_i = findfirst(x -> x == 1, new_P[i, :])\n        col_j = findfirst(x -> x == 1, new_P[j, :])\n        new_P[i, col_i] = 0\n        new_P[i, col_j] = 1\n        new_P[j, col_j] = 0\n        new_P[j, col_i] = 1\n        new_p = use_mip ? vec(new_P) : sparsevec(vec(new_P))\n        push!(Ps, new_p)\n    end\n    return Ps, false\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Graph-data","page":"Graph Isomorphism Problem","title":"Graph data","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"For this self-contained example, we use the Petersen graph as A. We then create B either as an isomorphic graph via a random permutation, or as a non-isomorphic graph by randomly toggling one edge.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"path = joinpath(@__DIR__, \"Petersen.csv\")\nrows = [collect(Int, r) for r in CSV.File(path; header = false, types = Int)]\nconst A = sparse(reduce(vcat, (permutedims(r) for r in rows)))\nn = size(A, 1)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"–- Isomorphic case –-","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"B, P = randomIsomorphic(Matrix(A))\nB = sparse(B)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#–-Non-isomorphic-case-–","page":"Graph Isomorphism Problem","title":"–- Non-isomorphic case –-","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"B = randomNonIsomorphic(A)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Objective-and-gradient","page":"Graph Isomorphism Problem","title":"Objective and gradient","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We represent X as a vector x ∈ ℝ^{n^2}, reshaped into X ∈ ℝ^{n×n} in the routines. Objective:     f(x) = || X A - B X ||_F^2 Gradient (by standard matrix calculus):     ∇f(X) = 2 (X A - B X) A' - 2 B' (X A - B X) We return/accept vectorized storage for Boscia/Frank–Wolfe.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function f(x)\n    X = reshape(x, n, n)\n    R = X * A - B * X\n    return sum(abs2, R)\nend\n\nfunction grad!(storage, x)\n    X = reshape(x, n, n)\n    grad_matrix = 2 * (X * A - B * X) * A' - 2 * B' * (X * A - B * X)\n    storage .= vec(grad_matrix)\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Linear-Minimization-Oracle-(LMO)","page":"Graph Isomorphism Problem","title":"Linear Minimization Oracle (LMO)","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We use the Birkhoff LMO from CombinatorialLinearOracles, i.e., linear optimization over the Birkhoff polytope is solved by the Hungarian algorithm.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"blmo = CLO.BirkhoffLMO(n, collect(1:(n^2)))","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Branching-and-pruning-callbacks","page":"Graph Isomorphism Problem","title":"Branching & pruning callbacks","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Branch callback: If the node’s lower bound is already strictly positive, no permutation can reach objective 0 in this subtree, so we prune.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function build_branch_callback()\n    return function (tree, node, vidx::Int)\n        x = Bonobo.get_relaxed_values(tree, node)\n        primal = tree.root.problem.f(x)\n        lower_bound = primal - node.dual_gap\n        if lower_bound > 0.0 + eps()\n            println(\"No need to branch here. Node lower bound already positive.\")\n        end\n        valid_lower = lower_bound > 0.0 + eps()\n        return valid_lower, valid_lower\n    end\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Tree callback: Early-stop logic.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"If the incumbent reaches 0 (within tolerance), we have found an isomorphism.\nIf the global tree lower bound becomes strictly positive, we can certify non-isomorphism.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function build_tree_callback()\n    return function (\n        tree,\n        node;\n        worse_than_incumbent = false,\n        node_infeasible = false,\n        lb_update = false,\n    )\n        if isapprox(tree.incumbent, 0.0, atol = eps())\n            tree.root.problem.solving_stage = Boscia.USER_STOP\n            println(\"Optimal solution found.\")\n        end\n        if Boscia.tree_lb(tree::Bonobo.BnBTree) > 0.0 + eps()\n            tree.root.problem.solving_stage = Boscia.USER_STOP\n            println(\"Tree lower bound already positive. No solution possible.\")\n        end\n    end\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Heuristic-configuration","page":"Graph Isomorphism Problem","title":"Heuristic configuration","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We pick k ~ sqrt(n) random neighbors per heuristic call.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"k = Int(round(sqrt(n)))\nswap_heu = Boscia.Heuristic(\n    (tree, blmo, x) -> random_k_neighbor_matrix(tree, blmo, x, k, false),\n    1.0,\n    :swap,\n)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Solver-settings","page":"Graph Isomorphism Problem","title":"Solver settings","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Configure Boscia settings","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"settings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = true\nsettings.branch_and_bound[:print_iter] = 10\nsettings.branch_and_bound[:bnb_callback] = build_tree_callback()\nsettings.branch_and_bound[:branch_callback] = build_branch_callback()\nsettings.heuristic[:custom_heuristics] = [swap_heu]\nsettings.frank_wolfe[:variant] = Boscia.DecompositionInvariantConditionalGradient()\nsettings.frank_wolfe[:line_search] = FrankWolfe.Secant()\nsettings.frank_wolfe[:lazy] = true\nsettings.frank_wolfe[:max_fw_iter] = 1000","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Solve-the-graph-isomorphism-problem","page":"Graph Isomorphism Problem","title":"Solve the graph isomorphism problem","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"x, _, result = Boscia.solve(f, grad!, blmo, settings = settings)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Certificate","page":"Graph Isomorphism Problem","title":"Certificate","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"If the graphs are isomorphic, the optimizer should recover a permutation matrix X with objective value f(X) = 0, satisfying B = X * A * X' (equivalently, A ≈ X' * B * X).","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"X = reshape(x, n, n)\n@assert A ≈ X' * B * X\nprintln(\"Certificate verified: graphs are isomorphic (A ≈ X' * B * X)\")","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"If the graphs are not isomorphic, no perfect permutation exists, and the optimization problem yields a positive lower bound. @assert result[:dual_bound] > 0.0 println(\"Graphs are not isomorphic (lower bound > 0)\")","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/custom/#Branch-and-Bound-tree-functionality","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"The functionality of the Branch-and-Bound implementation extended from Bonobo.jl and some extended features like strong branching and the callbacks.","category":"page"},{"location":"reference/custom/#Problem","page":"Branch-and-Bound tree functionality","title":"Problem","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"The main problem structure as stored in the Branch-and-Bound tree.","category":"page"},{"location":"reference/custom/#Boscia.SimpleOptimizationProblem","page":"Branch-and-Bound tree functionality","title":"Boscia.SimpleOptimizationProblem","text":"Represents an optimization problem of the form:\n\nmin_x f(x)\ns.t.  x ∈ X (given by the LMO)\n      x_j ∈ Z ∀ j in integer_variables\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.get_branching_indices-Tuple{Boscia.SimpleOptimizationProblem}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_indices","text":"Returns the indices of the discrete variables for the branching in Bonobo.BnBTree\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.indicator_present-Tuple{Boscia.TimeTrackingLMO}","page":"Branch-and-Bound tree functionality","title":"Boscia.indicator_present","text":"Are indicator constraints present\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_integer_feasible-Tuple{AbstractVector{<:Integer}, AbstractVector}","page":"Branch-and-Bound tree functionality","title":"Boscia.is_integer_feasible","text":"Checks if a given vector is valid integral solution. Specifically for mixed problems.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_linear_feasible-Tuple{Boscia.TimeTrackingLMO, AbstractVector}","page":"Branch-and-Bound tree functionality","title":"Boscia.is_linear_feasible","text":"Checks if x is valid for all linear and variable bound constraints \n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Customized-Bonobo-structures-and-functions","page":"Branch-and-Bound tree functionality","title":"Customized Bonobo structures and functions","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Our adaptations to the functions in Bonobo.jl. ","category":"page"},{"location":"reference/custom/#Bonobo.optimize!-Tuple{Bonobo.BnBTree{var\"#s23\", Root, Value, Solution} where {var\"#s23\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s23\", Value}}}","page":"Branch-and-Bound tree functionality","title":"Bonobo.optimize!","text":"optimize!(tree::BnBTree; callback=(args...; kwargs...)->())\n\nOptimize the problem using a branch and bound approach.  The steps, repeated until terminated is true, are the following:\n\n# 1. get the next open node depending on the traverse strategy\nnode = get_next_node(tree, tree.options.traverse_strategy)\n# 2. evaluate the current node and return the lower and upper bound\n# if the problem is infeasible both values should be set to NaN\nlb, ub = evaluate_node!(tree, node)\n# 3. update the upper and lower bound of the node struct\nset_node_bound!(tree.sense, node, lb, ub)\n# 4. update the best solution\nupdated = update_best_solution!(tree, node)\nupdated && bound!(tree, node.id)\n# 5. remove the current node\nclose_node!(tree, node)\n# 6. compute the node children and adds them to the tree\n# internally calls get_branching_variable and branch_on_variable!\nbranch!(tree, node)\n\nA callback function can be provided which will be called whenever a node is closed. It always has the arguments tree and node and is called after the node is closed.  Additionally the callback function must accept additional keyword arguments (kwargs)  which are set in the following ways:\n\nIf the node is infeasible the kwarg node_infeasible is set to true.\nIf the node has a higher lower bound than the incumbent the kwarg worse_than_incumbent is set to true.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Node-Evaluation","page":"Branch-and-Bound tree functionality","title":"Node Evaluation","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Evaluation of the nodes and handling of branching.","category":"page"},{"location":"reference/custom/#Boscia.AbstractFrankWolfeNode","page":"Branch-and-Bound tree functionality","title":"Boscia.AbstractFrankWolfeNode","text":"AbtractFrankWolfeNode <: Bonobo.AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Boscia.FrankWolfeNode","page":"Branch-and-Bound tree functionality","title":"Boscia.FrankWolfeNode","text":"FrankWolfeNode <: AbstractFrankWolfeNode\n\nA node in the branch-and-bound tree storing information for a Frank-Wolfe subproblem.\n\nstd stores the id, lower and upper bound of the node. active_set store the active set structure. local_bounds instead of storing the complete LMO, it just stores the bounds specific to THIS node.     All other integer bounds are stored in the root. 'level' stores the level in the tree 'fwdualgaplimit' set the tolerance for the dual gap in the FW algorithms 'precomputedset' stores specifically the extreme points computed in DICG for warm-start. 'parentlowerboundbase' contains lower bound value of the parent node.  Needed     for updating pseudocosts. 'branchedon' contains the index of the parent. Required for updating pseudocosts. 'branchedright' Boolean value specifying if node resulted from a left or right branch. Needed     for updating pseudocosts. 'distancetoint' Stores information on the rounding amount at branching. Required     for correct scaling of pseudocosts.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Boscia.NodeInfo","page":"Branch-and-Bound tree functionality","title":"Boscia.NodeInfo","text":"NodeInfo\n\nHolds the necessary information of every node. This needs to be added by every AbstractNode as std::NodeInfo\n\nThis variant is more flexibel than Bonobo.BnBNodeInfo.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.evaluate_node!-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode}","page":"Branch-and-Bound tree functionality","title":"Bonobo.evaluate_node!","text":"Computes the relaxation at that node\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Bonobo.get_branching_nodes_info-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode, Int64}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_nodes_info","text":"Create the information of the new branching nodes  based on their parent and the index of the branching variable\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Bonobo.get_relaxed_values-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_relaxed_values","text":"Returns the solution vector of the relaxed problem at the node\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Callbacks","page":"Branch-and-Bound tree functionality","title":"Callbacks","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"There are two callbacks.  One for the Branch-and-Bound tree that records progress data, checks the time limit and prints the logs. The other is a callback for the Frank-Wolfe runs that runs some checks in each iteration.  Additionally, the computed vertices are added to the solution pool. Lastly, the Frank-Wolfe solve can be interrupted if either the dual bound has reached the current incumbent or  there are enough more promising nodes open.","category":"page"},{"location":"reference/custom/#Boscia.build_FW_callback-Tuple{Any, Any, Bool, Vararg{Any, 4}}","page":"Branch-and-Bound tree functionality","title":"Boscia.build_FW_callback","text":"Frank-Wolfe Callback.\n\nIs called in every Frank-Wolfe iteration. Node evaluation can be dynamically stopped here. Time limit is checked. If the vertex is providing a better incumbent, it is added as solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.build_bnb_callback-NTuple{22, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.build_bnb_callback","text":"Branch-and-Bound Callback. Collects statistics and prints logs if verbose is turned on.\n\nOutput of Boscia:     iter :          current iteration of Boscia     node id :       current node id     lower bound :   treelb(tree)     incumbent :     tree.incumbent     gap :           tree.incumbent-treelb(tree)     rel. gap :      dualgap/tree.incumbent     time :          total time of Boscia     time/nodes :    average time per node     FW time :       time spent in FW      LMO time :      time used by LMO     LMO calls :     number of computeextreme_point calls in FW     FW iterations : number of iterations in FW\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Tightenings","page":"Branch-and-Bound tree functionality","title":"Tightenings","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Tightenings are performed on node level and can be used either just for the node in question or globally. If the obejctive is strongly convex and/or sharp, this can also be used to tighten the lower bound at the current node. ","category":"page"},{"location":"reference/custom/#Boscia.dual_tightening-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.dual_tightening","text":"Tightening of the bounds at node level. Children node inherit the updated bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.global_tightening-Tuple{Any, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.global_tightening","text":"Use the gradient of the root node to tighten the global bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.prune_children-NTuple{5, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.prune_children","text":"Use strong convexity and/or sharpness to potentially remove one of the children nodes. If both sharpness and strong convexity parameters are provided, strong convexity is preferred.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.store_data_global_tightening-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.store_data_global_tightening","text":"Save the gradient of the root solution (i.e. the relaxed solution) and the  corresponding lower and upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.tightening_lowerbound-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.tightening_lowerbound","text":"Tighten the lower bound using strong convexity and/or sharpness of the objective.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Strong-and-Hybrid-Branching","page":"Branch-and-Bound tree functionality","title":"Strong and Hybrid Branching","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"We provide a strong branching strategy consisting of running Frank-Wolfe for only a few iterations to get an estimate of the bound increase. Due to the cost of strong branching, it is usually not advisable to run strong branching through the whole tree. Hence, we provide a hybrid branching which performs strong branching until a user specified depth and then switches to most-infeasible branching. ","category":"page"},{"location":"reference/custom/#Boscia.HybridStrongBranching","page":"Branch-and-Bound tree functionality","title":"Boscia.HybridStrongBranching","text":"Hybrid between partial strong branching and another strategy. perform_strong_branch(tree, node) -> Bool decides whether to perform strong branching or not.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.get_branching_variable-Union{Tuple{LMO}, Tuple{Bonobo.BnBTree, Boscia.PartialStrongBranching{LMO}, Bonobo.AbstractNode}} where LMO<:LinearMinimizationOracle","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_variable","text":"Get branching variable using strong branching. Create all possible subproblems, solve them and pick the one with the most progress.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.strong_up_to_depth","page":"Branch-and-Bound tree functionality","title":"Boscia.strong_up_to_depth","text":"strongupto_depth performs strong branching on nodes up to a predetermined depth, and the falls back to another rule\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Algorithm-Interface","page":"Algorithm Interface","title":"Algorithm Interface","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia's solve function only requires the oracles of the objective function f and its gradient g as well as the BLMO encoding the feasible region. For the possible settings, see further down the page.","category":"page"},{"location":"reference/1_algorithms/#Boscia.postsolve-NTuple{5, Any}","page":"Algorithm Interface","title":"Boscia.postsolve","text":"postsolve(tree, result, time_ref, verbose, max_iteration_post)\n\nRuns the post solve to optimize for the continuous variables if present. Is called if use_post_solve is enabled in the solve function. Prints solution statistics if verbose is set to true.        \n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.solve-Tuple{Any, Any, LinearMinimizationOracle}","page":"Algorithm Interface","title":"Boscia.solve","text":"solve(f, g, lmo::LinearMinimizationOracle; ...)\n\nRequires\n\nf oracle of the objective function.\ng oracle of the gradient of the objective\nlmo encodes the feasible region and can handle additional bound constraints. This can either be a MIP solver instance (e.g., SCIP) or be a custom type (see polytope_blmos.jl). Has to be of type FrankWolfe.LinearMinimizationOracle (see blmo_interface.jl).\n\nReturns\n\nx the best solution found.\ntlmo the LMO wrapped in a TimeTrackingLMO instance.\nresult a dictionary containg the statistics like number of nodes, total solving etc. It also contains information for plotting progress plots like the lower and upper bound progress.\n\nOptional settings\n\nsettings_bnb dictionary of settings for the branch-and-bound algorithm. Created via settings_bnb().\nsettings_frank_wolfe dictionary of settings for the Frank-Wolfe algorithm. Created via settings_frank_wolfe().\nsettings_tolerances dictionary of settings for the tolerances. Created via settings_tolerances().\nsettings_postprocessing dictionary of settings for the postprocessing. Created via settings_postprocessing().\nsettings_heuristic dictionary of settings for the heuristics. Created via settings_heuristic().\nsettings_tightening dictionary of settings for the tightening. Created via settings_tightening().\nsettings_domain dictionary of settings for the domain. Created via settings_domain().\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Optional-settings","page":"Algorithm Interface","title":"Optional settings","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia has a lot of settings to customize the solving process. These are grouped by ","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"general Branch-and-Bound settings \nsettings specific for Frank-Wolfe \ntolerances settings for both the tree as well as the Frank-Wolfe algorithm \nsettings for the heuristics\nbound tightenings settings\npostprocessing settings\nparameters for the case of a non-trivial domain, i.e. the objective cannot be evaluated at all points of the feasible region","category":"page"},{"location":"reference/1_algorithms/#Boscia.create_default_settings-Tuple{}","page":"Algorithm Interface","title":"Boscia.create_default_settings","text":"Create default settings depending on the mode.\n\nOnly requires the mode, if no mode is provided, the default mode is used. Returns a NamedTuple of dictionaries for the different group of settings.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_bnb-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_bnb","text":"settings_bnb(mode::Mode;...)\n\nSet the settings for the branch-and-bound algorithm.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the branch-and-bound algorithm.\n\nAvailable settings:\n\ntraverse_strategy encodes how to choose the next node for evaluation. By default the node with the best lower bound is picked.\nbranching_strategy fixes the branching strategy. By default, weuse MOST_INFEASIBLE, i.e. we branch on the entry which is the farthest away from being an integer.\nverbose if true, logs and solution statistics are printed. Per default, this is false.\nnode_limit maximum number of nodes to be evaluated. In DEFAULT mode, there is no limit. In HEURISTIC mode, the default is set to 1000.\ntime_limit algorithm will stop if the time limit is reached. Depending on the problem it is possible that no feasible solution has been found yet. In DEFAULT mode, there is no time limit. In HEURISTIC mode, the default is set to 300 seconds (5 minutes).\nprint_iter encodes after how many processed nodes the current node and solution status is printed. The logs are always printed if a new integral solution has been found. Per default, print_iter is set to 100`.\nbnb_callback optional callback function that is called after every node evaluation. It will be called before the Boscia internal callback handling the printing of the logs. It receives the tree, the node and the following keyword arguments: worse_than_incumbent=false, node_infeasible=false, lb_update=false.\nbranch_callback an optional callback called before branching. Receives the tree, the node and the branching variable index as input. Expected output is a pair of boolean values indicating whether the left and right child should be pruned. falseindicates prune the child, true indicates keep the child.\nno_pruning if true, no pruning of nodes is performed. Per default, nodes are pruned if they have a lower bound which is worse than the best known solution. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\nignore_lower_bound if true, the lower bound obtain by Frank-Wolfe is ignored and in the logs, only Inf will be printed. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\nstart_solution an initial solution can be provided if known. It will be used as the initial incumbent.\nuse_shadow_set the shadow set is the set of discarded vertices which is inherited by the children nodes. It is used to avoid recomputing of vertices in case the LMO is expensive. In case of a cheap LMO, performance might improve by disabling this option. Per default, this is true.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_domain-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_domain","text":"settings_domain(mode::Mode;...)\n\nTo set settings for a non-trivial domain, i.e. if not all points of the feasible region are domain feasible.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the domain.\n\nAvailable settings:\n\ndomain_oracle given a point x: returns true if x is in the domain of f, else false. Per default, it always returns true. In case of the non-trivial domain oracle, the initial point has to be domain feasible for f and can be set via the active_set. Additionally, the user has to provide a functiondomain_point`, see below. Also, depending on the line search method, you might have to provide the domain oracle to it, too. The default line search Secant, for example, requires the domain oracle.\nfind_domain_point given the current node bounds return a domain feasible point respecting the bounds. If no such point can be found, return nothing. Only necessary for a non-trivial domain oracle.\nactive_set can be used to specify a starting point. By default, the direction (1,..,n) where n is the size of the problem is used to find a start vertex. This has to be of the type FrankWolfe.ActiveSet. Beware that the active set may only contain actual vertices of the feasible region.\ndepth_domain The domain point is used to generate new starting points after branching by solving a projection problem. This parameter is used to control how far we move into the domain.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_frank_wolfe-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_frank_wolfe","text":"settings_frank_wolfe(mode::Mode;...)\n\nOptions for the Frank-Wolfe algorithm used as node solver.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the Frank-Wolfe algorithm.\n\nAvailable settings:\n\nvariant the Frank-Wolfe variant to be used to solve the node problem. Options currently available are AwayFrankWolfe, BlendedConditionalGradient, BlendedPairwiseConditionalGradient, DecompositionInvariantConditionalGradient and StandardFrankWolfe. Per default, this is set to BlendedPairwiseConditionalGradient.\nline_search specifies the line search method used in the FrankWolfe variant. Default is the FrankWolfe.Secant line search. For other available types, check the FrankWolfe.jl package.\nmax_fw_iter maximum number of iterations in a Frank-Wolfe run. Per default, this is set to 10000.\nfw_timeout time limit for the Frank-Wolfe runs. Per default, there is no time limit. It is preferred to set the iteration limit but this can be used as a fallback and/or if the LMO call is time consuming.\nmin_fw_iterations the minimum number of Frank-Wolfe iterations performed in the node evaluation. Per default, this is set to 5.\nfw_verbose if true, the Frank-Wolfe logs are printed at each node. Mostly meant for debugging. Per default, this is false.\nlazy flag specifies whether the lazification of the Frank-Wolfe variant should be used. Per default true. Note that it has no effect on standard Frank-Wolfe.\nlazy_tolerance decides how much progress is deemed enough to not have to call the LMO. Only used if the lazy flag is activated. Per default, this is set to 2.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_heuristic-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_heuristic","text":"settings_heuristic(mode::Mode;...)\n\nSet the settings for the heuristics.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the heuristics.\n\nAvailable settings:\n\ncustom_heuristics list of custom heuristics from the user. Heuristics can be created via the Boscia.Heuristic constructor. It requires a function, a probability and an identifier (symbol). Note that the heuristics defined in Boscia themselves don't have to be added here and can be set via the probability parameters below.\npost_heuristics_callback callback function called whenever a new solution is found and added to the tree. \nprob_rounding the probability for calling the simple rounding heuristic. Since the feasibility has to be checked, it might be expensive to do this for every node. Per default, this is activated for every node.\nfollow_gradient_prob the probability for calling the follow-the-gradient heuristic. Per default, this is 0.0.\nfollow_gradient_steps the number of steps for the follow-the-gradient heuristic. Per default, this is 10.\nrounding_lmo_01_prob the probability for calling the rounding-LMO-01 heuristic. Per default, this is 0.0.\nprobability_rounding_prob the probability for calling the probability-rounding heuristic. Per default, this is 0.0.\nhyperplane_aware_rounding_prob the probability for calling the hyperplane-aware-rounding heuristic. Per default, this is 0.0.\nadd_all_solutions if true, all solutions found by the heuristics, Frank-Wolfe or the LMO are added to the tree. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_postprocessing-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_postprocessing","text":"settings_postprocessing(mode::Mode;...)\n\nSet the settings for the postprocessing.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the postprocessing.\n\nAvailable settings:\n\nuse_postsolve if true, runs the specified Frank-Wolfe variant on the problem with the integral variables fixed to the solution, i.e. it only optimizes over the continuous variables. This might improve the solution if one has many continuous variables. Per default, this is true.\nmax_iteration_post maximum number of iterations in the Frank-Wolfe run during postsolve. Per default, this is set to 10000.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_tightening-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_tightening","text":"settings_tightening(mode::Mode;...)\n\nSet the tightening parameters.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the tightening.\n\nAvailable settings:\n\ndual_tightening flag to decide  whether to use dual tightening techniques at node level. Note that this only porvides valid tightenings if your function is convex! Per default, this is true.\nglobal_dual_tightening flag to decide whether to generate dual tightenings from new solutions that are gloablly valid. Per default, this is true.\nstrong_convexity strong convexity parameter of the objective f, used for tightening the dual bound at every node. Per default, this is set to 0.0.\nsharpness_constant - the constant M > 0 for (θ, M)-sharpness. f is (θ, M)-sharpness: f satisfies min_{x^* ∈ X^*} || x - x^* || ≤ M (f(x) - f^(x^*))^θ where X^* is the set of minimizer of f. Note that tightenings using sharpness are only valid if the problem has a unique minimizer, i.e. f is stricly convex! Per default, this is set to 0.0.\nsharpness_exponent - the exponent θ ∈ [0, 1/2] for (θ, M)-sharpness. Per default, this is set to Inf.\npropagate_bounds optional function that allows the user to propagate and tighten bounds depending on the node. Receives the tree and the node as input.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_tolerances-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_tolerances","text":"settings_tolerances(mode::Mode;...)\n\nSet the tolerances for the Frank-Wolfe algorithm. These are tolerances both for the Branch-and-Bound tree as well as for the Frank-Wolfe variant used as node solver.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of tolerances for the Frank-Wolfe algorithm.\n\nAvailable settings:\n\nfw_epsilon the solving precision of Frank-Wolfe at the root node.\ndual_gap absolute dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to 1e-6.\nrel_dual_gap relative dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to 1e-2.\ndual_gap_decay_factor the FrankWolfe tolerance at a given level i in the tree is given by fw_epsilon * dual_gap_decay_factor^i until we reach the min_node_fw_epsilon. Per default, this is set to 0.8.\nmin_number_lower if not Inf, evaluation of a node is stopped if at least min_number_lower open nodes have a better lower bound. Per default, this is set to Inf.\nmin_node_fw_epsilon smallest fw epsilon tolerance, see also dual_gap_decay_factor. Per default, this is set to 1e-6.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Definitions","page":"Algorithm Interface","title":"Definitions","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia defines its own solving state.  Additionally, Boscia has different modes, like the DEFAULT_MODE and HEURISTIC_MODE. These have their own default settings for the optional parameters.","category":"page"},{"location":"reference/0_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/0_reference/","page":"API Reference","title":"API Reference","text":"In this section we present the algorithm interface and the possible settings.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Network Design Problem Example","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This example demonstrates solving a network design problem using Boscia.jl with two approaches:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"MOI-based LMO: Using MathOptInterface to model the feasible region\nCustom LMO: Using a customized Linear Minimization Oracle based on shortest path algorithms","category":"page"},{"location":"examples/docs-01-network-design/#Problem-Description","page":"Network Design Problem","title":"Problem Description","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"We solve a transportation network design problem where:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Some edges have been removed from the network\nWe decide which edges to restore (binary decision y[e])\nTraffic flows are routed to minimize total travel time (with BPR congestion)\nFlow conservation constraints must be satisfied\nLinking constraints: x[e] <= M * ye","category":"page"},{"location":"examples/docs-01-network-design/#Key-Difference-Between-Approaches","page":"Network Design Problem","title":"Key Difference Between Approaches","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"IMPORTANT: The two approaches solve DIFFERENT formulations of the same problem!","category":"page"},{"location":"examples/docs-01-network-design/#MOI-based-LMO","page":"Network Design Problem","title":"MOI-based LMO","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Enforces linking constraints x[e] <= M*y[e] as HARD constraints in the MOI model\nObjective: minimize BPRcost(x) + restorationcost(y)\nFinds feasible solution satisfying all constraints exactly","category":"page"},{"location":"examples/docs-01-network-design/#Custom-LMO","page":"Network Design Problem","title":"Custom LMO","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Cannot encode linking constraints x[e] <= M*y[e] in the shortest-path oracle\nInstead, adds PENALTY TERMS to the objective function\nObjective: minimize BPRcost(x) + restorationcost(y) + ρ·∑max(0, x[e] - M*y[e])²\nUses penalty method to discourage constraint violations","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Because they optimize different objective functions, they may find different solutions! The penalty weight ρ controls the tradeoff between optimality and feasibility.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"using Boscia\nusing FrankWolfe\nusing Graphs\nusing SparseArrays\nusing LinearAlgebra\nimport MathOptInterface\nconst MOI = MathOptInterface\nusing HiGHS\n\nprintln(\"\\nDocumentation Example 01: Network Design Problem\")","category":"page"},{"location":"examples/docs-01-network-design/#Data-Structure","page":"Network Design Problem","title":"Data Structure","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Simple graph structure with edge weights and demands","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"mutable struct NetworkData\n    num_nodes::Int\n    num_edges::Int\n    init_nodes::Vector{Int}\n    term_nodes::Vector{Int}\n    free_flow_time::Vector{Float64}\n    capacity::Vector{Float64}\n    b::Vector{Float64}  # BPR function parameter\n    power::Vector{Float64}  # BPR function exponent\n    travel_demand::Matrix{Float64}\n    num_zones::Int\nend","category":"page"},{"location":"examples/docs-01-network-design/#Load-Network","page":"Network Design Problem","title":"Load Network","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Transportation network matching the purchasable edge diagram 2 sources (S1, S2) → 5 intermediate nodes → 1 destination (D) Total: 8 nodes","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"IMPORTANT: Node numbering is constrained by the code structure The code requires zones 1..numzones to BE nodes 1..numzones So: Node 1=S1 (zone 1), Node 2=S2 (zone 2), Node 3=D (zone 3) Nodes 4-8 are the 5 intermediate nodes from the diagram","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Mapping from diagram to code: Diagram -> Code numbering S1 -> 1, S2 -> 2, D -> 3 intermediate nodes 1,2,3,4,5 -> 4,5,6,7,8","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Network topology from your description: S1(1) → node1(4) S2(2) → node3(6) node1(4) → node3(6) node2(5) → node1(4), D(3) node3(6) → node1(4), node4(7) node4(7) → node3(6), node5(8) node5(8) → node4(7), D(3) Optional edge: node1(4) → node2(5) [the purchasable dashed edge]","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function load_braess_network()\n    init_nodes = [1, 2, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4]\n    term_nodes = [4, 6, 6, 4, 3, 4, 7, 6, 8, 7, 3, 5]\n    free_flow_time = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n    capacity = [10.0, 10.0, 10.0, 10.0, 1.5, 10.0, 10.0, 10.0, 10.0, 10.0, 1.5, 10.0]\n    b = [0.1, 0.1, 0.1, 0.1, 3.0, 0.1, 0.1, 0.1, 0.1, 0.1, 3.0, 0.1]\n    power = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]\n    travel_demand = [0.0 0.0 1.0; 0.0 0.0 1.0; 0.0 0.0 0.0]\n    return NetworkData(8, length(init_nodes), init_nodes, term_nodes, free_flow_time,\n                      capacity, b, power, travel_demand, 3)\nend","category":"page"},{"location":"examples/docs-01-network-design/#Shortest-Path-Dijkstra-Implementation","page":"Network Design Problem","title":"Shortest Path Dijkstra Implementation","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Custom Dijkstra implementation for traffic assignment","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function traffic_dijkstra(graph, travel_time, origin, link_dic)\n    state = Graphs.dijkstra_shortest_paths(graph, origin)\n    return state\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Add demand to flow vector following shortest path","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function add_demand_to_path!(x, demand, state, origin, destination, link_dic, edge_list, num_zones)\n    current = destination\n    parent = -1\n    edge_count = length(edge_list)\n    agg_start = edge_count * num_zones\n\n    while parent != origin && origin != destination && current != 0\n        parent = state.parents[current]\n        if parent != 0\n            link_idx = link_dic[parent, current]\n            if link_idx != 0\n                x[(destination - 1) * edge_count + link_idx] += demand\n                x[agg_start + link_idx] += demand\n            end\n        end\n        current = parent\n    end\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"All-or-nothing assignment: route all flow on shortest paths","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function all_or_nothing_assignment(travel_time_vector, net_data, graph, link_dic, edge_list)\n    num_zones = net_data.num_zones\n    edge_count = net_data.num_edges\n    travel_time = travel_time_vector[num_zones * edge_count + 1 : (num_zones + 1) * edge_count]\n    x = zeros(length(travel_time_vector))\n\n    for origin in 1:num_zones\n        state = Graphs.dijkstra_shortest_paths(graph, origin)\n\n        for destination in 1:num_zones\n            demand = net_data.travel_demand[origin, destination]\n            if demand > 0\n                add_demand_to_path!(x, demand, state, origin, destination,\n                                  link_dic, edge_list, num_zones)\n            end\n        end\n    end\n\n    return x\nend","category":"page"},{"location":"examples/docs-01-network-design/#Custom-LMO-using-Shortest-Path","page":"Network Design Problem","title":"Custom LMO using Shortest Path","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Custom Linear Minimization Oracle using shortest path computations","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"struct ShortestPathLMO <: FrankWolfe.LinearMinimizationOracle\n    graph::Graphs.SimpleDiGraph{Int}\n    net_data::NetworkData\n    link_dic::SparseMatrixCSC{Int, Int}\n    edge_list::Vector{Tuple{Int, Int}}\nend\n\nfunction Boscia.bounded_compute_extreme_point(lmo::ShortestPathLMO, direction,\n                                               lower_bounds, upper_bounds, int_vars)\n    x = all_or_nothing_assignment(direction, lmo.net_data, lmo.graph,\n                                  lmo.link_dic, lmo.edge_list)\n    for (i, var_idx) in enumerate(int_vars)\n        if direction[var_idx] < 0\n            x[var_idx] = upper_bounds[i]\n        else\n            x[var_idx] = lower_bounds[i]\n        end\n    end\n    return x\nend\n\nfunction Boscia.is_simple_linear_feasible(lmo::ShortestPathLMO, x)\n    num_zones = lmo.net_data.num_zones\n    num_edges = lmo.net_data.num_edges\n    return all(x .>= -1e-6)\nend","category":"page"},{"location":"examples/docs-01-network-design/#MOI-Model-Setup","page":"Network Design Problem","title":"MOI Model Setup","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Build MOI model with flow conservation and network design constraints Big-M formulation: x[dest, edge] <= M * y[edge] When y=1 (restore), flow can be up to M When y=0 (closed), flow must be 0 Indicator constraint: y[edge] = 0 => x[dest, edge] = 0 Note: Indicator constraints may not be supported by all solvers","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function build_moi_model(net_data, removed_edges, use_big_m=true)\n    optimizer = HiGHS.Optimizer()\n    MOI.set(optimizer, MOI.Silent(), true)\n    num_zones = net_data.num_zones\n    num_edges = net_data.num_edges\n    num_removed = length(removed_edges)\n    num_flow_vars = num_zones * num_edges  # x[dest, edge]\n    num_agg_vars = num_edges  # x_agg[edge]\n    num_design_vars = num_removed  # y[removed_edge] binary\n    total_vars = num_flow_vars + num_agg_vars + num_design_vars\n    x = MOI.add_variables(optimizer, num_flow_vars)\n    x_agg = MOI.add_variables(optimizer, num_agg_vars)\n    y = MOI.add_variables(optimizer, num_design_vars)\n    for i in 1:num_flow_vars\n        MOI.add_constraint(optimizer, x[i], MOI.GreaterThan(0.0))\n    end\n    for i in 1:num_agg_vars\n        MOI.add_constraint(optimizer, x_agg[i], MOI.GreaterThan(0.0))\n    end\n    for i in 1:num_design_vars\n        MOI.add_constraint(optimizer, y[i], MOI.ZeroOne())\n    end\n    edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i]) for i in 1:num_edges]\n    edge_dict = Dict(edge_list[i] => i for i in eachindex(edge_list))\n    incoming = Dict{Int, Vector{Int}}()\n    outgoing = Dict{Int, Vector{Int}}()\n\n    for (idx, (src, dst)) in enumerate(edge_list)\n        if !haskey(outgoing, src)\n            outgoing[src] = Int[]\n        end\n        push!(outgoing[src], idx)\n\n        if !haskey(incoming, dst)\n            incoming[dst] = Int[]\n        end\n        push!(incoming[dst], idx)\n    end\n    for dest in 1:num_zones\n        for node in 1:net_data.num_nodes\n            terms = MOI.ScalarAffineTerm{Float64}[]\n            if haskey(outgoing, node)\n                for edge_idx in outgoing[node]\n                    push!(terms, MOI.ScalarAffineTerm(1.0, x[(dest-1)*num_edges + edge_idx]))\n                end\n            end\n            if haskey(incoming, node)\n                for edge_idx in incoming[node]\n                    push!(terms, MOI.ScalarAffineTerm(-1.0, x[(dest-1)*num_edges + edge_idx]))\n                end\n            end\n            if node == dest\n                rhs = -sum(net_data.travel_demand[:, dest])\n            elseif node <= num_zones\n                rhs = net_data.travel_demand[node, dest]\n            else\n                rhs = 0.0\n            end\n            MOI.add_constraint(optimizer,\n                             MOI.ScalarAffineFunction(terms, 0.0),\n                             MOI.EqualTo(rhs))\n        end\n    end\n    for edge_idx in 1:num_edges\n        terms = [MOI.ScalarAffineTerm(1.0, x_agg[edge_idx])]\n        for dest in 1:num_zones\n            push!(terms, MOI.ScalarAffineTerm(-1.0, x[(dest-1)*num_edges + edge_idx]))\n        end\n        MOI.add_constraint(optimizer,\n                         MOI.ScalarAffineFunction(terms, 0.0),\n                         MOI.EqualTo(0.0))\n    end\n    max_flow = 1.5 * sum(net_data.travel_demand)\n    for (y_idx, edge) in enumerate(removed_edges)\n        edge_idx = edge_dict[edge]\n        for dest in 1:num_zones\n            var_idx = (dest - 1) * num_edges + edge_idx\n            if use_big_m\n                terms = [\n                    MOI.ScalarAffineTerm(1.0, x[var_idx]),\n                    MOI.ScalarAffineTerm(-max_flow, y[y_idx])\n                ]\n                MOI.add_constraint(optimizer,\n                                 MOI.ScalarAffineFunction(terms, 0.0),\n                                 MOI.LessThan(0.0))\n            else\n                indicator_func = MOI.VectorAffineFunction(\n                    [\n                        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, y[y_idx])),\n                        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x[var_idx]))\n                    ],\n                    [0.0, 0.0]\n                )\n                MOI.add_constraint(optimizer, indicator_func,\n                                 MOI.Indicator{MOI.ACTIVATE_ON_ZERO}(MOI.EqualTo(0.0)))\n            end\n        end\n    end\n    return optimizer, edge_list\nend","category":"page"},{"location":"examples/docs-01-network-design/#Objective-Function-and-Gradient","page":"Network Design Problem","title":"Objective Function and Gradient","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR (Bureau of Public Roads) travel time function and gradient (for MOI-based LMO)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This function builds the objective function and gradient for the MOI-based approach. The objective function computes:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR travel time: t = t0 * (flow + b * flow^(power+1) / capacity^power / (power+1))\nDesign cost: sum of costperedge[i] * y[i] for each restored edge\nNo penalty terms needed - constraints are enforced by the MOI model","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The gradient function computes derivatives of the objective with respect to:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Aggregate flows: d/d(flow) of BPR function\nDesign variables: costperedge[i] for each restored edge","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Returns: (f, grad!) where f is the objective function and grad! is the gradient function","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function build_objective_and_gradient(net_data, removed_edges, cost_per_edge)\n    num_zones = net_data.num_zones\n    num_edges = net_data.num_edges\n    num_removed = length(removed_edges)\n    function f(x)\n        x = max.(x, 0.0)\n        total = 0.0\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            total += t0 * (flow + b * flow^(p + 1) / cap^p / (p + 1))\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            total += cost_per_edge[i] * x[design_start + i - 1]\n        end\n        return total\n    end\n    function grad!(storage, x)\n        x = max.(x, 0.0)\n        fill!(storage, 0.0)\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            storage[agg_start + i - 1] = t0 * (1 + b * flow^p / cap^p)\n        end\n        for dest in 1:num_zones\n            for edge in 1:num_edges\n                storage[(dest - 1) * num_edges + edge] = storage[agg_start + edge - 1]\n            end\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            storage[design_start + i - 1] = cost_per_edge[i]\n        end\n        return storage\n    end\n    return f, grad!\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR objective WITH penalty terms for linking constraints (for Custom LMO)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This function builds the objective function and gradient for the Custom LMO approach. Since the shortest-path oracle cannot enforce linking constraints x[dest,edge] <= M * y[edge] as hard constraints, we add penalty terms to the objective function to discourage violations.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The objective function computes:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR travel time: t = t0 * (flow + b * flow^(power+1) / capacity^power / (power+1))\nDesign cost: sum of costperedge[i] * y[i] for each restored edge\nPenalty terms: penaltyweight * sumi sumdest max(0, x[dest,removededgei] - M * y[i])^penaltyexponent","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The gradient function computes derivatives of the objective with respect to:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Aggregate flows: d/d(flow) of BPR function + penalty gradient w.r.t. flows\nDesign variables: costperedge[i] + penalty gradient w.r.t. design variables","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Parameters:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"penalty_weight: Weight of the penalty term (default: 1e6)\npenalty_exponent: Exponent for the penalty term (default: 2.0)\npenalty_exponent = 1: Linear penalty (L1)\npenalty_exponent = 2: Quadratic penalty (L2, most common)\npenalty_exponent > 2: Higher order penalties (stronger enforcement)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Returns: (f, grad!) where f is the objective function and grad! is the gradient function","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function build_objective_and_gradient_with_penalty(net_data, removed_edges, cost_per_edge,\n                                                    penalty_weight=1e6, penalty_exponent=2.0)\n    num_zones = net_data.num_zones\n    num_edges = net_data.num_edges\n    num_removed = length(removed_edges)\n    edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i]) for i in 1:num_edges]\n    removed_edge_indices = [findfirst(e -> e == removed_edge, edge_list)\n                            for removed_edge in removed_edges]\n    max_flow = 1.5 * sum(net_data.travel_demand)\n    function f(x)\n        x = max.(x, 0.0)\n        total = 0.0\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            total += t0 * (flow + b * flow^(p + 1) / cap^p / (p + 1))\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            total += cost_per_edge[i] * x[design_start + i - 1]\n        end\n        for (y_idx, edge_idx) in enumerate(removed_edge_indices)\n            if edge_idx !== nothing\n                y_val = x[design_start + y_idx - 1]\n                for dest in 1:num_zones\n                    flow_idx = (dest - 1) * num_edges + edge_idx\n                    flow_val = x[flow_idx]\n                    violation = max(0.0, flow_val - max_flow * y_val)\n                    total += penalty_weight * violation^penalty_exponent\n                end\n            end\n        end\n        return total\n    end\n    function grad!(storage, x)\n        x = max.(x, 0.0)\n        fill!(storage, 0.0)\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            storage[agg_start + i - 1] = t0 * (1 + b * flow^p / cap^p)\n        end\n        for dest in 1:num_zones\n            for edge in 1:num_edges\n                storage[(dest - 1) * num_edges + edge] = storage[agg_start + edge - 1]\n            end\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            storage[design_start + i - 1] = cost_per_edge[i]\n        end\n        for (y_idx, edge_idx) in enumerate(removed_edge_indices)\n            if edge_idx !== nothing\n                y_val = x[design_start + y_idx - 1]\n                for dest in 1:num_zones\n                    flow_idx = (dest - 1) * num_edges + edge_idx\n                    flow_val = x[flow_idx]\n                    violation = max(0.0, flow_val - max_flow * y_val)\n                    if violation > 1e-10\n                        grad_coeff = penalty_weight * penalty_exponent * violation^(penalty_exponent - 1)\n                        storage[flow_idx] += grad_coeff\n                        storage[design_start + y_idx - 1] += grad_coeff * (-max_flow)\n                    end\n                end\n            end\n        end\n        return storage\n    end\n    return f, grad!\nend","category":"page"},{"location":"examples/docs-01-network-design/#Helper-Functions-for-Results","page":"Network Design Problem","title":"Helper Functions for Results","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function print_solution(x, net_data, removed_edges, edge_list, method_name)\n    println(\"\\n\" * \"-\"^70)\n    println(\"Solution using $method_name\")\n    println(\"-\"^70)\n    num_zones = net_data.num_zones\n    num_edges = net_data.num_edges\n    num_removed = length(removed_edges)\n    function node_label(node)\n        if node == 1\n            return \"S1\"\n        elseif node == 2\n            return \"S2\"\n        elseif node == 3\n            return \"D\"\n        elseif node == 4\n            return \"1\"\n        elseif node == 5\n            return \"2\"\n        elseif node == 6\n            return \"3\"\n        elseif node == 7\n            return \"4\"\n        elseif node == 8\n            return \"5\"\n        else\n            return string(node)\n        end\n    end\n    design_start = num_zones * num_edges + num_edges + 1\n    design_vars = x[design_start:end]\n\n    println(\"\\nEdges to restore:\")\n    for (i, edge) in enumerate(removed_edges)\n        status = design_vars[i] > 0.5 ? \"RESTORE\" : \"KEEP CLOSED\"\n        from_label = node_label(edge[1])\n        to_label = node_label(edge[2])\n        println(\"  Edge ($from_label → $to_label): y = $(round(design_vars[i], digits=3)) → $status\")\n    end\n    agg_start = num_zones * num_edges + 1\n    println(\"\\nAggregate flows on edges:\")\n    for i in 1:num_edges\n        flow = x[agg_start + i - 1]\n        if flow > 1e-6\n            from_label = node_label(edge_list[i][1])\n            to_label = node_label(edge_list[i][2])\n            println(\"  Edge ($from_label → $to_label): flow = $(round(flow, digits=3))\")\n        end\n    end\nend","category":"page"},{"location":"examples/docs-01-network-design/#Example-Execution","page":"Network Design Problem","title":"Example Execution","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Load network","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"net_data = load_braess_network()\nprintln(\"\\nNetwork: Two-Source Network with Purchasable Edge\")\nprintln(\"  Nodes: $(net_data.num_nodes) (2 sources, 5 intermediate, 1 destination)\")\nprintln(\"  Edges: $(net_data.num_edges)\")\nprintln(\"  Sources: S1 (node 1), S2 (node 2)\")\nprintln(\"  Destination: D (node 3)\")\nprintln(\"  Intermediate nodes: 4, 5, 6, 7, 8\")\nprintln(\"  Demand: 1 unit from each source (2 units total)\")","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Define potentially purchasable edges (edges that need design decision)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"removed_edges = [(4, 5)]  # Optional edge from node_1 (intermediate node 4) to node_2 (intermediate node 5)\ncost_per_edge = [0.5]  # Cost to purchase the edge\n\nprintln(\"\\nPurchasable edges (need design decision): $removed_edges\")\nprintln(\"Cost to restore: $cost_per_edge\")","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Build edge list for display","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i])\n             for i in 1:net_data.num_edges]","category":"page"},{"location":"examples/docs-01-network-design/#Solve-with-MOI-based-LMO","page":"Network Design Problem","title":"Solve with MOI-based LMO","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"println(\"\\n\" * \"=\"^70)\nprintln(\"Solving with MOI-based LMO (MIP solver models feasible region)\")\nprintln(\"=\"^70)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Build MOI model","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"optimizer, _ = build_moi_model(net_data, removed_edges, true)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Create Boscia LMO from MOI model","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"lmo_moi = FrankWolfe.MathOptLMO(optimizer)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Build objective","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"f_moi, grad_moi! = build_objective_and_gradient(net_data, removed_edges, cost_per_edge)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Configure settings","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"settings_moi = Boscia.create_default_settings()\nsettings_moi.branch_and_bound[:verbose] = true","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Solve with Boscia","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"x_moi, _, result_moi = Boscia.solve(f_moi, grad_moi!, lmo_moi, settings=settings_moi)\n\nprint_solution(x_moi, net_data, removed_edges, edge_list, \"MOI-based LMO\")","category":"page"},{"location":"examples/docs-01-network-design/#Solve-with-Custom-LMO","page":"Network Design Problem","title":"Solve with Custom LMO","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"println(\"\\n\" * \"=\"^70)\nprintln(\"Solving with Custom LMO (shortest path oracle)\")\npenalty_weight = 1e3\npenalty_exponent = 1.5\nprintln(\"Penalty weight: $penalty_weight, Penalty exponent: $penalty_exponent\")\nprintln(\"=\"^70)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Build graph","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"graph = Graphs.SimpleDiGraph(net_data.num_nodes)\nedge_list_custom = Tuple{Int,Int}[]\nfor i in 1:net_data.num_edges\n    Graphs.add_edge!(graph, net_data.init_nodes[i], net_data.term_nodes[i])\n    push!(edge_list_custom, (net_data.init_nodes[i], net_data.term_nodes[i]))\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Build sparse link dictionary","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"link_dic = sparse(net_data.init_nodes, net_data.term_nodes,\n                 collect(1:net_data.num_edges))","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Create custom LMO for continuous variables","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"custom_lmo = ShortestPathLMO(graph, net_data, link_dic, edge_list_custom)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Set up integer bounds for Boscia","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"num_zones = net_data.num_zones\nnum_edges = net_data.num_edges\nnum_removed = length(removed_edges)\ntotal_vars = num_zones * num_edges + num_edges + num_removed","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Binary variables for network design (last num_removed variables)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"int_vars = collect((num_zones * num_edges + num_edges + 1):total_vars)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Create bounds vectors for integer variables","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"lower_bounds = zeros(Float64, num_removed)  # Binary: lower bound = 0\nupper_bounds = ones(Float64, num_removed)   # Binary: upper bound = 1","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Wrap LMO with integer handling","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"bounded_lmo = Boscia.ManagedLMO(custom_lmo, lower_bounds, upper_bounds, int_vars, total_vars)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Build objective WITH PENALTY TERMS for linking constraints","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"f_custom, grad_custom! = build_objective_and_gradient_with_penalty(net_data, removed_edges, cost_per_edge,\n                                                      penalty_weight, penalty_exponent)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Configure settings","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"settings_custom = Boscia.create_default_settings()\nsettings_custom.branch_and_bound[:verbose] = true","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Solve with Boscia","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"x_custom, _, result_custom = Boscia.solve(f_custom, grad_custom!, bounded_lmo, settings=settings_custom)\n\nprint_solution(x_custom, net_data, removed_edges, edge_list, \"Custom Shortest-Path LMO\")","category":"page"},{"location":"examples/docs-01-network-design/#Comparison-of-Results","page":"Network Design Problem","title":"Comparison of Results","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"println(\"\\n\" * \"=\"^70)\nprintln(\"Comparison of Results\")\nprintln(\"=\"^70)\nprintln(\"MOI-based LMO (Hard Constraints):\")\nprintln(\"  Objective: $(result_moi[:primal_objective])\")\nprintln(\"  Time: $(result_moi[:total_time_in_sec]) seconds\")\nprintln(\"  Formulation: min BPR_cost(x) + restoration_cost(y)\")\nprintln(\"               s.t. x[e] <= M*y[e] (hard constraints)\")\n\nprintln(\"\\nCustom LMO (Penalty Method):\")\nprintln(\"  Objective: $(result_custom[:primal_objective])\")\nprintln(\"  Time: $(result_custom[:total_time_in_sec]) seconds\")\nprintln(\"  Formulation: min BPR_cost(x) + restoration_cost(y) + penalties\")\nprintln(\"               (penalties for violating x[e] <= M*y[e])\")\n\nprintln(\"\\n\" * \"-\"^70)\nprintln(\"IMPORTANT: These are DIFFERENT objective functions!\")\nprintln(\"The Custom LMO uses a penalized formulation because the shortest-path\")\nprintln(\"oracle cannot enforce the linking constraints x[e] <= M*y[e] directly.\")\nprintln(\"Different formulations → different solutions → different objectives.\")\nprintln(\"=\"^70)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs-03-optimal-design/#Optimal-Design-of-Experiments","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"This example shows the A-Optimal and D-Optimal Design of Experiments problems. To quantify information, we use the Fisher information matrix:","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"X(x) = A * textdiag(x) * A","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"where each row of A corresponds to an experiment. For the D-criterion, the objective is the negative log determinant of the Fisher information matrix. The objective associated with the A-criterion is the trace of the inverse of the Fisher information matrix.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"using Boscia\nusing Random\nusing Distributions\nusing LinearAlgebra\nusing FrankWolfe\nusing Statistics\nusing Test\nusing StableRNGs\n\nprintln(\"\\nDocumentation Example 03: Optimal Design of Experiments\")\n\nseed = rand(UInt64)\n@show seed  #seed = 0x7be8a16f815cd122\nrng = StableRNG(seed)","category":"page"},{"location":"examples/docs-03-optimal-design/#Experiment-matrix-and-objectives","page":"Optimal Design of Experiments","title":"Experiment matrix and objectives","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"We generate the experiment matrix A randomly.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"m = 50\nn = Int(floor(m / 10))\nN = round(Int, 1.5 * n)\n\nB = rand(rng, m, n)\nB = B' * B\n@assert isposdef(B)\nconst D = MvNormal(randn(rng, n), B)\n\nconst A = rand(D, m)'\n@assert rank(A) == n","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Next, we define the two criteria and their gradients. The A-criterion is::","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"f_a(x) = textTrleft(X(x)^-1right)","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"μ = 1e-4\nfunction f_a(x)\n    X = transpose(A) * diagm(x) * A + Matrix(μ * I, n, n)\n    X = Symmetric(X)\n    U = cholesky(X)\n    X_inv = U \\ I\n    return LinearAlgebra.tr(X_inv)\nend\n\nfunction grad_a!(storage, x)\n    X = transpose(A) * diagm(x) * A + Matrix(μ * I, n, n)\n    X = Symmetric(X * X)\n    F = cholesky(X)\n    for i in 1:length(x)\n        storage[i] = LinearAlgebra.tr(-(F \\ A[i, :]) * transpose(A[i, :]))\n    end\n    return storage\nend","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"The D-criterion is:","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"f_d(x) = -log(det(X(x)))","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function f_d(x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X)\n    return float(-log(det(X)))\nend\n\nfunction grad_d!(storage, x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X)\n    F = cholesky(X)\n    for i in 1:length(x)\n        storage[i] = LinearAlgebra.tr(-(F \\ A[i, :]) * transpose(A[i, :]))\n    end\n    return storage\nend","category":"page"},{"location":"examples/docs-03-optimal-design/#Domain-Issues","page":"Optimal Design of Experiments","title":"Domain Issues","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"The feasible region is a scaled and truncated probability simplex.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"S = x in mathbbR^n 0 leq x leq u sum_i=1^n x_i = N","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"where N is the budget for the experiments and u are upper bounds.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"ub = floor(N/3)\nu = rand(rng, 1.0:ub, m)\nsimplex_lmo = Boscia.ProbabilitySimplexLMO(N)\nlmo = Boscia.ManagedLMO(simplex_lmo, fill(0.0, m), u, collect(1:m), m)","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"An issue arising from this is that the feasible region and the domain of the objectives don't completely overlap. Thus, we cannot start Boscia and by extension Frank-Wolfe at a random start point. Also, during the line search, we have to be careful to pick a step size that does not lead to the iterate leaving the domain. To address this problem, we first need to define a domain oracle tht given a point x returns true if x is feasible. There are different ways to check domain feasibility, here we chose to test if the activated rows of A are linearly independent and span the mathbbR^n.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function domain_oracle(x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X)\n    return LinearAlgebra.isposdef(X)\nend","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Even if we start Boscia with a domain feasible point, we might end up with domain infeasible points later in the tree. Observe that the vertices in the active set are not necessarily domain feasible. Therefore, while branching, we can have initial points that are not domain feasible. To address this, we need to define a domain point function that given the current node bounds returns a domain feasible point respecting the bounds, if possible. Find n linearly independent rows of A to build the starting point.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function linearly_independent_rows(A; u=fill(1, size(A, 1)))\nS = []\nm, n = size(A)\nfor i in 1:m\n    if iszero(u[i])\n        continue\n    end\n    S_i = vcat(S, i)\n    if rank(A[S_i, :]) == length(S_i)\n        S = S_i\n    end\n    if length(S) == n # we only n linearly independent points\n        return S\n    end\nend\nreturn S # then x= zeros(m) and x[S] = 1\nend","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Add to the smallest value of x while respecting the upper bounds u.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function add_to_min(x, u)\nperm = sortperm(x)\nfor i in perm\n    if x[i] < u[i]\n        x[i] += 1\n        break\n    end\nend\nreturn x\nend\nfunction domain_point(local_bounds)\n    lb = fill(0.0, m)\n    ub = copy(u)\n    x = zeros(m)\n    for idx in 1:m\n        if haskey(local_bounds.lower_bounds, idx)\n            lb[idx] = max(0.0, local_bounds.lower_bounds[idx])\n        end\n        if haskey(local_bounds.upper_bounds, idx)\n            ub[idx] = min(u[idx], local_bounds.upper_bounds[idx])\n        end\n    end\n    if sum(lb) > N\n        return nothing\n    end\n    if !domain_oracle(ub)\n        return nothing\n    end\n    x = lb\n    S = linearly_independent_rows(A, u=(.!(iszero.(ub))))\n        while sum(x) <= N\n            if sum(x) == N\n                if domain_oracle(x)\n                    return x\n                else\n                    @warn \"Domain feasible point not found.\"\n                    return nothing\n                end\n            end\n            if !iszero(x[S] - ub[S])\n                y = add_to_min(x[S], ub[S])\n                x[S] = y\n            else\n                x = add_to_min(x, ub)\n            end\n        end\n    return x\nend","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Note that the domain point function does not necessarily have to return an integer point. The generated point is used to solve a min distance problem over the feasible region to move the current iterate closer to the domain. To that end, the domain point should not be at the boundary of the domain as this can lead to numerical issues later in the node solve.","category":"page"},{"location":"examples/docs-03-optimal-design/#Build-initial-start-point","page":"Optimal Design of Experiments","title":"Build initial start point","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"We can use the same principal to generate an initial start point for Boscia. Note that Boscia expects the initial point to be given via an active set.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"intial_bounds = Boscia.IntegerBounds(fill(0.0, m), u, collect(1:m))\nx0 = domain_point(intial_bounds)\nf_help(x) = 1 / 2 * LinearAlgebra.norm(x - x0)^2\ngrad_help!(storage, x) = storage .= x - x0\nv0 = compute_extreme_point(lmo, collect(1.0:m))","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"We do not need to solve this problem to optimality. However, we do not want to stop as soon as we reach the domain because this can lead to numerical issues later in the node solve. Therefore, we count the iteration after entering the domain and stop if we have not found a feasible point after 5 iterations.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function build_inner_callback()\n    domain_counter = 0\n    return function inner_callback(state, active_set, kwargs...)\n        if domain_oracle(state.x)\n            if domain_counter > 10\n                return false\n            end\n            domain_counter += 1\n        end\n    end\nend\n\ninner_callback = build_inner_callback()\n\nx, _, _, _, _, _, active_set = FrankWolfe.blended_pairwise_conditional_gradient(\n    f_help,\n    grad_help!,\n    lmo,\n    v0,\n    callback=inner_callback,\n    lazy=true,\n)\n\n@show N, u","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Now we can use Boscia to solve the problem. As line search, we use the Secant method which receives the domain oracle as input. We also set some heuristics to be used during the node solve by specifying a probability for each heuristic.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"settings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = false\nsettings.branch_and_bound[:time_limit] = 10.0\nsettings.domain[:active_set] = copy(active_set) # this will be overwritten by Boscia during the solve\nsettings.domain[:domain_oracle] = domain_oracle\nsettings.domain[:find_domain_point] = domain_point\nsettings.domain[:depth_domain] = 10\nsettings.heuristic[:hyperplane_aware_rounding_prob] = 0.7\nsettings.heuristic[:rounding_lmo_01_prob] = 0.5\nsettings.frank_wolfe[:line_search] = FrankWolfe.Secant(domain_oracle=domain_oracle)\nsettings.frank_wolfe[:lazy] = true","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"First, we are calling the algorithm for a few seconds for precompilation.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"x_a, _, _ = Boscia.solve(f_a, grad_a!, lmo, settings=settings)\n\nsettings.branch_and_bound[:verbose] = true\nsettings.branch_and_bound[:time_limit] = Inf\nsettings.domain[:active_set] = copy(active_set) # this will be overwritten by Boscia during the solve\n\nx_a, _, result_a = Boscia.solve(f_a, grad_a!, lmo, settings=settings)\n\nsettings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = false\nsettings.branch_and_bound[:time_limit] = 10.0\nsettings.domain[:active_set] = copy(active_set) # this will be overwritten by Boscia during the solve\nsettings.domain[:domain_oracle] = domain_oracle\nsettings.domain[:find_domain_point] = domain_point\nsettings.domain[:depth_domain] = 10\nsettings.heuristic[:hyperplane_aware_rounding_prob] = 0.7\nsettings.heuristic[:rounding_lmo_01_prob] = 0.5\nsettings.frank_wolfe[:line_search] = FrankWolfe.Secant(domain_oracle=domain_oracle)\nsettings.frank_wolfe[:lazy] = true\n\nx_d, _, _ = Boscia.solve(f_d, grad_d!, lmo, settings=settings)\n\nsettings.branch_and_bound[:verbose] = true\nsettings.branch_and_bound[:time_limit] = Inf\nsettings.domain[:active_set] = copy(active_set) # this will be overwritten by Boscia during the solve\n\nx_d, _, result_d = Boscia.solve(f_d, grad_d!, lmo, settings=settings)","category":"page"},{"location":"examples/docs-03-optimal-design/#Plotting-the-progress","page":"Optimal Design of Experiments","title":"Plotting the progress","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"using PyPlot","category":"page"},{"location":"examples/docs-03-optimal-design/#Load-plotting-utilities","page":"Optimal Design of Experiments","title":"Load plotting utilities","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"include(\"plot_utilities.jl\")","category":"page"},{"location":"examples/docs-03-optimal-design/#Create-plots-for-A-criterion-(if-solved)","page":"Optimal Design of Experiments","title":"Create plots for A-criterion (if solved)","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"if @isdefined(resulta)     filenamea = \"oedAcriterionmmseedseed.pdf\"     figa = plotboundsprogress(         resulta,         filenamea,         titleprefix=\"A-Criterion\",         uselatex=true,         fontsize=11,         linewidth=2,     )     display(figa) end","category":"page"},{"location":"examples/docs-03-optimal-design/#Create-plots-for-D-criterion","page":"Optimal Design of Experiments","title":"Create plots for D-criterion","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"filenamed = \"oedDcriterionm(m)_seed_(seed).pdf\" figd = plotboundsprogress(     resultd,     filenamed,     titleprefix=\"D-Criterion\",     uselatex=true,     fontsize=11,     linewidth=2, ) display(fig_d)","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"This section contain some utility function ","category":"page"},{"location":"reference/utilities/#Bonobo.terminated-Tuple{Bonobo.BnBTree{var\"#s1029\", Root, Value, Solution} where {var\"#s1029\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s1029\", Value}}}","page":"Utilities","title":"Bonobo.terminated","text":"Checks if the branch and bound can be stopped. By default (in Bonobo) stops then the priority queue is empty. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.build_active_set_by_domain_oracle-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Boscia.IntegerBounds, Any}} where {T, R}","page":"Utilities","title":"Boscia.build_active_set_by_domain_oracle","text":"Build a new start point and active set in case the split active set does not lead to a domain feasible iterate. First, try filtering the active set by the domain oracle. If all vertices are domain infeasible, solve the projection problem 1/2 * ||x - x||_2^2  where x is a domain- and bound-feasible point provided by the user.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.check_feasibility-Tuple{Boscia.TimeTrackingLMO}","page":"Utilities","title":"Boscia.check_feasibility","text":"Check feasibility and boundedness\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.has_integer_constraint-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.has_integer_constraint","text":"Check if at a given index we have an integer constraint respectivily.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_bound_feasible-Tuple{Boscia.IntegerBounds, Any}","page":"Utilities","title":"Boscia.is_bound_feasible","text":"Check if a given point v satisfies the given bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.is_valid_split","text":"Check wether a split is valid. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.min_via_enum","page":"Utilities","title":"Boscia.min_via_enum","text":"Naive optimization by enumeration. Default uses binary values. Otherwise, third argument should be a vector of n sets of possible values for the variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Boscia.relative_gap-Tuple{Any, Any}","page":"Utilities","title":"Boscia.relative_gap","text":"Compute relative gap consistently everywhere\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.restart_active_set-Tuple{Boscia.FrankWolfeNode, LinearMinimizationOracle, Int64}","page":"Utilities","title":"Boscia.restart_active_set","text":"Call this if the active set is empty after splitting. Remark: This should not happen when using a MIP solver for the nodes!\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Int64, Boscia.IntegerBounds}} where {T, R}","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split an active set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{T}, Tuple{FrankWolfe.DeletedVertexStorage{T}, Any, Int64, Any, Boscia.IntegerBounds}} where T","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split a discarded vertices set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.trivial_build_dicg_start_point-Tuple{LinearMinimizationOracle}","page":"Utilities","title":"Boscia.trivial_build_dicg_start_point","text":"Default starting point function which generates a random vertex\n\n\n\n\n\n","category":"method"},{"location":"#Boscia.jl","page":"Home","title":"Boscia.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Dev) (Image: Stable) (Image: Coverage) (Image: DOI) (Image: Aqua QA)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A solver for Mixed-Integer Convex Optimization that uses Frank-Wolfe methods for convex relaxations and a branch-and-bound algorithm.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Boscia.jl solver combines (a variant of) the Frank-Wolfe algorithm with a branch-and-bound-like algorithm to solve mixed-integer convex optimization problems of the form min_x  C x_I  mathbbZ^n f(x), where f is a differentiable convex function, C is a convex and compact set, and I is a set of indices of integral variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approach is especially effective when we have a method to optimize a linear function over C and the integrality constraints in a computationally efficient way. The set C can modelled using the Julia package MathOptInterface (or JuMP).  We also implemented simple polytopes like the hypercube, the unit simplex and the probability simplex. Also, we intend to extend this list by combinatorial polytopes, e.g. the matching polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The paper presenting the package with mathematical explanations and numerous examples can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convex mixed-integer optimization with Frank-Wolfe methods: 2208.11010","category":"page"},{"location":"","page":"Home","title":"Home","text":"Boscia.jl uses FrankWolfe.jl for solving the convex subproblems, Bonobo.jl for managing the search tree, and oracles optimizing linear functions over the feasible set, for instance calling SCIP or any MOI-compatible solver to solve MIP subproblems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add the Boscia stable release with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Boscia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or get the latest master branch with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/ZIB-IOL/Boscia.jl\", rev=\"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the installation of SCIP.jl, see here. Note, for Windows users, you do not need to download the SCIP binaries, you can also use the installer provided by SCIP.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example to get started. For more examples, see the examples folder in the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Boscia\nusing FrankWolfe\nusing Random\nusing SCIP\nusing LinearAlgebra\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nn = 6\n\nconst diffw = 0.5 * ones(n)\no = SCIP.Optimizer()\n\nMOI.set(o, MOI.Silent(), true)\n\nx = MOI.add_variables(o, n)\n\nfor xi in x\n    MOI.add_constraint(o, xi, MOI.GreaterThan(0.0))\n    MOI.add_constraint(o, xi, MOI.LessThan(1.0))\n    MOI.add_constraint(o, xi, MOI.ZeroOne())\nend\n\nlmo = FrankWolfe.MathOptLMO(o)\n\nfunction f(x)\n    return sum(0.5*(x.-diffw).^2)\nend\n\nfunction grad!(storage, x)\n    @. storage = x-diffw\nend\n\nsettings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = true\nx, _, result = Boscia.solve(f, grad!, lmo, settings=settings)\n\nBoscia Algorithm.\n\nParameter settings.\n\t Tree traversal strategy: Move best bound\n\t Branching strategy: Most infeasible\n\t FrankWolfe variant: Blended Pairwise Conditional Gradient\n\t Line Search Method: Secant\n\t Lazification: true\n\t Lazification Tolerance: 2\n\t Absolute dual gap tolerance: 1.000000e-06\n\t Relative dual gap tolerance: 1.000000e-02\n\t Frank-Wolfe subproblem tolerance: 1.000000e-02\n\t Frank-Wolfe dual gap decay factor: 8.000000e-01\n\t Additional kwargs: \n\t Total number of variables: 6\n\t Number of integer variables: 6\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n   Iter  Open          Bound      Incumbent      Gap (abs)      Gap (rel)       Time (s)      Nodes/sec      FW (ms)   LMO (ms)  LMO (calls c)   FW (its) #activeset  #shadow\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n*     1     2   0.000000e+00   7.500000e-01   7.500000e-01            Inf   2.000000e-03   1.500000e+03            1          1              4          2        1        0\n    100    27   6.250000e-01   7.500000e-01   1.250000e-01   2.000000e-01   6.400000e-02   1.984375e+03            0          0            326          0        1        0\n    127     0   7.500000e-01   7.500000e-01   0.000000e+00   0.000000e+00   7.300000e-02   1.739726e+03            0          0            380          0        1        0\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nSolution Statistics.\n\t Solution Status: Optimal (tree empty)\n\t Primal Objective: 0.75\n\t Dual Bound: 0.75\n\t Dual Gap (relative): 0.0\n\nSearch Statistics.\n\t Total number of nodes processed: 127\n\t Total number of lmo calls: 380\n\t Total time (s): 0.074\n\t LMO calls / sec: 5135.135135135135\n\t Nodes / sec: 1716.2162162162163\n\t LMO calls / node: 2.9921259842519685\n\n\t Total number of global tightenings: 0\n\t Global tightenings / node: 0.0\n\t Total number of local tightenings: 0\n\t Local tightenings / node: 0.0\n\t Total number of potential local tightenings: 0","category":"page"}]
}
