var documenterSearchIndex = {"docs":
[{"location":"reference/fw_variant/#Frank-Wolfe-Variants","page":"Frank-Wolfe Variants","title":"Frank-Wolfe Variants","text":"","category":"section"},{"location":"reference/fw_variant/","page":"Frank-Wolfe Variants","title":"Frank-Wolfe Variants","text":"Here is the list with the currently supported Frank-Wolfe variants.","category":"page"},{"location":"reference/fw_variant/#Boscia.AwayFrankWolfe","page":"Frank-Wolfe Variants","title":"Boscia.AwayFrankWolfe","text":"Away-Frank-Wolfe\n\nIn every iteration, it computes the worst performing vertex, called away vertex, in the active set with regard to the gradient. If enough local progress can be made, weight is shifted from the away vertex to all other vertices. \n\nIn case lazification is activated, the FW vertex is only computed if not enough local progress can be guaranteed.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.BlendedConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.BlendedConditionalGradient","text":"Blended Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.BlendedPairwiseConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.BlendedPairwiseConditionalGradient","text":"Blended Pairwise Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.DecompositionInvariantConditionalGradient","page":"Frank-Wolfe Variants","title":"Boscia.DecompositionInvariantConditionalGradient","text":"DICG-Frank-Wolfe\n\nThe Decomposition-invariant Frank-Wolfe. \n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.FrankWolfeVariant","page":"Frank-Wolfe Variants","title":"Boscia.FrankWolfeVariant","text":"Frank-Wolfe variant used to compute the problems at node level. A FrankWolfeVariant must implement\n\nsolve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\n\tadded_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace))\n\nIt may also implement build_frank_wolfe_workspace(x) which creates a workspace structure that is passed as last argument to solve_frank_wolfe.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.StandardFrankWolfe","page":"Frank-Wolfe Variants","title":"Boscia.StandardFrankWolfe","text":"Vanilla-Frank-Wolfe\n\nThe standard variant of Frank-Wolfe. In each iteration, the vertex v minimizing ∇f * (x-v) is computed. \n\nLazification cannot be used in this setting.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.solve_frank_wolfe","page":"Frank-Wolfe Variants","title":"Boscia.solve_frank_wolfe","text":"solve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\nadded_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace)\n\nReturns the optimal solution x to the node problem, its primal and dual gap and the active set. \n\n\n\n\n\n","category":"function"},{"location":"basics/#How-does-it-work?","page":"How does it work?","title":"How does it work?","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Boscia.jl is aimed at mixed-integer convex problems where the nonlinearity stems mostly from the objective function:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nmin    f(x)  \ntextst   xin C  x_I in mathbbZ^I\nendaligned text where  x in X subset mathbbR  x_I in mathbbZ^I","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where C is a compact, nonconvex set admitting a boundable linear minimization oracle (BLMO), i.e., a set over which optimizing a linear function can be done efficiently (comparatively to the original problem), even when bounds are added or modified.  Taking lower bounds l and upper bounds u, the oracle solves","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nv in argmin   langle x d rangle \ntextst   xin C \n  x_I in mathbbZ^I cap lu   text where  x in X subset mathbbR  x_I in mathbbZ^I\nendaligned","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where d will usually be the gradient of f evaluated at a given point x_t, nabla f(x_t).","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The new algorithmic framework is a branch-and-bound approach utilizing Frank-Wolfe (FW), also called Conditional Gradient (CG), methods as the node solver. A new aspect is that we solve the continuous sub problems in the nodes over the integer hull, i.e. the convex hull of the integer feasible points. Additionally, we exploit both general properties of the FW methods as well as the recent developments in the field of FW methods to speed up the solution process. ","category":"page"},{"location":"basics/#Frank-Wolfe-variants","page":"How does it work?","title":"Frank-Wolfe variants","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Frank-Wolfe algorithms used in Boscia.jl are implemented in FrankWolfe.jl.  The variants currently available in Boscia.jl are Vanilla Frank-Wolfe, Away-Frank-Wolfe (AFW), Blended Conditional Gradient (BCG) and Blended Pairwise Conditional Gradient (BPCG). The latter is set as the default variant.","category":"page"},{"location":"basics/#Branch-and-Bound-techniques","page":"How does it work?","title":"Branch-and-Bound techniques","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In this section, we present the techniques derived from Frank Wolfe that can be used in our framework .","category":"page"},{"location":"basics/#Dual-gap-based-termination","page":"How does it work?","title":"Dual gap based termination","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Frank-Wolfe methods produce primal feasible iterates and an FW gap, offering many inexpensive iterations with a gradually increasing dual bound.  This allows early termination of nodes when the dual bound reaches the best incumbent's objective value, avoiding unnecessary computations.  Nodes can be stopped anytime to produce a useful dual bound, aiding overall progress.  This flexibility contrasts with other nonlinear solvers, enabling more efficient optimization.","category":"page"},{"location":"basics/#Tree-state-dependent-termination-and-evolving-error","page":"How does it work?","title":"Tree state-dependent termination and evolving error","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"We implement different termination criteria in the node processing to reduce iterations, prioritizing nodes with promising lower bounds.  The dual bound provided by Frank-Wolfe is always valid, even if the dual gap is large. Thus, we solve nodes high in the tree, like the root node, with a coarse precision  and increase the precision with which a node is solved depending on its depth in the tree.  This approach balances efficiency and accuracy in solving optimization problems.","category":"page"},{"location":"basics/#Warm-starting-via-the-active-set","page":"How does it work?","title":"Warm-starting via the active set","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Many Frank-Wolfe variants provide a so-called active set, the convex combination of vertices representing the solution.  This can be used to warm start the children nodes by partitioning the active set of the parent.","category":"page"},{"location":"basics/#Branching","page":"How does it work?","title":"Branching","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"As default, we use most-infeasible branching which has shown good performance for many problems. Also, implemented are strong branching and the so-called hybrid branching which performs strong branching until a specific depth and afterwards switches to most-infeasible. It should be noted that strong branching is only adviseable for problems with very cheap LMO.  Otherwise, most-infeasible or hybrid branching with a shallow depth is to be preferred.","category":"page"},{"location":"basics/#Dual-fixing-and-tightening","page":"How does it work?","title":"Dual fixing and tightening","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In subproblems where variables are at bounds, our approach utilizes convexity and primal solutions to tighten dual bounds effectively.  Drawing from methods pioneered by Dantzig and extended in various contexts, we leverage Frank-Wolfe methods and FW gaps, adaptable to scenarios without explicit dual solutions, such as those involving MIP-based LMOs. We can also exploit strong convexity and sharpness to tighten the lowerbound of the tree.","category":"page"},{"location":"basics/#The-Bounded-Linear-Minimization-Oracles-(BLMO)","page":"How does it work?","title":"The Bounded Linear Minimization Oracles (BLMO)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Bounded Linear Minimization Oracle (BLMO) represent the feasible region C with the integrality constraints and handles the computation of mixed-integer linear sub-problems.  The bound management is also handled by the BLMO.  There are two options for the BLMO.","category":"page"},{"location":"basics/#Mixed-Integer-Linear-Solver-via-JuMP","page":"How does it work?","title":"Mixed Integer Linear Solver via JuMP","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The first option is a MIP solver like SCIP via the MathOptInterface or JuMP package.  For examples, see the Poisson Regression in poisson_reg.jl, the Sparse Regression with a grouped lasso in lasso.jl. In mps-example.jl, the feasible region is encoded in an MPS file.","category":"page"},{"location":"basics/#Customized-BLMO's","page":"How does it work?","title":"Customized BLMO's","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In addition, we have implemented some specific BLMOs like the hypercube, the probability and unit simplex. For examples, see approx_planted_point.jl.  In cube_blmo.jl, there is an example on how to implement Boscia's BLMO interface from scratch.","category":"page"},{"location":"reference/2_blmo_build/#The-Bounded-Linear-Minimization-Oracle-(BLMO)","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"The Bounded Linear Minimization Oracle (BLMO) is an oracle solving the problem","category":"page"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"beginaligned\nv in argmin   langle x d rangle \ntextst   xin C \n  x_I in mathbbZ^I cap lu   text where  x in X subset mathbbR  x_I in mathbbZ^I\nendaligned","category":"page"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"where the direction d is usually the gradient evaluated at a certain point. The bounds are specified at the node level and correspond to bounds obtained by branching.","category":"page"},{"location":"reference/2_blmo_build/#General-BLMO-Interface","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"General BLMO Interface","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"In the following, the functions for the general BLMO interface are listed. Functions without signature needs to be implemented by a new BLMO type. Functions with signature are optional and are usually for statistics and additional safety checks.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.BoundedLinearMinimizationOracle","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.BoundedLinearMinimizationOracle","text":"BLMO\n\nSupertype for the Bounded Linear Minimization Oracles,\n\nWILL BE DEPRECATED in favor of simply extending the FrankWolfe.LinearMinimizationOracle type.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.LMOStatus","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.LMOStatus","text":"Enum encoding the status of the Linear Minimization Oracle. Currently available: OPTIMAL, INFEASIBLE and UNBOUNDED.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.add_bound_constraint!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.add_bound_constraint!","text":"Add bound constraint.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.build_LMO_correct-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO_correct","text":"build_LMO_correct(lmo::LinearMinimizationOracle, node_bounds)\n\nCheck if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_global_bounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_global_bounds","text":"Read global bounds from the problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.check_feasibility-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_feasibility","text":"check_feasibility(lmo::LinearMinimizationOracle)\n\nCheck if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_infeasible_vertex-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_infeasible_vertex","text":"check_infeasible_vertex(lmo::LinearMinimizationOracle, tree)\n\nDeal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.delete_bounds!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.delete_bounds!","text":"Delete bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, LinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"find_best_solution(f::Function, lmo::LinearMinimizationOracle, vars, domain_oracle)\n\nFind best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.free_model-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.free_model","text":"free_model(lmo::LinearMinimizationOracle)\n\nFree model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_LMO_solve_data-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_LMO_solve_data","text":"get_LMO_solve_data(lmo::LinearMinimizationOracle)\n\nGet solve time, number of nodes and number of iterations, if applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_bound","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_bound","text":"Read bound value for c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_int_var","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_int_var","text":"Get the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_integer_variables","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_integer_variables","text":"Get list of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_list_of_variables","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_list_of_variables","text":"Get list of variables indices.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_lower_bound_list","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_lower_bound_list","text":"Get the list of lower bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_tol-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_tol","text":"get_tol(lmo::LinearMinimizationOracle)\n\nGet solving tolerance for the LMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_upper_bound_list","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_upper_bound_list","text":"Get the list of upper bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.get_variables_pointers-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_variables_pointers","text":"get_variables_pointers(lmo::LinearMinimizationOracle, tree)\n\nList of all variable pointers. Depends on how you save your variables internally. In the easy case, this is simply collect(1:N). Is used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_integer_constraint","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_integer_constraint","text":"Has variable an integer constraint?\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.indicator_present-Tuple{LinearMinimizationOracle}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.indicator_present","text":"indicator_present(lmo::LinearMinimizationOracle)\n\nAre indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_bound_in","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_bound_in","text":"To check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_constraint_on_int_var","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_constraint_on_int_var","text":"Check if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_indicator_feasible-Tuple{LinearMinimizationOracle, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_indicator_feasible","text":"is_indicator_feasible(lmo::LinearMinimizationOracle, v; atol=1e-6, rtol=1e-6)\n\nIs a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_linear_feasible","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_linear_feasible","text":"Is a given point v linear feasible for the model? That means does v satisfy all bounds and other linear constraints?\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, LinearMinimizationOracle, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_valid_split","text":"is_valid_split(tree::Bonobo.BnBTree, lmo::LinearMinimizationOracle, vidx::Int)\n\nCheck whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.set_bound!","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.set_bound!","text":"Change the value of the bound c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#MathOptInterface-(MOI)-BLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"MathOptInterface (MOI) BLMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"With this BLMO type, any (MIP) solver that provides an interface to MathOptInterface and JuMP can be used in Boscia. Note that we only require the feasible region, i.e. no objective has to be set.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.MathOptBLMO-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.MathOptBLMO","text":"MathOptBLMO(lmo::FrankWolfe.MathOptLMO)\n\nBuild an instance of MathOptBLMO from a FrankWolfe.MathOptLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Base.convert-Tuple{Type{Boscia.MathOptBLMO}, FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Base.convert","text":"Convert object of Type FrankWolfe.MathOptLMO into Boscia.MathOptBLMO and viceversa.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Bonobo.get_branching_variable-Union{Tuple{OT}, Tuple{Bonobo.BnBTree, Boscia.PartialStrongBranching{FrankWolfe.MathOptLMO{OT}}, Bonobo.AbstractNode}} where OT<:MathOptInterface.AbstractOptimizer","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Bonobo.get_branching_variable","text":"Bonobo.get_branching_variable(tree::Bonobo.BnBTree, branching::PartialStrongBranching{MathOptBLMO{OT}}, node::Bonobo.AbstractNode,) where {OT<:MOI.AbstractOptimizer}\n\nBehavior for strong branching.  Note that in constrast to the ManagedBLMO type, we filter out the integer and binary constraints as solving general MIP in strong branching would be very expensive.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.add_bound_constraint!-Tuple{FrankWolfe.MathOptLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.add_bound_constraint!","text":"add_bound_constraint!(blmo::MathOptBLMO, key, value, sense::Symbol)\n\nAdd bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_LMO_correct-Tuple{Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO_correct","text":"build_LMO_correct(blmo, node_bounds)\n\nCheck if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_global_bounds-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_global_bounds","text":"build_global_bounds(blmo::MathOptBLMO, integer_variables)\n\nRead global bounds from the problem\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_feasibility-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_feasibility","text":"check_feasibility(blmo::MathOptBLMO)\n\nCheck if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_infeasible_vertex-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_infeasible_vertex","text":" check_infeasible_vertex(lmo::FrankWolfe.MathOptLMO, tree)\n\nDeal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.delete_bounds!-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.delete_bounds!","text":"delete_bounds!(blmo::MathOptBLMO, cons_delete)\n\nDelete bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.explicit_bounds_binary_var-Tuple{FrankWolfe.MathOptLMO, Boscia.IntegerBounds}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.explicit_bounds_binary_var","text":"explicit_bounds_binary_var(blmo::MathOptBLMO, global_bounds::IntegerBounds)\n\nAdd explicit bounds for binary variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, FrankWolfe.MathOptLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"find_best_solution(f::Function, lmo::FrankWolfe.MathOptLMO, vars, domain_oracle)\n\nFind best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Bonobo.BnBTree, Function, MathOptInterface.AbstractOptimizer, Vector{MathOptInterface.VariableIndex}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":" function find_best_solution(f::Function, o::MOI.AbstractOptimizer, vars::Vector{MOI.VariableIndex}, domain_oracle,)\n\nFinds the best solution in the Optimizer's solution storage, based on the objective function f. Returns the solution vector and the corresponding best value.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.free_model-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.free_model","text":" free_model(blmo::MathOptBLMO)\n\nFree model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_LMO_solve_data-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_LMO_solve_data","text":"get_LMO_solve_data(blmo::MathOptBLMO)\n\nGet solve time, number of nodes and number of simplex iterations.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_binary_variables-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_binary_variables","text":"get_binary_variables(blmo::MathOptBLMO)\n\nGet list of binary variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_bound-Tuple{FrankWolfe.MathOptLMO, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_bound","text":"get_bound(blmo::MathOptBLMO, c_idx, sense::Symbol)\n\nRead bound value for c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_int_var-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_int_var","text":" get_int_var(blmo::MathOptBLMO, c_idx)\n\nGet the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_integer_variables-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_integer_variables","text":" get_integer_variables(blmo::MathOptBLMO)\n\nGet list of integer variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_list_of_variables-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_list_of_variables","text":"get_list_of_variables(blmo::MathOptBLMO)\n\nGet list of variables indices and the total number of variables.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_lower_bound_list-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_lower_bound_list","text":"get_lower_bound_list(blmo::MathOptBLMO)\n\nGet the list of lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_tol-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_tol","text":" get_tol(blmo::MathOptBLMO)\n\nGet solving tolerance for the BLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_upper_bound_list-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_upper_bound_list","text":"get_upper_bound_list(blmo::MathOptBLMO)\n\nGet the list of upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_variables_pointers-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_variables_pointers","text":"get_variables_pointers(blmo, tree)\n\nList of all variable pointers. Depends on how you save your variables internally. Is used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_binary_constraint-Tuple{FrankWolfe.MathOptLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_binary_constraint","text":"has_binary_constraint(blmo::MathOptBLMO, idx::Int)\n\nHas variable a binary constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_integer_constraint-Tuple{FrankWolfe.MathOptLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_integer_constraint","text":"has_integer_constraint(blmo::MathOptBLMO, idx::Int)\n\nDoes the variable have an integer constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.indicator_present-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.indicator_present","text":"indicator_present(blmo::MathOptBLMO)\n\nAre indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_bound_in-Tuple{FrankWolfe.MathOptLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_bound_in","text":"is_bound_in(blmo::MathOptBLMO, c_idx, bounds)\n\nTo check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_constraint_on_int_var-Tuple{FrankWolfe.MathOptLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_constraint_on_int_var","text":"is_constraint_on_int_var(blmo::MathOptBLMO, c_idx, int_vars)\n\nCheck if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_indicator_feasible-Tuple{FrankWolfe.MathOptLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_indicator_feasible","text":"is_indicator_feasible(lmo::FrankWolfe.MathOptLMO, v; atol=1e-6, rtol=1e-6)\n\nIs a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_inface_feasible-Tuple{FrankWolfe.MathOptLMO, AbstractVector, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_inface_feasible","text":"Is a given point v inface feasible for the model?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_linear_feasible-Tuple{FrankWolfe.MathOptLMO, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_linear_feasible","text":"is_linear_feasible(blmo::MathOptBLMO, v::AbstractVector)\n\nIs a given point v linear feasible for the model?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, FrankWolfe.MathOptLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_valid_split","text":"is_valid_split(tree::Bonobo.BnBTree, blmo::MathOptBLMO, vidx::Int)\n\nCheck whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.set_bound!-Tuple{FrankWolfe.MathOptLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.set_bound!","text":"set_bound!(blmo::MathOptBLMO, c_idx, value, sense::Symbol)\n\nChange the value of the bound c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.solve-Tuple{Any, Any, Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.solve","text":"The solve  function receiving a Boscia.MathOptBLMO.  Converts the lmo into an instance of FrankWolfe.MathOptLMO and calls the main solve function.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Managed-BLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Managed BLMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Sometimes the linear problem over the feasible region can be computed via a combinatorial algorithm that is more efficient than formulating the problem as a MIP. If one does not want to implement the BLMO interface from scratch which requires multiple methods to be provided, we provide the ManagedBLMO. It handles the bound management, so that the user has to implement only a few methods.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.ManagedLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ManagedLMO","text":"ManagedLMO{LMO<:FrankWolfe.LinearMinimizationOracle} <: FrankWolfe.LinearMinimizationOracle\n\nA Linear Minimization Oracle wrapper that manages the bounds.\n\nlmo a FrankWolfe.LinearMinimizationOracle.  \nlower_bounds list of lower bounds for the integer variables recorded in int_vars. If there is no specific lower bound, set corresponding entry to -Inf.\nupper_bounds list of upper bounds for the integer variables recorded in int_vars. If there is no specific upper bound, set corresponding entry to Inf.\nn total number of variables.\nint_vars list of indices of the integer variables.\nsolving_time the time to evaluate compute_extreme_point.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.SimpleBoundableLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.SimpleBoundableLMO","text":"SimpleBoundableLinearMinimizationOracle\n\nA \"simple\" LMO that computes the extreme point given a linear objective and the node specific bounds on the integer variables. Can be stateless since all of the bound management is done by the ManagedBoundedLMO. \n\nWILL BE DEPRECATED!\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(lmo::LinearMinimizationOracle, d, lb, ub, int_vars; kwargs...)\n\nComputes the extreme point given an direction d, the current lower and upper bounds on the integer variables, and the set of indices of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_simple_linear_feasible","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_simple_linear_feasible","text":"is_simple_linear_feasible(lmo::LinearMinimizationOracle, v::AbstractVector)\n\nChecks whether a given point v is satisfying the constraints on the problem. Note that the bounds on the integer variables are being checked by the ManagedBoundedLMO and do not have to be check here. \n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Polytopes","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Polytopes","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Here are some preimplemented polytopes. We have the hypercube, the unit simplex and the probability simplex.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.CubeLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.CubeLMO","text":"CubeSimpleLMO{T}(lower_bounds, upper_bounds, int_vars)\n\nHypercube with lower and upper bounds implementing the SimpleBoundableLMO interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.ProbabilitySimplexLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ProbabilitySimplexLMO","text":"ProbablitySimplexSimpleLMO(N)\n\nThe scaled probability simplex with ∑ x = N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.ReverseKnapsackLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ReverseKnapsackLMO","text":"ReverseKnapsackLMO(N, upper_bounds)\n\nBLMO denotes the reverse Knapsack constraint: ∑ x ≥ N. We assume x ≥ 0.  Explicit upper bounds are needed, otherwise the feasible region is unbounded.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.UnitSimplexLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.UnitSimplexLMO","text":"UnitSimplexLMO(N)\n\nThe scaled unit simplex with ∑ x ≤ N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.CubeLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":" bounded_compute_extreme_point(sblmo::CubeSimpleLMO, d, lb, ub, int_vars; kwargs...)\n\nIf the entry is positve, choose the lower bound. Else, choose the upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.ProbabilitySimplexLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(lmo::ProbabilitySimplexLMO, d, lb, ub, int_vars; kwargs...)\n\nAssign the largest possible values to the entries corresponding to the smallest entries of d.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.ReverseKnapsackLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"Entries corresponding to non positive entries in d, are assigned their upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.UnitSimplexLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"bounded_compute_extreme_point(lmo::UnitSimplexSimpleLMO, d, lb, ub, int_vars; kwargs...)\n\nFor all positive entries of d, assign the corresponding lower bound. For non-positive entries, assign largest possible value in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.CubeLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"If the entry in x is at the boundary, choose the corresponding bound. Otherwise, if the entry in direction is positve, choose the lower bound. Else, choose the upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.ProbabilitySimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"Fix the corresponding entries to the boudary based on the given x. Assign the largest possible values to the unfixed entries corresponding to the smallest entries of d.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_inface_extreme_point-Tuple{Boscia.UnitSimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_inface_extreme_point","text":"For boundary entries of x, assign the corresponding boudary. For all positive entries of d, assign the corresponding lower bound. For non-positive entries, assign largest possible value in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.CubeLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.ProbabilitySimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_dicg_maximum_step-Tuple{Boscia.UnitSimplexLMO, Vararg{Any, 5}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_dicg_maximum_step","text":"Compute the maximum step size for each entry and the sum of entries should satisfy inequality constraint. Return the minium of all the possible step sizes.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedLMO{Boscia.ProbabilitySimplexLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":" rounding_hyperplane_heuristic(tree::Bonobo.BnBTree, tlmo::TimeTrackingLMO{ManagedBoundedLMO{ProbabilitySimplexLMO}}, x)\n\nHyperplane-aware rounding for the probability simplex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedLMO{Boscia.ReverseKnapsackLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"Hyperplane-aware rounding for the reverse knapsack constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedLMO{Boscia.UnitSimplexLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"rounding_hyperplane_heuristic(tree::Bonobo.BnBTree, tlmo::TimeTrackingLMO{ManagedBoundedLMO{UnitSimplexLMO}}, x)\n\nHyperplane-aware rounding for the unit simplex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Time-Tracking-BLMO-Wrapper","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Time Tracking BLMO Wrapper","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"This wrapper keeps track of the statistics like solving time of the BLMO, the number of calls etc.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO{LMO<:LinearMinimizationOracle} <: FrankWolfe.LinearMinimizationOracle\n\nA wrapper for the BLMO tracking the solving time, number of calls etc. Is created in Boscia itself.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO-Tuple{LinearMinimizationOracle, Any, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO(lmo::LinearMinimizationOracle, int_vars)\n\nConstructor with just the blmo.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO-Tuple{LinearMinimizationOracle, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO(lmo::LinearMinimizationOracle)\n\nConstructor with just the blmo.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.reset!-Tuple{Boscia.TimeTrackingLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.reset!","text":"reset!(tlmo::TimeTrackingLMO)\n\nIf we want to reset the info between nodes in the Branch-and-Bound tree.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#FrankWolfe.compute_extreme_point-Tuple{Boscia.TimeTrackingLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.compute_extreme_point","text":"FrankWolfe.compute_extreme_point(tlmo::TimeTrackingLMO, d; kwargs...)\n\nCompute the extreme point and collect statistics.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Build-LMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Build LMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Given the global bounds on the integer variables and the bounds at the node level, this builds the BLMO instance for the specific node. This way, the BLMO can be stored in the tree as opposed to every node having a copy of it.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.build_LMO-Tuple{LinearMinimizationOracle, Boscia.IntegerBounds, Boscia.IntegerBounds, Vector{Int64}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO","text":"Build node LMO from global LMO\n\nFour action can be taken:\n\nKEEP   constraint is as saved in the global bounds\nCHANGE lower/upper bound is changed to the node specific one\nDELETE custom bound from the previous node that is invalid at current node and has to be deleted\nADD    bound has to be added for this node because it does not exist in the global bounds (e.g. variable bound is a half open interval globally) \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Integer-Bounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Integer Bounds","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"The data structure that records the bounds on the integer/binary variables.","category":"page"},{"location":"reference/2_blmo_build/#Boscia.IntegerBounds","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.IntegerBounds","text":"IntegerBounds\n\nKeeps track of the bounds of the integer (binary) variables.\n\nlower_bounds dictionary of Float64, index is the key.\nupper_bounds dictionary of Float64, index is the key.\n\n\n\n\n\n","category":"type"},{"location":"examples/docs-02-graph-isomorphism/#Graph-Isomorphism-Problem","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"This example shows how to use Boscia to certify whether two graphs are isomorphic. Given adjacency matrices A and B, the graphs are isomorphic if and only if there exists a permutation matrix X in mathcalP_n such that:","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"  X * A = B * X","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"where mathcalP_n denotes the set of permutation matrices. Equivalently, we consider the optimization problem","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"  min_Xin mathcalP_n f(X) =  X A - B X _F^2","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"whose optimum is exactly 0 if and only if the graphs are isomorphic. We solve over the Birkhoff polytope (convex hull of permutation matrices) with a branch-and-bound scheme plus Frank–Wolfe in the nodes; the lower bound allows pruning, and a zero incumbent certifies isomorphism.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Imports-and-graph-generation-utilities","page":"Graph Isomorphism Problem","title":"Imports and graph generation utilities","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We begin by importing the packages used in this example.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"using Boscia\nusing Random\nusing SparseArrays\nusing FrankWolfe\nusing Bonobo\nusing CSV\nusing StableRNGs\nusing CombinatorialLinearOracles\nconst CLO = CombinatorialLinearOracles\n\nprintln(\"\\nDocumentation Example 02: Graph Isomorphism Problem\")\n\nseed = rand(UInt64)\n@show seed\nrng = StableRNG(seed)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"To create test instances, we provide two helper functions that construct pairs of graphs with either matching or mismatching structure.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Isomorphic case: Given an adjacency matrix A, we sample a permutation matrix P and form B = P A P′. This produces a graph that is isomorphic to A by construction.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function randomIsomorphic(A)\n    n = size(A, 1)\n    p = randperm(n)\n    P = sparse(1:n, p, ones(Float64, n), n, n)\n    B = P * A * P'\n    return B, P\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Non-isomorphic case: To obtain a simple counterexample, we toggle a single undirected edge of A to produce B. Such a small perturbation typically breaks isomorphism while preserving symmetry of the adjacency matrix.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function randomNonIsomorphic(A::AbstractMatrix)\n    B = copy(A)\n    n = size(B, 1)\n    i = rand(1:(n-1))\n    j = rand((i+1):n)\n    B[i, j] = 1 - B[i, j]\n    B[j, i] = B[i, j]\n    return B\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"For this example, we work with the Petersen graph, provided as a CSV file containing its adjacency matrix. After loading A, we generate an isomorphic graph B using the routine above.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"path = joinpath(@__DIR__, \"Petersen.csv\")\nrows = [collect(Int, r) for r in CSV.File(path; header=false, types=Int)]\nconst A = sparse(reduce(vcat, (permutedims(r) for r in rows)))\nn = size(A, 1)\n\nB, P = randomIsomorphic(Matrix(A))\nB = sparse(B)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Objective-and-gradient","page":"Graph Isomorphism Problem","title":"Objective and gradient","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"To measure how well a matrix X satisfies the relation X A = B X, we minimize the Frobenius norm of the mismatch:","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"f(X) = lVert X A - B X rVert_F^2","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"The gradient has the form","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"nabla f(X)\n  = 2(X A - B X)A^top\n    - 2B^top(X A - B X)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"In the implementation, X is stored in vectorized form for compatibility with the solver.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function f(x)\n    X = reshape(x, n, n)\n    R = X * A - B * X\n    return sum(abs2, R)\nend\n\nfunction grad!(storage, x)\n    X = reshape(x, n, n)\n    grad_matrix = 2 * (X * A - B * X) * A' - 2 * B' * (X * A - B * X)\n    return storage .= vec(grad_matrix)\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Linear-Minimization-Oracle-(LMO)","page":"Graph Isomorphism Problem","title":"Linear Minimization Oracle (LMO)","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"The feasible region of the optimization is the Birkhoff polytope, the convex hull of permutation matrices. We use the Birkhoff LMO provided by CombinatorialLinearOracles, which performs the required linear subproblem via the Hungarian algorithm.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"In CombinatorialLinearOracles, we implement the full LMO interface for the Birkhoff polytope. The simpler approach using the ManagedLMO wrapper would not be able to efficiently support additional bound information, such as tracking and updating reduced matrices after entries of the permutation matrix have been fixed. Without a structure-aware oracle, each call to compute an extreme point would require rebuilding the reduced assignment problem, introducing avoidable overhead.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"The custom BirkhoffLMO avoids this by recording fixed indices and maintaining the corresponding reduced assignment matrix. Linear minimization is then performed on the reduced matrix via the Hungarian algorithm, and the resulting solution is lifted back by adding the fixed entries. This ensures that node-specific constraints are handled consistently and that each oracle call remains efficient.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"blmo = CLO.BirkhoffLMO(n, collect(1:(n^2)))","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Branching-and-pruning-callbacks","page":"Graph Isomorphism Problem","title":"Branching & pruning callbacks","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We define callback routines to steer the branch-and-bound process.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Branch callback: At a given node, if the node’s lower bound is already strictly positive, no permutation can achieve an objective value of zero in that subtree. On such nodes, we do not need to branch further..","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function build_branch_callback()\n    return function (tree, node, vidx::Int)\n        x = Bonobo.get_relaxed_values(tree, node)\n        primal = tree.root.problem.f(x)\n        lower_bound = primal - node.dual_gap\n        if lower_bound > 0.0 + eps()\n            println(\"No need to branch here. Node lower bound already positive.\")\n        end\n        valid_lower = lower_bound > 0.0 + eps()\n        return valid_lower, valid_lower\n    end\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"Tree callback: The search can be terminated early under either of two conditions:","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"The current incumbent reaches objective value of 0.0, certifying isomorphism.\nThe lower bound of the B&B tree becomes strictly positive, implying that no permutation satisfies X A = B X, and thus the graphs are not isomorphic.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function build_tree_callback()\n    return function (tree, node; worse_than_incumbent=false, node_infeasible=false, lb_update=false)\n        if isapprox(tree.incumbent, 0.0, atol=eps())\n            tree.root.problem.solving_stage = Boscia.USER_STOP\n            println(\"Optimal solution found.\")\n        end\n        if Boscia.tree_lb(tree::Bonobo.BnBTree) > 0.0 + eps()\n            tree.root.problem.solving_stage = Boscia.USER_STOP\n            println(\"Tree lower bound already positive. No solution possible.\")\n        end\n    end\nend","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Neighborhood-heuristic-over-the-Birkhoff-polytope","page":"Graph Isomorphism Problem","title":"Neighborhood heuristic over the Birkhoff polytope","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We include a simple neighborhood heuristic that generates a few alternative permutations around the current incumbent. This provides additional candidates that the solver may consider during the search.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We generate k = ⌊√n⌋ neighbor candidates during each invocation of the heuristic.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"function random_k_neighbor_matrix(\n    tree::Bonobo.BnBTree,\n    blmo::Boscia.TimeTrackingLMO,\n    x,\n    k::Int,\n    use_mip=false,\n)\n    P = tree.incumbent_solution.solution\n    n0 = size(P, 1)\n    n = Int(sqrt(n0))\n    P = reshape(P, n, n)\n    new_P = copy(P)\n    Ps = []\n    for _ in 1:k\n        i, j = rand(1:n, 2)\n        while i == j\n            j = rand(1:n)\n        end\n        col_i = findfirst(x -> x == 1, new_P[i, :])\n        col_j = findfirst(x -> x == 1, new_P[j, :])\n        new_P[i, col_i] = 0\n        new_P[i, col_j] = 1\n        new_P[j, col_j] = 0\n        new_P[j, col_i] = 1\n        new_p = use_mip ? vec(new_P) : sparsevec(vec(new_P))\n        push!(Ps, new_p)\n    end\n    return Ps, false\nend\n\nk = Int(round(sqrt(n)))\nswap_heu = Boscia.Heuristic(\n    (tree, blmo, x) -> random_k_neighbor_matrix(tree, blmo, x, k, false),\n    1.0,\n    :swap,\n)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Solver-configuration-and-solve-call","page":"Graph Isomorphism Problem","title":"Solver configuration and solve call","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We configure Boscia with the problem-specific callbacks, the swap-based neighborhood heuristic, and a decomposition-invariant Frank-Wolfe method using a secant line search.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"settings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = true\nsettings.branch_and_bound[:print_iter] = 10\nsettings.branch_and_bound[:bnb_callback] = build_tree_callback()\nsettings.branch_and_bound[:branch_callback] = build_branch_callback()\nsettings.heuristic[:custom_heuristics] = [swap_heu]\nsettings.frank_wolfe[:variant] = Boscia.DecompositionInvariantConditionalGradient()\nsettings.frank_wolfe[:line_search] = FrankWolfe.Secant()\nsettings.frank_wolfe[:lazy] = true\nsettings.frank_wolfe[:max_fw_iter] = 1000","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"We now call Boscia.solve with the objective, gradient, and Birkhoff LMO. If A and B are isomorphic, the solver should identify a permutation matrix X with objective value f(X) = 0.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"x, _, result = Boscia.solve(f, grad!, blmo, settings=settings)","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"A successful solve provides a permutation matrix X such that:","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"A approx X^top B X ","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"This equality certifies that the two graphs are isomorphic.","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"X = reshape(x, n, n)\n@assert A ≈ X' * B * X\nprintln(\"Certificate verified: graphs are isomorphic (A ≈ X' * B * X)\")","category":"page"},{"location":"examples/docs-02-graph-isomorphism/#Complement:-Non-isomorphic-case","page":"Graph Isomorphism Problem","title":"Complement: Non-isomorphic case","text":"","category":"section"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"To certify non-isomorphism, we can replace B by a perturbed version (e.g., by toggling an edge). In that case, no permutation satisfies X A = B X, and the optimization yields a strictly positive lower bound:","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"textdual bound  0 ","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"B = randomNonIsomorphic(A)\nx, _, result = Boscia.solve(f, grad!, blmo, settings = settings)\n@assert result[:dual_bound] > 0.0\nprintln(\"Graphs are not isomorphic (lower bound > 0)\")","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"","category":"page"},{"location":"examples/docs-02-graph-isomorphism/","page":"Graph Isomorphism Problem","title":"Graph Isomorphism Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/custom/#Branch-and-Bound-tree-functionality","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"The functionality of the Branch-and-Bound implementation extended from Bonobo.jl and some extended features like strong branching and the callbacks.","category":"page"},{"location":"reference/custom/#Problem","page":"Branch-and-Bound tree functionality","title":"Problem","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"The main problem structure as stored in the Branch-and-Bound tree.","category":"page"},{"location":"reference/custom/#Boscia.SimpleOptimizationProblem","page":"Branch-and-Bound tree functionality","title":"Boscia.SimpleOptimizationProblem","text":"Represents an optimization problem of the form:\n\nmin_x f(x)\ns.t.  x ∈ X (given by the LMO)\n      x_j ∈ Z ∀ j in integer_variables\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.get_branching_indices-Tuple{Boscia.SimpleOptimizationProblem}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_indices","text":"Returns the indices of the discrete variables for the branching in Bonobo.BnBTree\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.indicator_present-Tuple{Boscia.TimeTrackingLMO}","page":"Branch-and-Bound tree functionality","title":"Boscia.indicator_present","text":"Are indicator constraints present\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_integer_feasible-Tuple{AbstractVector{<:Integer}, AbstractVector}","page":"Branch-and-Bound tree functionality","title":"Boscia.is_integer_feasible","text":"Checks if a given vector is valid integral solution. Specifically for mixed problems.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_linear_feasible-Tuple{Boscia.TimeTrackingLMO, AbstractVector}","page":"Branch-and-Bound tree functionality","title":"Boscia.is_linear_feasible","text":"Checks if x is valid for all linear and variable bound constraints \n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Customized-Bonobo-structures-and-functions","page":"Branch-and-Bound tree functionality","title":"Customized Bonobo structures and functions","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Our adaptations to the functions in Bonobo.jl. ","category":"page"},{"location":"reference/custom/#Bonobo.optimize!-Tuple{Bonobo.BnBTree{var\"#s23\", Root, Value, Solution} where {var\"#s23\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s23\", Value}}}","page":"Branch-and-Bound tree functionality","title":"Bonobo.optimize!","text":"optimize!(tree::BnBTree; callback=(args...; kwargs...)->())\n\nOptimize the problem using a branch and bound approach.  The steps, repeated until terminated is true, are the following:\n\n# 1. get the next open node depending on the traverse strategy\nnode = get_next_node(tree, tree.options.traverse_strategy)\n# 2. evaluate the current node and return the lower and upper bound\n# if the problem is infeasible both values should be set to NaN\nlb, ub = evaluate_node!(tree, node)\n# 3. update the upper and lower bound of the node struct\nset_node_bound!(tree.sense, node, lb, ub)\n# 4. update the best solution\nupdated = update_best_solution!(tree, node)\nupdated && bound!(tree, node.id)\n# 5. remove the current node\nclose_node!(tree, node)\n# 6. compute the node children and adds them to the tree\n# internally calls get_branching_variable and branch_on_variable!\nbranch!(tree, node)\n\nA callback function can be provided which will be called whenever a node is closed. It always has the arguments tree and node and is called after the node is closed.  Additionally the callback function must accept additional keyword arguments (kwargs)  which are set in the following ways:\n\nIf the node is infeasible the kwarg node_infeasible is set to true.\nIf the node has a higher lower bound than the incumbent the kwarg worse_than_incumbent is set to true.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Node-Evaluation","page":"Branch-and-Bound tree functionality","title":"Node Evaluation","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Evaluation of the nodes and handling of branching.","category":"page"},{"location":"reference/custom/#Boscia.AbstractFrankWolfeNode","page":"Branch-and-Bound tree functionality","title":"Boscia.AbstractFrankWolfeNode","text":"AbtractFrankWolfeNode <: Bonobo.AbstractNode\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Boscia.FrankWolfeNode","page":"Branch-and-Bound tree functionality","title":"Boscia.FrankWolfeNode","text":"FrankWolfeNode <: AbstractFrankWolfeNode\n\nA node in the branch-and-bound tree storing information for a Frank-Wolfe subproblem.\n\nstd stores the id, lower and upper bound of the node. active_set store the active set structure. local_bounds instead of storing the complete LMO, it just stores the bounds specific to THIS node.     All other integer bounds are stored in the root. 'level' stores the level in the tree 'fwdualgaplimit' set the tolerance for the dual gap in the FW algorithms 'precomputedset' stores specifically the extreme points computed in DICG for warm-start. 'parentlowerboundbase' contains lower bound value of the parent node.  Needed     for updating pseudocosts. 'branchedon' contains the index of the parent. Required for updating pseudocosts. 'branchedright' Boolean value specifying if node resulted from a left or right branch. Needed     for updating pseudocosts. 'distancetoint' Stores information on the rounding amount at branching. Required     for correct scaling of pseudocosts.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Boscia.NodeInfo","page":"Branch-and-Bound tree functionality","title":"Boscia.NodeInfo","text":"NodeInfo\n\nHolds the necessary information of every node. This needs to be added by every AbstractNode as std::NodeInfo\n\nThis variant is more flexibel than Bonobo.BnBNodeInfo.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.evaluate_node!-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode}","page":"Branch-and-Bound tree functionality","title":"Bonobo.evaluate_node!","text":"Computes the relaxation at that node\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Bonobo.get_branching_nodes_info-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode, Int64}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_nodes_info","text":"Create the information of the new branching nodes  based on their parent and the index of the branching variable\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Bonobo.get_relaxed_values-Tuple{Bonobo.BnBTree, Boscia.FrankWolfeNode}","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_relaxed_values","text":"Returns the solution vector of the relaxed problem at the node\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Callbacks","page":"Branch-and-Bound tree functionality","title":"Callbacks","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"There are two callbacks.  One for the Branch-and-Bound tree that records progress data, checks the time limit and prints the logs. The other is a callback for the Frank-Wolfe runs that runs some checks in each iteration.  Additionally, the computed vertices are added to the solution pool. Lastly, the Frank-Wolfe solve can be interrupted if either the dual bound has reached the current incumbent or  there are enough more promising nodes open.","category":"page"},{"location":"reference/custom/#Boscia.build_FW_callback-Tuple{Any, Any, Bool, Vararg{Any, 4}}","page":"Branch-and-Bound tree functionality","title":"Boscia.build_FW_callback","text":"Frank-Wolfe Callback.\n\nIs called in every Frank-Wolfe iteration. Node evaluation can be dynamically stopped here. Time limit is checked. If the vertex is providing a better incumbent, it is added as solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.build_bnb_callback-NTuple{22, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.build_bnb_callback","text":"Branch-and-Bound Callback. Collects statistics and prints logs if verbose is turned on.\n\nOutput of Boscia:     iter :          current iteration of Boscia     node id :       current node id     lower bound :   treelb(tree)     incumbent :     tree.incumbent     gap :           tree.incumbent-treelb(tree)     rel. gap :      dualgap/tree.incumbent     time :          total time of Boscia     time/nodes :    average time per node     FW time :       time spent in FW      LMO time :      time used by LMO     LMO calls :     number of computeextreme_point calls in FW     FW iterations : number of iterations in FW\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Tightenings","page":"Branch-and-Bound tree functionality","title":"Tightenings","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"Tightenings are performed on node level and can be used either just for the node in question or globally. If the obejctive is strongly convex and/or sharp, this can also be used to tighten the lower bound at the current node. ","category":"page"},{"location":"reference/custom/#Boscia.dual_tightening-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.dual_tightening","text":"Tightening of the bounds at node level. Children node inherit the updated bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.global_tightening-Tuple{Any, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.global_tightening","text":"Use the gradient of the root node to tighten the global bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.prune_children-NTuple{5, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.prune_children","text":"Use strong convexity and/or sharpness to potentially remove one of the children nodes. If both sharpness and strong convexity parameters are provided, strong convexity is preferred.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.store_data_global_tightening-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.store_data_global_tightening","text":"Save the gradient of the root solution (i.e. the relaxed solution) and the  corresponding lower and upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.tightening_lowerbound-NTuple{4, Any}","page":"Branch-and-Bound tree functionality","title":"Boscia.tightening_lowerbound","text":"Tighten the lower bound using strong convexity and/or sharpness of the objective.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Strong-and-Hybrid-Branching","page":"Branch-and-Bound tree functionality","title":"Strong and Hybrid Branching","text":"","category":"section"},{"location":"reference/custom/","page":"Branch-and-Bound tree functionality","title":"Branch-and-Bound tree functionality","text":"We provide a strong branching strategy consisting of running Frank-Wolfe for only a few iterations to get an estimate of the bound increase. Due to the cost of strong branching, it is usually not advisable to run strong branching through the whole tree. Hence, we provide a hybrid branching which performs strong branching until a user specified depth and then switches to most-infeasible branching. ","category":"page"},{"location":"reference/custom/#Boscia.HybridStrongBranching","page":"Branch-and-Bound tree functionality","title":"Boscia.HybridStrongBranching","text":"Hybrid between partial strong branching and another strategy. perform_strong_branch(tree, node) -> Bool decides whether to perform strong branching or not.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.get_branching_variable-Union{Tuple{LMO}, Tuple{Bonobo.BnBTree, Boscia.PartialStrongBranching{LMO}, Bonobo.AbstractNode}} where LMO<:LinearMinimizationOracle","page":"Branch-and-Bound tree functionality","title":"Bonobo.get_branching_variable","text":"Get branching variable using strong branching. Create all possible subproblems, solve them and pick the one with the most progress.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.strong_up_to_depth","page":"Branch-and-Bound tree functionality","title":"Boscia.strong_up_to_depth","text":"strongupto_depth performs strong branching on nodes up to a predetermined depth, and the falls back to another rule\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Algorithm-Interface","page":"Algorithm Interface","title":"Algorithm Interface","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia's solve function only requires the oracles of the objective function f and its gradient g as well as the BLMO encoding the feasible region. For the possible settings, see further down the page.","category":"page"},{"location":"reference/1_algorithms/#Boscia.postsolve-NTuple{5, Any}","page":"Algorithm Interface","title":"Boscia.postsolve","text":"postsolve(tree, result, time_ref, verbose, max_iteration_post)\n\nRuns the post solve to optimize for the continuous variables if present. Is called if use_post_solve is enabled in the solve function. Prints solution statistics if verbose is set to true.        \n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.solve-Tuple{Any, Any, LinearMinimizationOracle}","page":"Algorithm Interface","title":"Boscia.solve","text":"solve(f, g, lmo::LinearMinimizationOracle; ...)\n\nRequires\n\nf oracle of the objective function.\ng oracle of the gradient of the objective\nlmo encodes the feasible region and can handle additional bound constraints. This can either be a MIP solver instance (e.g., SCIP) or be a custom type (see polytope_blmos.jl). Has to be of type FrankWolfe.LinearMinimizationOracle (see blmo_interface.jl).\n\nReturns\n\nx the best solution found.\ntlmo the LMO wrapped in a TimeTrackingLMO instance.\nresult a dictionary containg the statistics like number of nodes, total solving etc. It also contains information for plotting progress plots like the lower and upper bound progress.\n\nOptional settings\n\nsettings_bnb dictionary of settings for the branch-and-bound algorithm. Created via settings_bnb().\nsettings_frank_wolfe dictionary of settings for the Frank-Wolfe algorithm. Created via settings_frank_wolfe().\nsettings_tolerances dictionary of settings for the tolerances. Created via settings_tolerances().\nsettings_postprocessing dictionary of settings for the postprocessing. Created via settings_postprocessing().\nsettings_heuristic dictionary of settings for the heuristics. Created via settings_heuristic().\nsettings_tightening dictionary of settings for the tightening. Created via settings_tightening().\nsettings_domain dictionary of settings for the domain. Created via settings_domain().\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Optional-settings","page":"Algorithm Interface","title":"Optional settings","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia has a lot of settings to customize the solving process. These are grouped by ","category":"page"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"general Branch-and-Bound settings \nsettings specific for Frank-Wolfe \ntolerances settings for both the tree as well as the Frank-Wolfe algorithm \nsettings for the heuristics\nbound tightenings settings\npostprocessing settings\nparameters for the case of a non-trivial domain, i.e. the objective cannot be evaluated at all points of the feasible region","category":"page"},{"location":"reference/1_algorithms/#Boscia.create_default_settings-Tuple{}","page":"Algorithm Interface","title":"Boscia.create_default_settings","text":"Create default settings depending on the mode.\n\nOnly requires the mode, if no mode is provided, the default mode is used. Returns a NamedTuple of dictionaries for the different group of settings.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_bnb-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_bnb","text":"settings_bnb(mode::Mode;...)\n\nSet the settings for the branch-and-bound algorithm.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the branch-and-bound algorithm.\n\nAvailable settings:\n\ntraverse_strategy encodes how to choose the next node for evaluation. By default the node with the best lower bound is picked.\nbranching_strategy fixes the branching strategy. By default, weuse MOST_INFEASIBLE, i.e. we branch on the entry which is the farthest away from being an integer.\nverbose if true, logs and solution statistics are printed. Per default, this is false.\nnode_limit maximum number of nodes to be evaluated. In DEFAULT mode, there is no limit. In HEURISTIC mode, the default is set to 1000.\ntime_limit algorithm will stop if the time limit is reached. Depending on the problem it is possible that no feasible solution has been found yet. In DEFAULT mode, there is no time limit. In HEURISTIC mode, the default is set to 300 seconds (5 minutes).\nprint_iter encodes after how many processed nodes the current node and solution status is printed. The logs are always printed if a new integral solution has been found. Per default, print_iter is set to 100`.\nbnb_callback optional callback function that is called after every node evaluation. It will be called before the Boscia internal callback handling the printing of the logs. It receives the tree, the node and the following keyword arguments: worse_than_incumbent=false, node_infeasible=false, lb_update=false.\nbranch_callback an optional callback called before branching. Receives the tree, the node and the branching variable index as input. Expected output is a pair of boolean values indicating whether the left and right child should be pruned. falseindicates prune the child, true indicates keep the child.\nno_pruning if true, no pruning of nodes is performed. Per default, nodes are pruned if they have a lower bound which is worse than the best known solution. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\nignore_lower_bound if true, the lower bound obtain by Frank-Wolfe is ignored and in the logs, only Inf will be printed. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\nstart_solution an initial solution can be provided if known. It will be used as the initial incumbent.\nuse_shadow_set the shadow set is the set of discarded vertices which is inherited by the children nodes. It is used to avoid recomputing of vertices in case the LMO is expensive. In case of a cheap LMO, performance might improve by disabling this option. Per default, this is true.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_domain-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_domain","text":"settings_domain(mode::Mode;...)\n\nTo set settings for a non-trivial domain, i.e. if not all points of the feasible region are domain feasible.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the domain.\n\nAvailable settings:\n\ndomain_oracle given a point x: returns true if x is in the domain of f, else false. Per default, it always returns true. In case of the non-trivial domain oracle, the initial point has to be domain feasible for f and can be set via the active_set. Additionally, the user has to provide a functiondomain_point`, see below. Also, depending on the line search method, you might have to provide the domain oracle to it, too. The default line search Secant, for example, requires the domain oracle.\nfind_domain_point given the current node bounds return a domain feasible point respecting the bounds. If no such point can be found, return nothing. Only necessary for a non-trivial domain oracle.\nactive_set can be used to specify a starting point. By default, the direction (1,..,n) where n is the size of the problem is used to find a start vertex. This has to be of the type FrankWolfe.ActiveSet. Beware that the active set may only contain actual vertices of the feasible region.\ndepth_domain The domain point is used to generate new starting points after branching by solving a projection problem. This parameter is used to control how far we move into the domain.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_frank_wolfe-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_frank_wolfe","text":"settings_frank_wolfe(mode::Mode;...)\n\nOptions for the Frank-Wolfe algorithm used as node solver.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the Frank-Wolfe algorithm.\n\nAvailable settings:\n\nvariant the Frank-Wolfe variant to be used to solve the node problem. Options currently available are AwayFrankWolfe, BlendedConditionalGradient, BlendedPairwiseConditionalGradient, DecompositionInvariantConditionalGradient and StandardFrankWolfe. Per default, this is set to BlendedPairwiseConditionalGradient.\nline_search specifies the line search method used in the FrankWolfe variant. Default is the FrankWolfe.Secant line search. For other available types, check the FrankWolfe.jl package.\nmax_fw_iter maximum number of iterations in a Frank-Wolfe run. Per default, this is set to 10000.\nfw_timeout time limit for the Frank-Wolfe runs. Per default, there is no time limit. It is preferred to set the iteration limit but this can be used as a fallback and/or if the LMO call is time consuming.\nmin_fw_iterations the minimum number of Frank-Wolfe iterations performed in the node evaluation. Per default, this is set to 5.\nfw_verbose if true, the Frank-Wolfe logs are printed at each node. Mostly meant for debugging. Per default, this is false.\nlazy flag specifies whether the lazification of the Frank-Wolfe variant should be used. Per default true. Note that it has no effect on standard Frank-Wolfe.\nlazy_tolerance decides how much progress is deemed enough to not have to call the LMO. Only used if the lazy flag is activated. Per default, this is set to 2.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_heuristic-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_heuristic","text":"settings_heuristic(mode::Mode;...)\n\nSet the settings for the heuristics.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the heuristics.\n\nAvailable settings:\n\ncustom_heuristics list of custom heuristics from the user. Heuristics can be created via the Boscia.Heuristic constructor. It requires a function, a probability and an identifier (symbol). Note that the heuristics defined in Boscia themselves don't have to be added here and can be set via the probability parameters below.\npost_heuristics_callback callback function called whenever a new solution is found and added to the tree. \nprob_rounding the probability for calling the simple rounding heuristic. Since the feasibility has to be checked, it might be expensive to do this for every node. Per default, this is activated for every node.\nfollow_gradient_prob the probability for calling the follow-the-gradient heuristic. Per default, this is 0.0.\nfollow_gradient_steps the number of steps for the follow-the-gradient heuristic. Per default, this is 10.\nrounding_lmo_01_prob the probability for calling the rounding-LMO-01 heuristic. Per default, this is 0.0.\nprobability_rounding_prob the probability for calling the probability-rounding heuristic. Per default, this is 0.0.\nhyperplane_aware_rounding_prob the probability for calling the hyperplane-aware-rounding heuristic. Per default, this is 0.0.\nadd_all_solutions if true, all solutions found by the heuristics, Frank-Wolfe or the LMO are added to the tree. Per default, this is true for the HEURISTIC mode and false for the OPTIMAL mode.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_postprocessing-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_postprocessing","text":"settings_postprocessing(mode::Mode;...)\n\nSet the settings for the postprocessing.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the postprocessing.\n\nAvailable settings:\n\nuse_postsolve if true, runs the specified Frank-Wolfe variant on the problem with the integral variables fixed to the solution, i.e. it only optimizes over the continuous variables. This might improve the solution if one has many continuous variables. Per default, this is true.\nmax_iteration_post maximum number of iterations in the Frank-Wolfe run during postsolve. Per default, this is set to 10000.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_tightening-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_tightening","text":"settings_tightening(mode::Mode;...)\n\nSet the tightening parameters.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of settings for the tightening.\n\nAvailable settings:\n\ndual_tightening flag to decide  whether to use dual tightening techniques at node level. Note that this only porvides valid tightenings if your function is convex! Per default, this is true.\nglobal_dual_tightening flag to decide whether to generate dual tightenings from new solutions that are gloablly valid. Per default, this is true.\nstrong_convexity strong convexity parameter of the objective f, used for tightening the dual bound at every node. Per default, this is set to 0.0.\nsharpness_constant - the constant M > 0 for (θ, M)-sharpness. f is (θ, M)-sharpness: f satisfies min_{x^* ∈ X^*} || x - x^* || ≤ M (f(x) - f^(x^*))^θ where X^* is the set of minimizer of f. Note that tightenings using sharpness are only valid if the problem has a unique minimizer, i.e. f is stricly convex! Per default, this is set to 0.0.\nsharpness_exponent - the exponent θ ∈ [0, 1/2] for (θ, M)-sharpness. Per default, this is set to Inf.\npropagate_bounds optional function that allows the user to propagate and tighten bounds depending on the node. Receives the tree and the node as input.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.settings_tolerances-Tuple{}","page":"Algorithm Interface","title":"Boscia.settings_tolerances","text":"settings_tolerances(mode::Mode;...)\n\nSet the tolerances for the Frank-Wolfe algorithm. These are tolerances both for the Branch-and-Bound tree as well as for the Frank-Wolfe variant used as node solver.\n\nRequires:\n\nmode the mode of the algorithm. See the Boscia.Mode enum for the available modes. If no mode is provided, the default mode is used.\n\nReturns:\n\nDict of tolerances for the Frank-Wolfe algorithm.\n\nAvailable settings:\n\nfw_epsilon the solving precision of Frank-Wolfe at the root node.\ndual_gap absolute dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to 1e-6.\nrel_dual_gap relative dual gap. If the difference between the incumbent and the lower bound reaches this value, the algorithm stops. Per default, this is set to 1e-2.\ndual_gap_decay_factor the FrankWolfe tolerance at a given level i in the tree is given by fw_epsilon * dual_gap_decay_factor^i until we reach the min_node_fw_epsilon. Per default, this is set to 0.8.\nmin_number_lower if not Inf, evaluation of a node is stopped if at least min_number_lower open nodes have a better lower bound. Per default, this is set to Inf.\nmin_node_fw_epsilon smallest fw epsilon tolerance, see also dual_gap_decay_factor. Per default, this is set to 1e-6.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Definitions","page":"Algorithm Interface","title":"Definitions","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm Interface","title":"Algorithm Interface","text":"Boscia defines its own solving state.  Additionally, Boscia has different modes, like the DEFAULT_MODE and HEURISTIC_MODE. These have their own default settings for the optional parameters.","category":"page"},{"location":"reference/0_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/0_reference/","page":"API Reference","title":"API Reference","text":"In this section we present the algorithm interface and the possible settings.","category":"page"},{"location":"examples/docs-01-network-design/#Network-Design-Problem","page":"Network Design Problem","title":"Network Design Problem","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"We demonstrate solving a network design problem using Boscia.jl. We want to minimize the total travel time over a network:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"beginaligned\n    min_mathbfx mathbfy quad  r^T mathbfy + c(mathbfx)   \n    textst quad  x_e = sum_z in mathcalZ x_e^z  forall e in mathcalE \n     mathbfx^z in mathcalX^z =\n    begincases\n        sum_e in delta^+(i) x_e^z - sum_e in delta^-(i) x_e^z = 0  forall i in mathcalV setminus (mathcalO cup mathcalZ) \n        sum_e in delta^+(i) x_e^z = d_i^z  forall i in mathcalO \n        sum_e in delta^-(z) x_e^z = sum_i in mathcalO d_i^z\n    endcases  forall z in mathcalZ \n       y_e = 0 Rightarrow x_e leq 0  forall e in mathcalR \n       mathbfy in mathcalY subset 01^mathcalR\nendaligned","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"where","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"c(x) = sum_e in E c_e(x) = α_e + β_e*x_e + γ_e*x_e^ρ_e","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"with α_e, β_e, and γ_e are constants and the exponent ρ_e  1 model the congestion effect. Given a set of purchasable/optional edges mathcalR, we want to decide which edges to build/restore. mathcalE denotes the set of edges mathcalS and mathcalO denote the set of source and destination nodes, respectively. The design cost is linear and the operating cost of the network is modeled as a traffic assignment problem. We solve the problem with two approaches based on the formulations in \"Network design for the traffic assignment problem with mixed-integer Frank-Wolfe\" by Sharma et al.:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Using MathOptInterface.jl (MOI) to model the feasible region\nA penalty formulation using a customized Linear Minimization Oracle based on shortest path algorithms","category":"page"},{"location":"examples/docs-01-network-design/#Imports-and-Setup","page":"Network Design Problem","title":"Imports and Setup","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"We start by generating the network.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"using Boscia\nusing FrankWolfe\nusing Graphs\nusing SparseArrays\nusing LinearAlgebra\nimport MathOptInterface\nconst MOI = MathOptInterface\nusing HiGHS\n\nprintln(\"\\nDocumentation Example 01: Network Design Problem\")","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The graph structure is shown below.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"mutable struct NetworkData\n    num_nodes::Int\n    num_edges::Int\n    init_nodes::Vector{Int}\n    term_nodes::Vector{Int}\n    free_flow_time::Vector{Float64}\n    capacity::Vector{Float64}\n    b::Vector{Float64}  # BPR function parameter\n    power::Vector{Float64}  # BPR function exponent\n    travel_demand::Matrix{Float64}\n    num_zones::Int\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The example is a small network with 8 nodes. Nodes 1 and 2 are the sources, node 3 is the destination, and nodes 4-8 are the intermediate nodes. The network is a directed graph with 12 edges. The edges are:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"1 - 4\n2 - 6\n4 - 6\n6 - 7\n7 - 8\n8 - 3\n5 - 3\n4 - 5 (optional edge)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Edge 8 will be the purchasable edge, i.e. an edge for which we have to decide to restore it or keep it closed. Travel demand is 1 unit from each source to the destination.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function load_braess_network()\n    init_nodes = [1, 2, 4, 5, 5, 6, 6, 7, 7, 8, 8, 4]\n    term_nodes = [4, 6, 6, 4, 3, 4, 7, 6, 8, 7, 3, 5]\n    free_flow_time = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n    capacity = [10.0, 10.0, 10.0, 10.0, 1.5, 10.0, 10.0, 10.0, 10.0, 10.0, 1.5, 10.0]\n    b = [0.1, 0.1, 0.1, 0.1, 3.0, 0.1, 0.1, 0.1, 0.1, 0.1, 3.0, 0.1]\n    power = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]\n    travel_demand = [0.0 0.0 1.0; 0.0 0.0 1.0; 0.0 0.0 0.0]\n    return NetworkData(8, length(init_nodes), init_nodes, term_nodes, free_flow_time,\n                      capacity, b, power, travel_demand, 3)\nend","category":"page"},{"location":"examples/docs-01-network-design/#Direct-modelling-via-MathOptInterface","page":"Network Design Problem","title":"Direct modelling via MathOptInterface","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"With MOI, we can directly model the feasible region. The linking constraints y_e = 0 Rightarrow x_e leq 0 forall e in mathcalR can be modelled either as bigM-constraints or indicator constraints (if the chosen MIP solver supports them).","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function build_moi_model(net_data, removed_edges, use_big_m=true)\n    optimizer = HiGHS.Optimizer()\n    MOI.set(optimizer, MOI.Silent(), true)\n    num_zones = net_data.num_zones\n    num_edges = net_data.num_edges\n    num_removed = length(removed_edges)\n    num_flow_vars = num_zones * num_edges  # x[dest, edge]\n    num_agg_vars = num_edges  # x_agg[edge]\n    num_design_vars = num_removed  # y[removed_edge] binary\n    total_vars = num_flow_vars + num_agg_vars + num_design_vars\n    x = MOI.add_variables(optimizer, num_flow_vars)\n    x_agg = MOI.add_variables(optimizer, num_agg_vars)\n    y = MOI.add_variables(optimizer, num_design_vars)\n    for i in 1:num_flow_vars\n        MOI.add_constraint(optimizer, x[i], MOI.GreaterThan(0.0))\n    end\n    for i in 1:num_agg_vars\n        MOI.add_constraint(optimizer, x_agg[i], MOI.GreaterThan(0.0))\n    end\n    for i in 1:num_design_vars\n        MOI.add_constraint(optimizer, y[i], MOI.ZeroOne())\n    end\n    edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i]) for i in 1:num_edges]\n    edge_dict = Dict(edge_list[i] => i for i in eachindex(edge_list))\n    incoming = Dict{Int, Vector{Int}}()\n    outgoing = Dict{Int, Vector{Int}}()\n\n    for (idx, (src, dst)) in enumerate(edge_list)\n        if !haskey(outgoing, src)\n            outgoing[src] = Int[]\n        end\n        push!(outgoing[src], idx)\n\n        if !haskey(incoming, dst)\n            incoming[dst] = Int[]\n        end\n        push!(incoming[dst], idx)\n    end\n    for dest in 1:num_zones\n        for node in 1:net_data.num_nodes\n            terms = MOI.ScalarAffineTerm{Float64}[]\n            if haskey(outgoing, node)\n                for edge_idx in outgoing[node]\n                    push!(terms, MOI.ScalarAffineTerm(1.0, x[(dest-1)*num_edges + edge_idx]))\n                end\n            end\n            if haskey(incoming, node)\n                for edge_idx in incoming[node]\n                    push!(terms, MOI.ScalarAffineTerm(-1.0, x[(dest-1)*num_edges + edge_idx]))\n                end\n            end\n            if node == dest\n                rhs = -sum(net_data.travel_demand[:, dest])\n            elseif node <= num_zones\n                rhs = net_data.travel_demand[node, dest]\n            else\n                rhs = 0.0\n            end\n            MOI.add_constraint(optimizer,\n                             MOI.ScalarAffineFunction(terms, 0.0),\n                             MOI.EqualTo(rhs))\n        end\n    end\n    for edge_idx in 1:num_edges\n        terms = [MOI.ScalarAffineTerm(1.0, x_agg[edge_idx])]\n        for dest in 1:num_zones\n            push!(terms, MOI.ScalarAffineTerm(-1.0, x[(dest-1)*num_edges + edge_idx]))\n        end\n        MOI.add_constraint(optimizer,\n                         MOI.ScalarAffineFunction(terms, 0.0),\n                         MOI.EqualTo(0.0))\n    end\n    max_flow = 1.5 * sum(net_data.travel_demand)\n    for (y_idx, edge) in enumerate(removed_edges)\n        edge_idx = edge_dict[edge]\n        for dest in 1:num_zones\n            var_idx = (dest - 1) * num_edges + edge_idx\n            if use_big_m\n                terms = [\n                    MOI.ScalarAffineTerm(1.0, x[var_idx]),\n                    MOI.ScalarAffineTerm(-max_flow, y[y_idx])\n                ]\n                MOI.add_constraint(optimizer,\n                                 MOI.ScalarAffineFunction(terms, 0.0),\n                                 MOI.LessThan(0.0))\n            else\n                indicator_func = MOI.VectorAffineFunction(\n                    [\n                        MOI.VectorAffineTerm(1, MOI.ScalarAffineTerm(1.0, y[y_idx])),\n                        MOI.VectorAffineTerm(2, MOI.ScalarAffineTerm(1.0, x[var_idx]))\n                    ],\n                    [0.0, 0.0]\n                )\n                MOI.add_constraint(optimizer, indicator_func,\n                                 MOI.Indicator{MOI.ACTIVATE_ON_ZERO}(MOI.EqualTo(0.0)))\n            end\n        end\n    end\n    return optimizer, edge_list\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR (Bureau of Public Roads) travel time function and gradient (for MOI-based LMO)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This function builds the objective function and gradient for the MOI-based approach. The objective function computes:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR travel time: t = t0 * (flow + b * flow^(power+1) / capacity^power / (power+1))\nDesign cost: sum of costperedge[i] * y[i] for each restored edge","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The gradient function computes derivatives of the objective with respect to:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Aggregate flows: d/d(flow) of BPR function\nDesign variables: costperedge[i] for each restored edge","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function build_objective_and_gradient(net_data, removed_edges, cost_per_edge)\n    num_zones = net_data.num_zones\n    num_edges = net_data.num_edges\n    num_removed = length(removed_edges)\n    function f(x)\n        x = max.(x, 0.0)\n        total = 0.0\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            total += t0 * (flow + b * flow^(p + 1) / cap^p / (p + 1))\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            total += cost_per_edge[i] * x[design_start + i - 1]\n        end\n        return total\n    end\n    function grad!(storage, x)\n        x = max.(x, 0.0)\n        fill!(storage, 0.0)\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            storage[agg_start + i - 1] = t0 * (1 + b * flow^p / cap^p)\n        end\n        for dest in 1:num_zones\n            for edge in 1:num_edges\n                storage[(dest - 1) * num_edges + edge] = storage[agg_start + edge - 1]\n            end\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            storage[design_start + i - 1] = cost_per_edge[i]\n        end\n        return storage\n    end\n    return f, grad!\nend","category":"page"},{"location":"examples/docs-01-network-design/#Calling-Boscia-on-the-MOI-formulation","page":"Network Design Problem","title":"Calling Boscia on the MOI formulation","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Define potentially purchasable edges (edges that need design decision).","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"removed_edges = [(4, 5)]  # Optional edge from node_1 (intermediate node 4) to node_2 (intermediate node 5)\ncost_per_edge = [0.5]  # Cost to purchase the edge\n\nnet_data = load_braess_network()\noptimizer, _ = build_moi_model(net_data, removed_edges, true)\nlmo_moi = FrankWolfe.MathOptLMO(optimizer)\n\nf_moi, grad_moi! = build_objective_and_gradient(net_data, removed_edges, cost_per_edge)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This problem does not require any particular settings. We only enable the logs and run with the default settings.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"settings_moi = Boscia.create_default_settings()\nsettings_moi.branch_and_bound[:verbose] = true\n\nx_moi, _, result_moi = Boscia.solve(f_moi, grad_moi!, lmo_moi, settings=settings_moi)","category":"page"},{"location":"examples/docs-01-network-design/#Penalty-formulation-and-custom-LMO","page":"Network Design Problem","title":"Penalty formulation and custom LMO","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The LMO of the previous formulation is computationally expensive due to the linking constraints. Also, we cannot really exploit the network structure. Thus, Sharma et al. introduce a penalty formulation adding the linking constraints to the objective.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"mu sum_z in mathcalZ sum_e in mathcalR max(x_e^z - M^z y_e 0)^p","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The advantage of this formulation is that we can separate the LMO call for flow variables x and design variables y. On the other hand, we have estimate mu to solve the problem exactly. The LMO for the flow variables implements a shortest path algorithm. As for the design space mathcalY, we assume it is simply the hypercube.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"We create a custom LMO for the penalty formulation. The bound management will be handled by Boscia itself, so we only need to implement the bounded_compute_extreme_point and is_simple_linear_feasible methods.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"struct ShortestPathLMO <: FrankWolfe.LinearMinimizationOracle\n    graph::Graphs.SimpleDiGraph{Int}\n    net_data::NetworkData\n    link_dic::SparseMatrixCSC{Int, Int}\n    edge_list::Vector{Tuple{Int, Int}}\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Add demand to flow vector following shortest path","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function add_demand_to_path!(x, demand, state, origin, destination, link_dic, edge_list, num_zones)\n    current = destination\n    parent = -1\n    edge_count = length(edge_list)\n    agg_start = edge_count * num_zones\n\n    while parent != origin && origin != destination && current != 0\n        parent = state.parents[current]\n        if parent != 0\n            link_idx = link_dic[parent, current]\n            if link_idx != 0\n                x[(destination - 1) * edge_count + link_idx] += demand\n                x[agg_start + link_idx] += demand\n            end\n        end\n        current = parent\n    end\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"All-or-nothing assignment: route all flow on shortest paths","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function all_or_nothing_assignment(travel_time_vector, net_data, graph, link_dic, edge_list)\n    num_zones = net_data.num_zones\n    edge_count = net_data.num_edges\n    travel_time = travel_time_vector[num_zones * edge_count + 1 : (num_zones + 1) * edge_count]\n    x = zeros(length(travel_time_vector))\n\n    for origin in 1:num_zones\n        state = Graphs.dijkstra_shortest_paths(graph, origin)\n\n        for destination in 1:num_zones\n            demand = net_data.travel_demand[origin, destination]\n            if demand > 0\n                add_demand_to_path!(x, demand, state, origin, destination,\n                                  link_dic, edge_list, num_zones)\n            end\n        end\n    end\n\n    return x\nend\n\nfunction Boscia.bounded_compute_extreme_point(lmo::ShortestPathLMO, direction,\n                                               lower_bounds, upper_bounds, int_vars)\n    x = all_or_nothing_assignment(direction, lmo.net_data, lmo.graph,\n                                  lmo.link_dic, lmo.edge_list)\n    for (i, var_idx) in enumerate(int_vars)\n        if direction[var_idx] < 0\n            x[var_idx] = upper_bounds[i]\n        else\n            x[var_idx] = lower_bounds[i]\n        end\n    end\n    return x\nend\n\nfunction Boscia.is_simple_linear_feasible(lmo::ShortestPathLMO, x)\n    num_zones = lmo.net_data.num_zones\n    num_edges = lmo.net_data.num_edges\n    return all(x .>= -1e-6)\nend","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR objective WITH penalty terms for linking constraints (for Custom LMO)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This function builds the objective function and gradient for the Custom LMO approach. Since the shortest-path oracle cannot enforce linking constraints x[dest,edge] <= M * y[edge] as hard constraints, we add penalty terms to the objective function to discourage violations.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The objective function computes:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"BPR travel time: t = t0 * (flow + b * flow^(power+1) / capacity^power / (power+1))\nDesign cost: sum of costperedge[i] * y[i] for each restored edge\nPenalty terms: penaltyweight * sumi sumdest max(0, x[dest,removededgei] - M * y[i])^penaltyexponent","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"The gradient function computes derivatives of the objective with respect to:","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Aggregate flows: d/d(flow) of BPR function + penalty gradient w.r.t. flows\nDesign variables: costperedge[i] + penalty gradient w.r.t. design variables","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"function build_objective_and_gradient_with_penalty(net_data, removed_edges, cost_per_edge,\n                                                    penalty_weight=1e6, penalty_exponent=2.0)\n    num_zones = net_data.num_zones\n    num_edges = net_data.num_edges\n    num_removed = length(removed_edges)\n    edge_list = [(net_data.init_nodes[i], net_data.term_nodes[i]) for i in 1:num_edges]\n    removed_edge_indices = [findfirst(e -> e == removed_edge, edge_list)\n                            for removed_edge in removed_edges]\n    max_flow = 1.5 * sum(net_data.travel_demand)\n    function f(x)\n        x = max.(x, 0.0)\n        total = 0.0\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            total += t0 * (flow + b * flow^(p + 1) / cap^p / (p + 1))\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            total += cost_per_edge[i] * x[design_start + i - 1]\n        end\n        for (y_idx, edge_idx) in enumerate(removed_edge_indices)\n            if edge_idx !== nothing\n                y_val = x[design_start + y_idx - 1]\n                for dest in 1:num_zones\n                    flow_idx = (dest - 1) * num_edges + edge_idx\n                    flow_val = x[flow_idx]\n                    violation = max(0.0, flow_val - max_flow * y_val)\n                    total += penalty_weight * violation^penalty_exponent\n                end\n            end\n        end\n        return total\n    end\n    function grad!(storage, x)\n        x = max.(x, 0.0)\n        fill!(storage, 0.0)\n        agg_start = num_zones * num_edges + 1\n        agg_end = num_zones * num_edges + num_edges\n        x_agg = @view x[agg_start:agg_end]\n        for i in 1:num_edges\n            flow = x_agg[i]\n            t0 = net_data.free_flow_time[i]\n            b = net_data.b[i]\n            cap = net_data.capacity[i]\n            p = net_data.power[i]\n            storage[agg_start + i - 1] = t0 * (1 + b * flow^p / cap^p)\n        end\n        for dest in 1:num_zones\n            for edge in 1:num_edges\n                storage[(dest - 1) * num_edges + edge] = storage[agg_start + edge - 1]\n            end\n        end\n        design_start = num_zones * num_edges + num_edges + 1\n        for i in 1:num_removed\n            storage[design_start + i - 1] = cost_per_edge[i]\n        end\n        for (y_idx, edge_idx) in enumerate(removed_edge_indices)\n            if edge_idx !== nothing\n                y_val = x[design_start + y_idx - 1]\n                for dest in 1:num_zones\n                    flow_idx = (dest - 1) * num_edges + edge_idx\n                    flow_val = x[flow_idx]\n                    violation = max(0.0, flow_val - max_flow * y_val)\n                    if violation > 1e-10\n                        grad_coeff = penalty_weight * penalty_exponent * violation^(penalty_exponent - 1)\n                        storage[flow_idx] += grad_coeff\n                        storage[design_start + y_idx - 1] += grad_coeff * (-max_flow)\n                    end\n                end\n            end\n        end\n        return storage\n    end\n    return f, grad!\nend","category":"page"},{"location":"examples/docs-01-network-design/#Calling-Boscia-on-the-penalty-formulation","page":"Network Design Problem","title":"Calling Boscia on the penalty formulation","text":"","category":"section"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"penalty_weight = 1e3\npenalty_exponent = 1.5","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Generate the graph structure.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"graph = Graphs.SimpleDiGraph(net_data.num_nodes)\nedge_list_custom = Tuple{Int,Int}[]\nfor i in 1:net_data.num_edges\n    Graphs.add_edge!(graph, net_data.init_nodes[i], net_data.term_nodes[i])\n    push!(edge_list_custom, (net_data.init_nodes[i], net_data.term_nodes[i]))\nend\n\nlink_dic = sparse(net_data.init_nodes, net_data.term_nodes,\n                 collect(1:net_data.num_edges))\n\ncustom_lmo = ShortestPathLMO(graph, net_data, link_dic, edge_list_custom)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"Set the bounds for the binary variables.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"num_zones = net_data.num_zones\nnum_edges = net_data.num_edges\nnum_removed = length(removed_edges)\ntotal_vars = num_zones * num_edges + num_edges + num_removed\n\nint_vars = collect((num_zones * num_edges + num_edges + 1):total_vars) # last num_removed variables\nlower_bounds = zeros(Float64, num_removed)  # Binary: lower bound = 0\nupper_bounds = ones(Float64, num_removed)   # Binary: upper bound = 1","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"To have Boscia handle the bounds, we need to wrap our LMO in an instance of ManagedLMO.","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"bounded_lmo = Boscia.ManagedLMO(custom_lmo, lower_bounds, upper_bounds, int_vars, total_vars)\n\nf_custom, grad_custom! = build_objective_and_gradient_with_penalty(net_data, removed_edges, cost_per_edge,\n                                                      penalty_weight, penalty_exponent)\n\nsettings_custom = Boscia.create_default_settings()\nsettings_custom.branch_and_bound[:verbose] = true\n\nx_custom, _, result_custom = Boscia.solve(f_custom, grad_custom!, bounded_lmo, settings=settings_custom)","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"","category":"page"},{"location":"examples/docs-01-network-design/","page":"Network Design Problem","title":"Network Design Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/docs-03-optimal-design/#Optimal-Design-of-Experiments","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Given a large set of experiments, the Optimal Design of Experiments (OEDP) problem aims to select a subset of experiments that maximizes the information gain. Formally, we are given a experiment matrix A in mathbbR^m times n encoding the experiments data where m denotes the number of experiments, n denotes the number of parameters and generally m gg n. To quantify information, we utilize the Fisher information matrix defined as:","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"X(x) = A * textdiag(x) * A","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"where x in mathbbZ^n is the design vector. There exist multiple information measures, i.e. a function that maps the Fisher information matrix to a real number, for a comprehensive overview, see the book by Friedrich Pukelsheim titled \"Optimal Design of Experiments\". For this example, we consider the A-criterion and D-criterion.","category":"page"},{"location":"examples/docs-03-optimal-design/#Imports-and-problem-setup","page":"Optimal Design of Experiments","title":"Imports and problem setup","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"We start by generating the experiment matrix A randomly.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"using Boscia\nusing Random\nusing Distributions\nusing LinearAlgebra\nusing FrankWolfe\nusing Statistics\nusing Test\nusing StableRNGs\n\nprintln(\"\\nDocumentation Example 03: Optimal Design of Experiments\")\n\nseed = rand(UInt64)\n@show seed  #seed = 0x7be8a16f815cd122\nrng = StableRNG(seed)\n\nm = 50\nn = Int(floor(m / 10))\nN = round(Int, 1.5 * n)\n\nB = rand(rng, m, n)\nB = B' * B\n@assert isposdef(B)\nconst D = MvNormal(randn(rng, n), B)\n\nconst A = rand(D, m)'\n@assert rank(A) == n","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Next, we define the two criteria and their gradients. The A-criterion is defined as:","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"f_a(x) = textTrleft(X(x)^-1right)","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"so the trace of the inverse of the Fisher information matrix.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function f_a(x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X)\n    U = cholesky(X)\n    X_inv = U \\ I\n    return LinearAlgebra.tr(X_inv)\nend\n\nfunction grad_a!(storage, x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X * X)\n    F = cholesky(X)\n    for i in 1:length(x)\n        storage[i] = LinearAlgebra.tr(-(F \\ A[i, :]) * transpose(A[i, :]))\n    end\n    return storage\nend","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"The D-criterion is defined as:","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"f_d(x) = -log(det(X(x)))","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function f_d(x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X)\n    return float(-log(det(X)))\nend\n\nfunction grad_d!(storage, x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X)\n    F = cholesky(X)\n    for i in 1:length(x)\n        storage[i] = LinearAlgebra.tr(-(F \\ A[i, :]) * transpose(A[i, :]))\n    end\n    return storage\nend","category":"page"},{"location":"examples/docs-03-optimal-design/#Issue:-Restricted-function-domain","page":"Optimal Design of Experiments","title":"Issue: Restricted function domain","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"The feasible region is a scaled and truncated probability simplex.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Delta = leftx in mathbbR^n 0 leq x leq u sum_i=1^n x_i = Nright","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"where N is the budget and u are upper bounds.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"An issue arising in OEDP is that the objective functions and their gradients are not well defined over the entire feasible region. Note that for both the A-criterion and D-criterion, the associated Fisher information matrix has to be positive definite. Thus, we cannot start Boscia, and by extension Frank-Wolfe, at an arbitrary start point. Additionally, we have to be careful not to leave the domain during computation of the step size for Frank-Wolfe in the line search. To address this problem, we first need to define a domain oracle that given a point x returns true if x is feasible. There are different ways to check domain feasibility, we choose to test if the minimum eigenvalue i strictly positive (up to numerical tolerance).","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"ub = floor(N/3)\nu = rand(rng, 1.0:ub, m)\nsimplex_lmo = Boscia.ProbabilitySimplexLMO(N)\nlmo = Boscia.ManagedLMO(simplex_lmo, fill(0.0, m), u, collect(1:m), m)\n\nfunction domain_oracle(x)\n    X = transpose(A) * diagm(x) * A\n    X = Symmetric(X)\n    #return LinearAlgebra.isposdef(X)\n    return minimum(eigvals(X)) > sqrt(eps())\nend","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Next, we have to ensure that the start points of the child nodes are also domain feasible. Observe that the vertices in the active set are not necessarily domain feasible. Therefore, while branching, we can have initial points that are not domain feasible. To address this, we need to define a domain point function that given the current node bounds returns a domain feasible point respecting the bounds, if possible. For OEDP, we start by setting x equal to the current lower bounds and finding n linearly independent rows of A. If x does not yet satisfy the knapsack constraint, we increase the values of X, first by sampling from the linearly independent rows and then by adding 1 to the smallest value of x while respecting the upper bounds u.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function linearly_independent_rows(A; u=fill(1, size(A, 1)))\nS = []\nm, n = size(A)\nfor i in 1:m\n    if iszero(u[i])\n        continue\n    end\n    S_i = vcat(S, i)\n    if rank(A[S_i, :]) == length(S_i)\n        S = S_i\n    end\n    if length(S) == n # we only n linearly independent points\n        return S\n    end\nend\nreturn S # then x= zeros(m) and x[S] = 1\nend\nfunction add_to_min(x, u)\nperm = sortperm(x)\nfor i in perm\n    if x[i] < u[i]\n        x[i] += 1\n        break\n    end\nend\nreturn x\nend\nfunction domain_point(local_bounds)\n    lb = fill(0.0, m)\n    ub = copy(u)\n    x = zeros(m)\n    for idx in 1:m\n        if haskey(local_bounds.lower_bounds, idx)\n            lb[idx] = max(0.0, local_bounds.lower_bounds[idx])\n        end\n        if haskey(local_bounds.upper_bounds, idx)\n            ub[idx] = min(u[idx], local_bounds.upper_bounds[idx])\n        end\n    end\n    if sum(lb) > N\n        return nothing\n    end\n    if !domain_oracle(ub)\n        return nothing\n    end\n    x = lb\n    S = linearly_independent_rows(A, u=(.!(iszero.(ub))))\n    while sum(x) <= N\n        if sum(x) == N\n            if domain_oracle(x)\n                return x\n            else\n                @warn \"Domain feasible point not found.\"\n                return nothing\n            end\n        end\n        if !iszero(x[S] - ub[S])\n            y = add_to_min(x[S], ub[S])\n            x[S] = y\n        else\n            x = add_to_min(x, ub)\n        end\n    end\n    return x\nend","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Note that the domain point function does not necessarily has to return an integral feasible point. The generated point is used to solve a projection problem over the feasible region to move the current iterate into the domain. To that end, the generated point should not be at the boundary of the domain as this can lead to numerical issues later in the node solve.","category":"page"},{"location":"examples/docs-03-optimal-design/#Generating-the-initial-start-point","page":"Optimal Design of Experiments","title":"Generating the initial start point","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"We can use the same principal Boscia uses to generate domain feasible starting points for the child nodes to generate an initial start point. To this end, we use the find_domain_point function to generate a domain feasible point respecting the bounds. The projection problem can be solved using Frank-Wolfe. Note that Boscia expects the initial point to be given via an active set.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"initial_bounds = Boscia.IntegerBounds(fill(0.0, m), u, collect(1:m))\nx0 = domain_point(initial_bounds)\nf_help(x) = 1 / 2 * LinearAlgebra.norm(x - x0)^2\ngrad_help!(storage, x) = storage .= x - x0","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"We do not need to solve this problem to optimality. However, we do not want to stop as soon as we reach the domain because this can lead to numerical issues later in the node solve. Therefore, we count the iteration after entering the domain and stop if we have not found a feasible point after 5 iterations.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"function build_inner_callback()\n    domain_counter = 0\n    return function inner_callback(state, active_set, kwargs...)\n        if domain_oracle(state.x)\n            if domain_counter > 10\n                return false\n            end\n            domain_counter += 1\n        end\n    end\nend\n\ninner_callback = build_inner_callback()\nv0 = compute_extreme_point(lmo, collect(1.0:m))\n\n_, _, _, _, _, _, active_set = FrankWolfe.blended_pairwise_conditional_gradient(\n    f_help,\n    grad_help!,\n    lmo,\n    v0,\n    callback=inner_callback,\n    lazy=true,\n)","category":"page"},{"location":"examples/docs-03-optimal-design/#Calling-Boscia","page":"Optimal Design of Experiments","title":"Calling Boscia","text":"","category":"section"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"Now we have everything set up and ready to use Boscia to solve the problem. As line search, we use the Secant method which receives the domain oracle as input. We also set some heuristics to be used during the node solve by specifying a probability for each heuristic.","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"settings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = true\nsettings.domain[:active_set] = copy(active_set) # this will be overwritten by Boscia during the solve\nsettings.domain[:domain_oracle] = domain_oracle\nsettings.domain[:find_domain_point] = domain_point\nsettings.domain[:depth_domain] = 10\nsettings.heuristic[:hyperplane_aware_rounding_prob] = 0.7\nsettings.heuristic[:rounding_lmo_01_prob] = 0.5\nsettings.frank_wolfe[:line_search] = FrankWolfe.Secant(domain_oracle=domain_oracle)\nsettings.frank_wolfe[:lazy] = true\n\nx_a, _, _ = Boscia.solve(f_a, grad_a!, lmo, settings=settings)\n\n\nsettings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = true\nsettings.domain[:active_set] = copy(active_set)\nsettings.domain[:domain_oracle] = domain_oracle\nsettings.domain[:find_domain_point] = domain_point\nsettings.domain[:depth_domain] = 10\nsettings.heuristic[:hyperplane_aware_rounding_prob] = 0.7\nsettings.heuristic[:rounding_lmo_01_prob] = 0.5\nsettings.frank_wolfe[:line_search] = FrankWolfe.Secant(domain_oracle=domain_oracle)\nsettings.frank_wolfe[:lazy] = true\n\nx_d, _, _ = Boscia.solve(f_d, grad_d!, lmo, settings=settings)","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"","category":"page"},{"location":"examples/docs-03-optimal-design/","page":"Optimal Design of Experiments","title":"Optimal Design of Experiments","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"This section contain some utility function ","category":"page"},{"location":"reference/utilities/#Bonobo.terminated-Tuple{Bonobo.BnBTree{var\"#s1029\", Root, Value, Solution} where {var\"#s1029\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s1029\", Value}}}","page":"Utilities","title":"Bonobo.terminated","text":"Checks if the branch and bound can be stopped. By default (in Bonobo) stops then the priority queue is empty. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.build_active_set_by_domain_oracle-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Boscia.IntegerBounds, Any}} where {T, R}","page":"Utilities","title":"Boscia.build_active_set_by_domain_oracle","text":"Build a new start point and active set in case the split active set does not lead to a domain feasible iterate. First, try filtering the active set by the domain oracle. If all vertices are domain infeasible, solve the projection problem 1/2 * ||x - x||_2^2  where x is a domain- and bound-feasible point provided by the user.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.check_feasibility-Tuple{Boscia.TimeTrackingLMO}","page":"Utilities","title":"Boscia.check_feasibility","text":"Check feasibility and boundedness\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.has_integer_constraint-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.has_integer_constraint","text":"Check if at a given index we have an integer constraint respectivily.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_bound_feasible-Tuple{Boscia.IntegerBounds, Any}","page":"Utilities","title":"Boscia.is_bound_feasible","text":"Check if a given point v satisfies the given bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.is_valid_split","text":"Check wether a split is valid. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.min_via_enum","page":"Utilities","title":"Boscia.min_via_enum","text":"Naive optimization by enumeration. Default uses binary values. Otherwise, third argument should be a vector of n sets of possible values for the variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Boscia.relative_gap-Tuple{Any, Any}","page":"Utilities","title":"Boscia.relative_gap","text":"Compute relative gap consistently everywhere\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.restart_active_set-Tuple{Boscia.FrankWolfeNode, LinearMinimizationOracle, Int64}","page":"Utilities","title":"Boscia.restart_active_set","text":"Call this if the active set is empty after splitting. Remark: This should not happen when using a MIP solver for the nodes!\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Int64, Boscia.IntegerBounds}} where {T, R}","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split an active set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{T}, Tuple{FrankWolfe.DeletedVertexStorage{T}, Any, Int64, Any, Boscia.IntegerBounds}} where T","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split a discarded vertices set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.trivial_build_dicg_start_point-Tuple{LinearMinimizationOracle}","page":"Utilities","title":"Boscia.trivial_build_dicg_start_point","text":"Default starting point function which generates a random vertex\n\n\n\n\n\n","category":"method"},{"location":"#Boscia.jl","page":"Home","title":"Boscia.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Dev) (Image: Stable) (Image: Coverage) (Image: DOI) (Image: Aqua QA)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A solver for Mixed-Integer Convex Optimization that uses Frank-Wolfe methods for convex relaxations and a branch-and-bound algorithm.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Boscia.jl solver combines (a variant of) the Frank-Wolfe algorithm with a branch-and-bound-like algorithm to solve mixed-integer convex optimization problems of the form min_x  C x_I  mathbbZ^n f(x), where f is a differentiable convex function, C is a convex and compact set, and I is a set of indices of integral variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approach is especially effective when we have a method to optimize a linear function over C and the integrality constraints in a computationally efficient way. The set C can modelled using the Julia package MathOptInterface (or JuMP).  We also implemented simple polytopes like the hypercube, the unit simplex and the probability simplex. Also, we intend to extend this list by combinatorial polytopes, e.g. the matching polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The paper presenting the package with mathematical explanations and numerous examples can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convex mixed-integer optimization with Frank-Wolfe methods: 2208.11010","category":"page"},{"location":"","page":"Home","title":"Home","text":"Boscia.jl uses FrankWolfe.jl for solving the convex subproblems, Bonobo.jl for managing the search tree, and oracles optimizing linear functions over the feasible set, for instance calling SCIP or any MOI-compatible solver to solve MIP subproblems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add the Boscia stable release with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Boscia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or get the latest master branch with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/ZIB-IOL/Boscia.jl\", rev=\"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the installation of SCIP.jl, see here. Note, for Windows users, you do not need to download the SCIP binaries, you can also use the installer provided by SCIP.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example to get started. For more examples, see the examples folder in the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Boscia\nusing FrankWolfe\nusing Random\nusing SCIP\nusing LinearAlgebra\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nn = 6\n\nconst diffw = 0.5 * ones(n)\no = SCIP.Optimizer()\n\nMOI.set(o, MOI.Silent(), true)\n\nx = MOI.add_variables(o, n)\n\nfor xi in x\n    MOI.add_constraint(o, xi, MOI.GreaterThan(0.0))\n    MOI.add_constraint(o, xi, MOI.LessThan(1.0))\n    MOI.add_constraint(o, xi, MOI.ZeroOne())\nend\n\nlmo = FrankWolfe.MathOptLMO(o)\n\nfunction f(x)\n    return sum(0.5*(x.-diffw).^2)\nend\n\nfunction grad!(storage, x)\n    @. storage = x-diffw\nend\n\nsettings = Boscia.create_default_settings()\nsettings.branch_and_bound[:verbose] = true\nx, _, result = Boscia.solve(f, grad!, lmo, settings=settings)\n\nBoscia Algorithm.\n\nParameter settings.\n\t Tree traversal strategy: Move best bound\n\t Branching strategy: Most infeasible\n\t FrankWolfe variant: Blended Pairwise Conditional Gradient\n\t Line Search Method: Secant\n\t Lazification: true\n\t Lazification Tolerance: 2\n\t Absolute dual gap tolerance: 1.000000e-06\n\t Relative dual gap tolerance: 1.000000e-02\n\t Frank-Wolfe subproblem tolerance: 1.000000e-02\n\t Frank-Wolfe dual gap decay factor: 8.000000e-01\n\t Additional kwargs: \n\t Total number of variables: 6\n\t Number of integer variables: 6\n\n\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n   Iter  Open          Bound      Incumbent      Gap (abs)      Gap (rel)       Time (s)      Nodes/sec      FW (ms)   LMO (ms)  LMO (calls c)   FW (its) #activeset  #shadow\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n*     1     2   0.000000e+00   7.500000e-01   7.500000e-01            Inf   2.000000e-03   1.500000e+03            1          1              4          2        1        0\n    100    27   6.250000e-01   7.500000e-01   1.250000e-01   2.000000e-01   6.400000e-02   1.984375e+03            0          0            326          0        1        0\n    127     0   7.500000e-01   7.500000e-01   0.000000e+00   0.000000e+00   7.300000e-02   1.739726e+03            0          0            380          0        1        0\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nSolution Statistics.\n\t Solution Status: Optimal (tree empty)\n\t Primal Objective: 0.75\n\t Dual Bound: 0.75\n\t Dual Gap (relative): 0.0\n\nSearch Statistics.\n\t Total number of nodes processed: 127\n\t Total number of lmo calls: 380\n\t Total time (s): 0.074\n\t LMO calls / sec: 5135.135135135135\n\t Nodes / sec: 1716.2162162162163\n\t LMO calls / node: 2.9921259842519685\n\n\t Total number of global tightenings: 0\n\t Global tightenings / node: 0.0\n\t Total number of local tightenings: 0\n\t Local tightenings / node: 0.0\n\t Total number of potential local tightenings: 0","category":"page"}]
}
