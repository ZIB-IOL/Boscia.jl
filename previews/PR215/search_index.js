var documenterSearchIndex = {"docs":
[{"location":"reference/custom/#Branch-and-Bound-Tree-functionality","page":"Branch and Bound Tree functionality","title":"Branch and Bound Tree functionality","text":"","category":"section"},{"location":"reference/custom/","page":"Branch and Bound Tree functionality","title":"Branch and Bound Tree functionality","text":"This section contains the customization of the branch-and-bound implementation of Bonobo.jl.","category":"page"},{"location":"reference/custom/#Custom-Bonobo","page":"Branch and Bound Tree functionality","title":"Custom Bonobo","text":"","category":"section"},{"location":"reference/custom/","page":"Branch and Bound Tree functionality","title":"Branch and Bound Tree functionality","text":"Modules = [Boscia]\nPages = [\"custom_bonobo.jl\"]","category":"page"},{"location":"reference/custom/#Bonobo.optimize!-Tuple{Bonobo.BnBTree{var\"#s19\", Root, Value, Solution} where {var\"#s19\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s19\", Value}}}","page":"Branch and Bound Tree functionality","title":"Bonobo.optimize!","text":"optimize!(tree::BnBTree; callback=(args...; kwargs...)->())\n\nOptimize the problem using a branch and bound approach.  The steps, repeated until terminated is true, are the following:\n\n# 1. get the next open node depending on the traverse strategy\nnode = get_next_node(tree, tree.options.traverse_strategy)\n# 2. evaluate the current node and return the lower and upper bound\n# if the problem is infeasible both values should be set to NaN\nlb, ub = evaluate_node!(tree, node)\n# 3. update the upper and lower bound of the node struct\nset_node_bound!(tree.sense, node, lb, ub)\n# 4. update the best solution\nupdated = update_best_solution!(tree, node)\nupdated && bound!(tree, node.id)\n# 5. remove the current node\nclose_node!(tree, node)\n# 6. compute the node children and adds them to the tree\n# internally calls get_branching_variable and branch_on_variable!\nbranch!(tree, node)\n\nA callback function can be provided which will be called whenever a node is closed. It always has the arguments tree and node and is called after the node is closed.  Additionally the callback function must accept additional keyword arguments (kwargs)  which are set in the following ways:\n\nIf the node is infeasible the kwarg node_infeasible is set to true.\nIf the node has a higher lower bound than the incumbent the kwarg worse_than_incumbent is set to true.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Integer-Bounds","page":"Branch and Bound Tree functionality","title":"Integer Bounds","text":"","category":"section"},{"location":"reference/custom/","page":"Branch and Bound Tree functionality","title":"Branch and Bound Tree functionality","text":"Modules = [Boscia]\nPages = [\"integer_bounds.jl\"]","category":"page"},{"location":"reference/custom/#Boscia.IntegerBounds","page":"Branch and Bound Tree functionality","title":"Boscia.IntegerBounds","text":"IntegerBounds\n\nKeeps track of the bounds of the integer (binary) variables.\n\nlower_bounds dictionary of Float64, index is the key. upper_bounds dictionary of Float64, index is the key.\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Problem","page":"Branch and Bound Tree functionality","title":"Problem","text":"","category":"section"},{"location":"reference/custom/","page":"Branch and Bound Tree functionality","title":"Branch and Bound Tree functionality","text":"Modules = [Boscia]\nPages = [\"problem.jl\"]","category":"page"},{"location":"reference/custom/#Boscia.SimpleOptimizationProblem","page":"Branch and Bound Tree functionality","title":"Boscia.SimpleOptimizationProblem","text":"Represents an optimization problem of the form:\n\nmin_x f(x)\ns.t.  x ∈ X (given by the LMO)\n      x_j ∈ Z ∀ j in integer_variables\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Boscia.Solve_Stage","page":"Branch and Bound Tree functionality","title":"Boscia.Solve_Stage","text":"Enum for the solving stage\n\n\n\n\n\n","category":"type"},{"location":"reference/custom/#Bonobo.get_branching_indices-Tuple{Boscia.SimpleOptimizationProblem}","page":"Branch and Bound Tree functionality","title":"Bonobo.get_branching_indices","text":"Returns the indices of the discrete variables for the branching in Bonobo.BnBTree\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia._trivial_domain-Tuple{Any}","page":"Branch and Bound Tree functionality","title":"Boscia._trivial_domain","text":"Trivial domain function.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia._trivial_domain_point-Tuple{Boscia.IntegerBounds}","page":"Branch and Bound Tree functionality","title":"Boscia._trivial_domain_point","text":"Trivial domain point function.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.indicator_present-Tuple{Boscia.TimeTrackingLMO}","page":"Branch and Bound Tree functionality","title":"Boscia.indicator_present","text":"Are indicator constraints present\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_integer_feasible-Tuple{AbstractVector{<:Integer}, AbstractVector}","page":"Branch and Bound Tree functionality","title":"Boscia.is_integer_feasible","text":"Checks if a given vector is valid integral solution. Specifically for mixed problems.\n\n\n\n\n\n","category":"method"},{"location":"reference/custom/#Boscia.is_linear_feasible-Tuple{Boscia.TimeTrackingLMO, AbstractVector}","page":"Branch and Bound Tree functionality","title":"Boscia.is_linear_feasible","text":"Checks if x is valid for all linear and variable bound constraints \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"This section contain some utility function ","category":"page"},{"location":"reference/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [Boscia]\nPages = [\"utilities.jl\"]","category":"page"},{"location":"reference/utilities/#Bonobo.terminated-Tuple{Bonobo.BnBTree{var\"#s467\", Root, Value, Solution} where {var\"#s467\"<:Boscia.FrankWolfeNode, Root, Value, Solution<:Bonobo.AbstractSolution{var\"#s467\", Value}}}","page":"Utilities","title":"Bonobo.terminated","text":"Checks if the branch and bound can be stopped. By default (in Bonobo) stops then the priority queue is empty. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.build_active_set_by_domain_oracle-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Boscia.IntegerBounds, Any}} where {T, R}","page":"Utilities","title":"Boscia.build_active_set_by_domain_oracle","text":"Build a new start point and active set in case the split active set does not lead to a domain feasible iterate. First, try filtering the active set by the domain oracle. If all vertices are domain infeasible, solve the projection problem 1/2 * ||x - x||_2^2  where x is a domain- and bound-feasible point provided by the user.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.check_feasibility-Tuple{Boscia.TimeTrackingLMO}","page":"Utilities","title":"Boscia.check_feasibility","text":"Check feasibility and boundedness\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.has_integer_constraint-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.has_integer_constraint","text":"Check if at a given index we have an integer constraint respectivily.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_bound_feasible-Tuple{Boscia.IntegerBounds, Any}","page":"Utilities","title":"Boscia.is_bound_feasible","text":"Check if a given point v satisfies the given bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Int64}","page":"Utilities","title":"Boscia.is_valid_split","text":"Check wether a split is valid. \n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.min_via_enum","page":"Utilities","title":"Boscia.min_via_enum","text":"Naive optimization by enumeration. Default uses binary values. Otherwise, third argument should be a vector of n sets of possible values for the variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/utilities/#Boscia.relative_gap-Tuple{Any, Any}","page":"Utilities","title":"Boscia.relative_gap","text":"Compute relative gap consistently everywhere\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.restart_active_set-Tuple{Boscia.FrankWolfeNode, FrankWolfe.LinearMinimizationOracle, Int64}","page":"Utilities","title":"Boscia.restart_active_set","text":"Call this if the active set is empty after splitting. Remark: This should not happen when using a MIP solver for the nodes!\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{R}, Tuple{T}, Tuple{FrankWolfe.ActiveSet{T, R}, Any, Int64, Boscia.IntegerBounds}} where {T, R}","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split an active set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/utilities/#Boscia.split_vertices_set!-Union{Tuple{T}, Tuple{FrankWolfe.DeletedVertexStorage{T}, Any, Int64, Any, Boscia.IntegerBounds}} where T","page":"Utilities","title":"Boscia.split_vertices_set!","text":"Split a discarded vertices set between left and right children.\n\n\n\n\n\n","category":"method"},{"location":"reference/fw_variant/#Frank-Wolfe-Variant","page":"Frank Wolfe Variant","title":"Frank Wolfe Variant","text":"","category":"section"},{"location":"reference/fw_variant/","page":"Frank Wolfe Variant","title":"Frank Wolfe Variant","text":"Here is the list with the currently supported Frank-Wolfe variants.","category":"page"},{"location":"reference/fw_variant/","page":"Frank Wolfe Variant","title":"Frank Wolfe Variant","text":"Modules = [Boscia]\nPages = [\"frank_wolfe_variants.jl\"]","category":"page"},{"location":"reference/fw_variant/#Boscia.AwayFrankWolfe","page":"Frank Wolfe Variant","title":"Boscia.AwayFrankWolfe","text":"Away-Frank-Wolfe\n\nIn every iteration, it computes the worst performing vertex, called away vertex, in the active set with regard to the gradient. If enough local progress can be made, weight is shifted from the away vertex to all other vertices. \n\nIn case lazification is activated, the FW vertex is only computed if not enough local progress can be guaranteed.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.BPCG","page":"Frank Wolfe Variant","title":"Boscia.BPCG","text":"Blended Pairwise Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.Blended","page":"Frank Wolfe Variant","title":"Boscia.Blended","text":"Blended Conditional Gradient\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.FrankWolfeVariant","page":"Frank Wolfe Variant","title":"Boscia.FrankWolfeVariant","text":"Frank-Wolfe variant used to compute the problems at node level. A FrankWolfeVariant must implement\n\nsolve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\n    added_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace))\n\nIt may also implement build_frank_wolfe_workspace(x) which creates a workspace structure that is passed as last argument to solve_frank_wolfe.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.VanillaFrankWolfe","page":"Frank Wolfe Variant","title":"Boscia.VanillaFrankWolfe","text":"Vanilla-Frank-Wolfe\n\nThe standard variant of Frank-Wolfe. In each iteration, the vertex v minimizing ∇f * (x-v) is computed. \n\nLazification cannot be used in this setting.\n\n\n\n\n\n","category":"type"},{"location":"reference/fw_variant/#Boscia.solve_frank_wolfe","page":"Frank Wolfe Variant","title":"Boscia.solve_frank_wolfe","text":"solve_frank_wolfe(fw::FrankWolfeVariant, f, grad!, lmo, active_set, line_search, epsilon, max_iteration,\nadded_dropped_vertices, use_extra_vertex_storage, callback, lazy, timeout, verbose, workspace)\n\nReturns the optimal solution x to the node problem, its primal and dual gap and the active set. \n\n\n\n\n\n","category":"function"},{"location":"basics/#How-does-it-work?","page":"How does it work?","title":"How does it work?","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Boscia.jl is aimed at mixed-integer convex problems where the nonlinearity stems mostly from the objective function:","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nmin    f(x)  \ntextst   xin C  x_I in mathbbZ^I\nendaligned text where  x in X subset mathbbR  x_I in mathbbZ^I","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where C is a compact, nonconvex set admitting a boundable linear minimization oracle (BLMO), i.e., a set over which optimizing a linear function can be done efficiently (comparatively to the original problem), even when bounds are added or modified.  Taking lower bounds l and upper bounds u, the oracle solves","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"beginaligned\nv in argmin   langle x d rangle \ntextst   xin C \n  x_I in mathbbZ^I cap lu   text where  x in X subset mathbbR  x_I in mathbbZ^I\nendaligned","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"where d will usually be the gradient of f evaluated at a given point x_t, nabla f(x_t).","category":"page"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The new algorithmic framework is a branch-and-bound approach utilizing Frank-Wolfe (FW), also called Conditional Gradient (CG), methods as the node solver. A new aspect is that we solve the continuous sub problems in the nodes over the integer hull, i.e. the convex hull of the integer feasible points. Additionally, we exploit both general properties of the FW methods as well as the recent developments in the field of FW methods to speed up the solution process. ","category":"page"},{"location":"basics/#Frank-Wolfe-variants","page":"How does it work?","title":"Frank-Wolfe variants","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Frank-Wolfe algorithms used in Boscia.jl are implemented in FrankWolfe.jl.  The variants currently available in Boscia.jl are Vanilla Frank-Wolfe, Away-Frank-Wolfe (AFW), Blended Conditional Gradient (BCG) and Blended Pairwise Conditional Gradient (BPCG). The latter is set as the default variant.","category":"page"},{"location":"basics/#Branch-and-Bound-techniques","page":"How does it work?","title":"Branch-and-Bound techniques","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In this section, we present the techniques derived from Frank Wolfe that can be used in our framework .","category":"page"},{"location":"basics/#Dual-gap-based-termination","page":"How does it work?","title":"Dual gap based termination","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Frank-Wolfe methods produce primal feasible iterates and an FW gap, offering many inexpensive iterations with a gradually increasing dual bound.  This allows early termination of nodes when the dual bound reaches the best incumbent's objective value, avoiding unnecessary computations.  Nodes can be stopped anytime to produce a useful dual bound, aiding overall progress.  This flexibility contrasts with other nonlinear solvers, enabling more efficient optimization.","category":"page"},{"location":"basics/#Tree-state-dependent-termination-and-evolving-error","page":"How does it work?","title":"Tree state-dependent termination and evolving error","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"We implement different termination criteria in the node processing to reduce iterations, prioritizing nodes with promising lower bounds.  The dual bound provided by Frank-Wolfe is always valid, even if the dual gap is large. Thus, we solve nodes high in the tree, like the root node, with a coarse precision  and increase the precision with which a node is solved depending on its depth in the tree.  This approach balances efficiency and accuracy in solving optimization problems.","category":"page"},{"location":"basics/#Warm-starting-via-the-active-set","page":"How does it work?","title":"Warm-starting via the active set","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"Many Frank-Wolfe variants provide a so-called active set, the convex combination of vertices representing the solution.  This can be used to warm start the children nodes by partitioning the active set of the parent.","category":"page"},{"location":"basics/#Branching","page":"How does it work?","title":"Branching","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"As default, we use most-infeasible branching which has shown good performance for many problems. Also, implemented are strong branching and the so-called hybrid branching which performs strong branching until a specific depth and afterwards switches to most-infeasible. It should be noted that strong branching is only adviseable for problems with very cheap LMO.  Otherwise, most-infeasible or hybrid branching with a shallow depth is to be preferred.","category":"page"},{"location":"basics/#Dual-fixing-and-tightening","page":"How does it work?","title":"Dual fixing and tightening","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In subproblems where variables are at bounds, our approach utilizes convexity and primal solutions to tighten dual bounds effectively.  Drawing from methods pioneered by Dantzig and extended in various contexts, we leverage Frank-Wolfe methods and FW gaps, adaptable to scenarios without explicit dual solutions, such as those involving MIP-based LMOs. We can also exploit strong convexity and sharpness to tighten the lowerbound of the tree.","category":"page"},{"location":"basics/#The-Bounded-Linear-Minimization-Oracles-(BLMO)","page":"How does it work?","title":"The Bounded Linear Minimization Oracles (BLMO)","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The Bounded Linear Minimization Oracle (BLMO) represent the feasible region C with the integrality constraints and handles the computation of mixed-integer linear sub-problems.  The bound management is also handled by the BLMO.  There are two options for the BLMO.","category":"page"},{"location":"basics/#Mixed-Integer-Linear-Solver-via-JuMP","page":"How does it work?","title":"Mixed Integer Linear Solver via JuMP","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"The first option is a MIP solver like SCIP via the MathOptInterface or JuMP package.  For examples, see the Poisson Regression in poisson_reg.jl, the Sparse Regression with a grouped lasso in lasso.jl. In mps-example.jl, the feasible region is encoded in an MPS file.","category":"page"},{"location":"basics/#Customized-BLMO's","page":"How does it work?","title":"Customized BLMO's","text":"","category":"section"},{"location":"basics/","page":"How does it work?","title":"How does it work?","text":"In addition, we have implemented some specific BLMOs like the hypercube, the probability and unit simplex. For examples, see approx_planted_point.jl'.  Incube_blmo.jl`, there is an example on how to implement Boscia's BLMO interface from scratch.","category":"page"},{"location":"reference/1_algorithms/#Algorithm","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm","title":"Algorithm","text":"This section contains information about interface.jl","category":"page"},{"location":"reference/1_algorithms/#Interface","page":"Algorithm","title":"Interface","text":"","category":"section"},{"location":"reference/1_algorithms/","page":"Algorithm","title":"Algorithm","text":"Modules = [Boscia]\nPages = [\"interface.jl\"]","category":"page"},{"location":"reference/1_algorithms/#Boscia.BLMOStatus","page":"Algorithm","title":"Boscia.BLMOStatus","text":"Enum encoding the status of the Bounded Linear Minimization Oracle.\n\n\n\n\n\n","category":"type"},{"location":"reference/1_algorithms/#Boscia.BoundedLinearMinimizationOracle","page":"Algorithm","title":"Boscia.BoundedLinearMinimizationOracle","text":"BLMO\n\nSupertype for the Bounded Linear Minimization Oracles\n\n\n\n\n\n","category":"type"},{"location":"reference/1_algorithms/#Boscia.add_bound_constraint!","page":"Algorithm","title":"Boscia.add_bound_constraint!","text":"Add bound constraint.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.build_LMO_correct-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"Algorithm","title":"Boscia.build_LMO_correct","text":"Check if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.build_global_bounds","page":"Algorithm","title":"Boscia.build_global_bounds","text":"Read global bounds from the problem.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.check_feasibility-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"Algorithm","title":"Boscia.check_feasibility","text":"Check if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.check_infeasible_vertex-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"Algorithm","title":"Boscia.check_infeasible_vertex","text":"Deal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.delete_bounds!","page":"Algorithm","title":"Boscia.delete_bounds!","text":"Delete bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.find_best_solution-Tuple{Function, Boscia.BoundedLinearMinimizationOracle, Any, Any}","page":"Algorithm","title":"Boscia.find_best_solution","text":"Find best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.free_model-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"Algorithm","title":"Boscia.free_model","text":"Free model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.get_BLMO_solve_data-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"Algorithm","title":"Boscia.get_BLMO_solve_data","text":"Get solve time, number of nodes and number of iterations, if applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.get_bound","page":"Algorithm","title":"Boscia.get_bound","text":"Read bound value for c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.get_int_var","page":"Algorithm","title":"Boscia.get_int_var","text":"Get the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.get_integer_variables","page":"Algorithm","title":"Boscia.get_integer_variables","text":"Get list of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.get_list_of_variables","page":"Algorithm","title":"Boscia.get_list_of_variables","text":"Get list of variables indices.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.get_lower_bound_list","page":"Algorithm","title":"Boscia.get_lower_bound_list","text":"Get the list of lower bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.get_tol-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"Algorithm","title":"Boscia.get_tol","text":"Get solving tolerance for the BLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.get_upper_bound_list","page":"Algorithm","title":"Boscia.get_upper_bound_list","text":"Get the list of upper bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.get_variables_pointers-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"Algorithm","title":"Boscia.get_variables_pointers","text":"List of all variable pointers. Depends on how you save your variables internally. In the easy case, this is simply collect(1:N).\n\nIs used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.has_integer_constraint","page":"Algorithm","title":"Boscia.has_integer_constraint","text":"Has variable an integer constraint?\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.indicator_present-Tuple{Boscia.BoundedLinearMinimizationOracle}","page":"Algorithm","title":"Boscia.indicator_present","text":"Are indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.is_bound_in","page":"Algorithm","title":"Boscia.is_bound_in","text":"To check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.is_constraint_on_int_var","page":"Algorithm","title":"Boscia.is_constraint_on_int_var","text":"Check if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.is_indicator_feasible-Tuple{Boscia.BoundedLinearMinimizationOracle, Any}","page":"Algorithm","title":"Boscia.is_indicator_feasible","text":"Is a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.is_linear_feasible","page":"Algorithm","title":"Boscia.is_linear_feasible","text":"Is a given point v linear feasible for the model? That means does v satisfy all bounds and other linear constraints?\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Boscia.BoundedLinearMinimizationOracle, Int64}","page":"Algorithm","title":"Boscia.is_valid_split","text":"Check whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.postsolve-NTuple{5, Any}","page":"Algorithm","title":"Boscia.postsolve","text":"postsolve(tree, result, time_ref, verbose)\n\nRuns the post solve both for a cleaner solutiona and to optimize  for the continuous variables if present. Prints solution statistics if verbose is true.        \n\n\n\n\n\n","category":"method"},{"location":"reference/1_algorithms/#Boscia.set_bound!","page":"Algorithm","title":"Boscia.set_bound!","text":"Change the value of the bound c_idx.\n\n\n\n\n\n","category":"function"},{"location":"reference/1_algorithms/#FrankWolfe.compute_extreme_point","page":"Algorithm","title":"FrankWolfe.compute_extreme_point","text":"Implement FrankWolfe.compute_extreme_point\n\nGiven a direction d solves the problem     min_x d^T x where x has to be an integer feasible point\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#The-Bounded-Linear-Minimization-Oracle-(BLMO)","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"This section describes the general interface to the Bounded Linear Minimization Oracle and the preimplemented types of BLMO.","category":"page"},{"location":"reference/2_blmo_build/#General-BLMO-interface","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"General BLMO interface","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Modules = [Boscia]\nPages = [\"blmo_interface.jl\"]","category":"page"},{"location":"reference/2_blmo_build/#Time-Tracking-Wrapper","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Time Tracking Wrapper","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Modules = [Boscia]\nPages = [\"time_tracking_lmo.jl\"]","category":"page"},{"location":"reference/2_blmo_build/#Boscia.TimeTrackingLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.TimeTrackingLMO","text":"TimeTrackingLMO  <: FW.LMO\n\nAn LMO wrapping another one tracking the time, number of nodes and number of calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Build-LMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Build LMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Modules = [Boscia]\nPages = [\"build_lmo.jl\"]","category":"page"},{"location":"reference/2_blmo_build/#Boscia.build_LMO-Tuple{Boscia.BoundedLinearMinimizationOracle, Boscia.IntegerBounds, Boscia.IntegerBounds, Vector{Int64}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO","text":"Build node LMO from global LMO\n\nFour action can be taken: KEEP   - constraint is as saved in the global bounds CHANGE - lower/upper bound is changed to the node specific one DELETE - custom bound from the previous node that is invalid at current node and has to be deleted ADD    - bound has to be added for this node because it does not exist in the global bounds (e.g. variable bound is a half open interval globally) \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#MOI-Oracle","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"MOI Oracle","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Modules = [Boscia]\nPages = [\"MOI_bounded_oracle.jl\"]\n","category":"page"},{"location":"reference/2_blmo_build/#Boscia.MathOptBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.MathOptBLMO","text":"BoundedLinearMinimizationOracle for solvers supporting MathOptInterface.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.MathOptBLMO-Tuple{FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.MathOptBLMO","text":"Build MathOptBLMO from FrankWolfe.MathOptLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Base.convert-Tuple{Type{Boscia.MathOptBLMO}, FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Base.convert","text":"Convert object of Type MathOptLMO into MathOptBLMO and viceversa.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Bonobo.get_branching_variable-Union{Tuple{OT}, Tuple{Bonobo.BnBTree, Boscia.PartialStrongBranching{Boscia.MathOptBLMO{OT}}, Bonobo.AbstractNode}} where OT<:MathOptInterface.AbstractOptimizer","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Bonobo.get_branching_variable","text":"Behavior for strong branching.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.add_bound_constraint!-Tuple{Boscia.MathOptBLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.add_bound_constraint!","text":"Add bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_LMO_correct-Tuple{Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_LMO_correct","text":"Check if the bounds were set correctly in build_LMO. Safety check only.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.build_global_bounds-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.build_global_bounds","text":"Read global bounds from the problem\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_feasibility-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_feasibility","text":"Check if problem is bounded and feasible, i.e. no contradicting constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.check_infeasible_vertex-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.check_infeasible_vertex","text":"Deal with infeasible vertex if necessary, e.g. check what caused it etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.delete_bounds!-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.delete_bounds!","text":"Delete bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.explicit_bounds_binary_var-Tuple{Boscia.MathOptBLMO, Boscia.IntegerBounds}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.explicit_bounds_binary_var","text":"Add explicit bounds for binary variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Function, Boscia.MathOptBLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"Find best solution from the solving process.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.find_best_solution-Tuple{Function, MathOptInterface.AbstractOptimizer, Vector{MathOptInterface.VariableIndex}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.find_best_solution","text":"Finds the best solution in the Optimizer's solution storage, based on the objective function f. Returns the solution vector and the corresponding best value.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.free_model-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.free_model","text":"Free model data from previous solve (if necessary).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_BLMO_solve_data-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_BLMO_solve_data","text":"Get solve time, number of nodes and number of simplex iterations.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_binary_variables-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_binary_variables","text":"Get list of binary and integer variables, respectively.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_bound-Tuple{Boscia.MathOptBLMO, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_bound","text":"Read bound value for c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_int_var-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_int_var","text":"Get the index of the integer variable the bound is working on.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_list_of_variables-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_list_of_variables","text":"Get list of variables indices and the total number of variables.  If the problem has n variables, they are expected to contiguous and ordered from 1 to n.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_lower_bound_list-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_lower_bound_list","text":"Get the list of lower bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_tol-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_tol","text":"Get solving tolerance for the BLMO.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_upper_bound_list-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_upper_bound_list","text":"Get the list of upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.get_variables_pointers-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.get_variables_pointers","text":"List of all variable pointers. Depends on how you save your variables internally.\n\nIs used in find_best_solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_binary_constraint-Tuple{Boscia.MathOptBLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_binary_constraint","text":"Has variable a binary constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.has_integer_constraint-Tuple{Boscia.MathOptBLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.has_integer_constraint","text":"Does the variable have an integer constraint?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.indicator_present-Tuple{Boscia.MathOptBLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.indicator_present","text":"Are indicator constraints present?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_bound_in-Tuple{Boscia.MathOptBLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_bound_in","text":"To check if there is bound for the variable in the global or node bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_constraint_on_int_var-Tuple{Boscia.MathOptBLMO, Any, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_constraint_on_int_var","text":"Check if the subject of the bound cidx is an integer variable (recorded in intvars).\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_indicator_feasible-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_indicator_feasible","text":"Is a given point v indicator feasible, i.e. meets the indicator constraints? If applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_linear_feasible-Tuple{Boscia.MathOptBLMO, AbstractVector}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_linear_feasible","text":"Is a given point v linear feasible for the model?\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.is_valid_split-Tuple{Bonobo.BnBTree, Boscia.MathOptBLMO, Int64}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_valid_split","text":"Check whether a split is valid, i.e. the upper and lower on variable vidx are not the same. \n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.set_bound!-Tuple{Boscia.MathOptBLMO, Any, Any, Symbol}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.set_bound!","text":"Change the value of the bound c_idx.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.solve-Tuple{Any, Any, FrankWolfe.MathOptLMO}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.solve","text":"Solve function in case of MathOptLMO.  Converts the lmo into a MathOptBLMO and calls the solve function below.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#FrankWolfe.compute_extreme_point-Tuple{Boscia.MathOptBLMO, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"FrankWolfe.compute_extreme_point","text":"compute_extreme_point\n\nIs implemented in the FrankWolfe package in file \"moi_oracle.jl\".\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Managed-BLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Managed BLMO","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Modules = [Boscia]\nPages = [\"managed_blmo.jl\"]","category":"page"},{"location":"reference/2_blmo_build/#Boscia.ManagedBoundedLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ManagedBoundedLMO","text":"ManagedBoundedLinearMinimizationOracle\n\nA Bounded Linear Minimization Oracle that manages the bounds.\n\nsimplelmo   - An LMO of type Simple Boundable LMO (see above).   lowerbounds - List of lower bounds for the integer variables recorded in intvars. If there is no specific lower bound, set corresponding entry to -Inf. upperbounds - List of upper bounds for the integer variables recorded in intvars. If there is no specific upper bound, set corresponding entry to Inf. n            - Total number of variables. intvars     - List of indices of the integer variables. solvingtime - The time evaluate `computeextreme_point`.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.SimpleBoundableLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.SimpleBoundableLMO","text":"SimpleBoundableLinearMinimizationOracle\n\nA simple LMO that computes the extreme point given the node specific bounds on the integer variables. Can be stateless since all of the bound management is done by the ManagedBoundedLMO.   \n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"Computes the extreme point given an direction d, the current lower and upper bounds on the integer variables, and the set of integer variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Boscia.is_simple_linear_feasible","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.is_simple_linear_feasible","text":"Checks whether a given point v is satisfying the constraints on the problem. Note that the bounds on the integer variables are being checked by the ManagedBoundedLMO and do not have to be check here. \n\n\n\n\n\n","category":"function"},{"location":"reference/2_blmo_build/#Polytopes","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Polytopes","text":"","category":"section"},{"location":"reference/2_blmo_build/","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"The Bounded Linear Minimization Oracle (BLMO)","text":"Modules = [Boscia]\nPages = [\"polytope_blmos.jl\"]","category":"page"},{"location":"reference/2_blmo_build/#Boscia.CubeSimpleBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.CubeSimpleBLMO","text":"CubeSimpleBLMO{T}(lower_bounds, upper_bounds)\n\nHypercube with lower and upper bounds implementing the SimpleBoundableLMO interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.ProbabilitySimplexSimpleBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.ProbabilitySimplexSimpleBLMO","text":"ProbablitySimplexSimpleBLMO(N)\n\nScaled Probability Simplex: ∑ x = N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.UnitSimplexSimpleBLMO","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.UnitSimplexSimpleBLMO","text":"UnitSimplexSimpleBLMO(N)\n\nScaled Unit Simplex: ∑ x ≤ N.\n\n\n\n\n\n","category":"type"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.CubeSimpleBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"If the entry is positve, choose the lower bound. Else, choose the upper bound.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.ProbabilitySimplexSimpleBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"Assign the largest possible values to the entries corresponding to the smallest entries of d.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.bounded_compute_extreme_point-Tuple{Boscia.UnitSimplexSimpleBLMO, Vararg{Any, 4}}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.bounded_compute_extreme_point","text":"For all positive entries of d, assign the corresponding lower bound. For non-positive entries, assign largest possible value in increasing order.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedBoundedLMO{Boscia.ProbabilitySimplexSimpleBLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"Hyperplane-aware rounding for the probability simplex.\n\n\n\n\n\n","category":"method"},{"location":"reference/2_blmo_build/#Boscia.rounding_hyperplane_heuristic-Tuple{Bonobo.BnBTree, Boscia.TimeTrackingLMO{Boscia.ManagedBoundedLMO{Boscia.UnitSimplexSimpleBLMO}}, Any}","page":"The Bounded Linear Minimization Oracle (BLMO)","title":"Boscia.rounding_hyperplane_heuristic","text":"Hyperplane-aware rounding for the unit simplex.\n\n\n\n\n\n","category":"method"},{"location":"#Boscia.jl","page":"Home","title":"Boscia.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A solver for Mixed-Integer Convex Optimization that uses Frank-Wolfe methods for convex relaxations and a branch-and-bound algorithm.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Boscia.jl solver combines (a variant of) the Frank-Wolfe algorithm with a branch-and-bound-like algorithm to solve mixed-integer convex optimization problems of the form min_x  C x_I  mathbbZ^n f(x), where f is a differentiable convex function, C is a convex and compact set, and I is a set of indices of integral variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approach is especially effective when we have a method to optimize a linear function over C and the integrality constraints in a computationally efficient way. The set C can modelled using the Julia package MathOptInterface (or JuMP).  We also implemented simple polytopes like the hypercube, the unit simplex and the probability simplex. Also, we intend to extend this list by combinatorial polytopes, e.g. the matching polytope.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The paper presenting the package with mathematical explanations and numerous examples can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convex integer optimization with Frank-Wolfe methods: 2208.11010","category":"page"},{"location":"","page":"Home","title":"Home","text":"Boscia.jl uses FrankWolfe.jl for solving the convex subproblems, Bonobo.jl for managing the search tree, and oracles optimizing linear functions over the feasible set, for instance calling SCIP or any MOI-compatible solver to solve MIP subproblems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add the Boscia stable release with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Boscia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or get the latest master branch with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/ZIB-IOL/Boscia.jl\", rev=\"main\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the installation of SCIP.jl, see here. Note, for Windows users, you do not need to download the SCIP binaries, you can also use the installer provided by SCIP.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example to get started. For more examples, see the examples folder in the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Boscia\nusing FrankWolfe\nusing Random\nusing SCIP\nusing LinearAlgebra\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nn = 6\n\nconst diffw = 0.5 * ones(n)\no = SCIP.Optimizer()\n\nMOI.set(o, MOI.Silent(), true)\n\nx = MOI.add_variables(o, n)\n\nfor xi in x\n    MOI.add_constraint(o, xi, MOI.GreaterThan(0.0))\n    MOI.add_constraint(o, xi, MOI.LessThan(1.0))\n    MOI.add_constraint(o, xi, MOI.ZeroOne())\nend\n\nlmo = FrankWolfe.MathOptLMO(o)\n\nfunction f(x)\n    return sum(0.5*(x.-diffw).^2)\nend\n\nfunction grad!(storage, x)\n    @. storage = x-diffw\nend\n\nx, _, result = Boscia.solve(f, grad!, lmo, verbose = true)\n\nBoscia Algorithm.\n\nParameter settings.\n\t Tree traversal strategy: Move best bound\n\t Branching strategy: Most infeasible\n\t Absolute dual gap tolerance: 1.000000e-06\n\t Relative dual gap tolerance: 1.000000e-02\n\t Frank-Wolfe subproblem tolerance: 1.000000e-05\n\t Total number of varibales: 6\n\t Number of integer variables: 0\n\t Number of binary variables: 6\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n   Iteration       Open          Bound      Incumbent      Gap (abs)      Gap (rel)       Time (s)      Nodes/sec        FW (ms)       LMO (ms)  LMO (calls c)   FW (Its)   #ActiveSet  Discarded\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n*          1          2  -1.202020e-06   7.500000e-01   7.500012e-01            Inf   3.870000e-01   7.751938e+00            237              2              9         13            1          0\n         100         27   6.249998e-01   7.500000e-01   1.250002e-01   2.000004e-01   5.590000e-01   2.271914e+02              0              0            641          0            1          0\n         127          0   7.500000e-01   7.500000e-01   0.000000e+00   0.000000e+00   5.770000e-01   2.201040e+02              0              0            695          0            1          0\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPostprocessing\n\nBlended Pairwise Conditional Gradient Algorithm.\nMEMORY_MODE: FrankWolfe.InplaceEmphasis() STEPSIZE: Adaptive EPSILON: 1.0e-7 MAXITERATION: 10000 TYPE: Float64\nGRADIENTTYPE: Nothing LAZY: true lazy_tolerance: 2.0\n[ Info: In memory_mode memory iterates are written back into x0!\n\n----------------------------------------------------------------------------------------------------------------\n  Type     Iteration         Primal           Dual       Dual Gap           Time         It/sec     #ActiveSet\n----------------------------------------------------------------------------------------------------------------\n  Last             0   7.500000e-01   7.500000e-01   0.000000e+00   1.086583e-03   0.000000e+00              1\n----------------------------------------------------------------------------------------------------------------\n    PP             0   7.500000e-01   7.500000e-01   0.000000e+00   1.927792e-03   0.000000e+00              1\n----------------------------------------------------------------------------------------------------------------\n\nSolution Statistics.\n\t Solution Status: Optimal (tree empty)\n\t Primal Objective: 0.75\n\t Dual Bound: 0.75\n\t Dual Gap (relative): 0.0\n\nSearch Statistics.\n\t Total number of nodes processed: 127\n\t Total number of lmo calls: 699\n\t Total time (s): 0.58\n\t LMO calls / sec: 1205.1724137931035\n\t Nodes / sec: 218.96551724137933\n\t LMO calls / node: 5.503937007874016","category":"page"},{"location":"reference/0_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/0_reference/","page":"API Reference","title":"API Reference","text":"In this section we present the algorithm interface and the possible settings.","category":"page"}]
}
