<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm Interface · Boscia.jl</title><meta name="title" content="Algorithm Interface · Boscia.jl"/><meta property="og:title" content="Algorithm Interface · Boscia.jl"/><meta property="twitter:title" content="Algorithm Interface · Boscia.jl"/><meta name="description" content="Documentation for Boscia.jl."/><meta property="og:description" content="Documentation for Boscia.jl."/><meta property="twitter:description" content="Documentation for Boscia.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Boscia.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../basics/">How does it work?</a></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Algorithm Interface</a></li><li><a class="tocitem" href="../2_blmo_build/">The Bounded Linear Minimization Oracle (BLMO)</a></li><li><a class="tocitem" href="../custom/">Branch-and-Bound tree functionality</a></li><li><a class="tocitem" href="../fw_variant/">Frank-Wolfe Variants</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Algorithm Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/Boscia.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ZIB-IOL/Boscia.jl/blob/main/docs/src/reference/1_algorithms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithm-Interface"><a class="docs-heading-anchor" href="#Algorithm-Interface">Algorithm Interface</a><a id="Algorithm-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Interface" title="Permalink"></a></h1><p>Boscia&#39;s <code>solve</code> function only requires the oracles of the objective function <code>f</code> and its gradient <code>g</code> as well as the BLMO encoding the feasible region.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.postsolve-NTuple{5, Any}" href="#Boscia.postsolve-NTuple{5, Any}"><code>Boscia.postsolve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">postsolve(tree, result, time_ref, verbose, max_iteration_post)</code></pre><p>Runs the post solve to optimize for the continuous variables if present. Is called if <code>use_post_solve</code> is enabled in the <code>solve</code> function. Prints solution statistics if verbose is set to <code>true</code>.        </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/d1351b73d57135dc086c8a3fd89ddbee0f4941fd/src/interface.jl#L362-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Boscia.solve-Tuple{Any, Any, Boscia.BoundedLinearMinimizationOracle}" href="#Boscia.solve-Tuple{Any, Any, Boscia.BoundedLinearMinimizationOracle}"><code>Boscia.solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(f, g, blmo::BoundedLinearMinimizationOracle; ...)</code></pre><p>Requires</p><ul><li><code>f</code> oracle of the objective function.</li><li><code>g</code> oracle of the gradient of the objective</li><li><code>blmo</code> encodes the feasible region and can handle additional bound constraints. This can either be a MIP solver instance (e.g., SCIP) or be a custom type (see <code>polytope_blmos.jl</code>). Has to be of type <code>BoundedLinearMinimizationOracle</code> (see <code>blmo_interface.jl</code>).</li></ul><p>Returns</p><ul><li><code>x</code> the best solution found.</li><li><code>tlmo</code> the BLMO wrapped in a TimeTrackingLMO instance.</li><li><code>result</code> a dictionary containg the statistics like number of nodes, total solving etc. It also contains information for plotting progress plots like the lower and upper bound progress.</li></ul><p>Optional settings</p><ul><li><code>traverse_strategy</code> encodes how to choose the next node for evaluation. By default the node with the best lower bound is picked.</li><li><code>branching_strategy</code> fixes the branching strategy. By default, weuse <code>MOST_INFEASIBLE</code>, i.e. we branch on the entry which is the farthest away from being an integer.</li><li><code>variant</code> the Frank-Wolfe variant to be used to solve the node problem. Options currently available are <code>AwayFrankWolfe</code>, <code>Blended</code>, <code>BPCG</code> and <code>VanillaFrankWolfe</code>.</li><li><code>line_search</code> specifies the line search method used in the FrankWolfe variant. Default is the <code>Adaptive</code> line search. For other available types, check the FrankWolfe.jl package.</li><li><code>active_set</code> can be used to specify a starting point. By default, the direction (1,..,n) where n is the size of the problem is used to find a start vertex. This has to be of the type <code>FrankWolfe.ActiveSet</code>. Beware that the active set may only contain actual vertices of the feasible region.</li><li><code>lazy</code> flag specifies whether the lazification of the Frank-Wolfe variant should be used. Per default <code>true</code>. Note that it has no effect on Vanilla Frank-Wolfe.</li><li><code>lazy_tolerance</code> decides how much progress is deemed enough to not have to call the LMO. Only used if the <code>lazy</code> flag is activated.</li><li><code>fw_epsilon</code> the solving precision of Frank-Wolfe at the root node.</li><li><code>verbose</code> if <code>true</code>, logs and solution statistics are printed.</li><li><code>dual_gap</code> absolute dual gap. If  reached, the algorithm stops.</li><li><code>rel_dual_gap</code> relative dual gap. If reached, the algorithm stops.</li><li><code>time_limit</code> algorithm will stop if the time limit is reached. Depending on the problem it is possible that no feasible solution has been found yet. On default, there is no time limit.</li><li><code>print_iter</code> encodes after how many processed nodes the current node and solution status is printed. The logs are always printed if a new integral solution has been found.</li><li><code>dual_gap_decay_factor</code> the FrankWolfe tolerance at a given level <code>i</code> in the tree is given by <code>fw_epsilon * dual_gap_decay_factor^i</code> until we reach the <code>min_node_fw_epsilon</code>.</li><li><code>max_fw_iter</code> maximum number of iterations in a Frank-Wolfe run.</li><li><code>min_number_lower</code> if not <code>Inf</code>, evaluation of a node is stopped if at least <code>min_number_lower</code> open nodes have a better lower bound.</li><li><code>min_node_fw_epsilon</code> smallest fw epsilon tolerance, see also <code>dual_gap_decay_factor</code>.</li><li><code>use_postsolve</code> if <code>true</code>, runs the specified Frank-Wolfe variant on the problem with the integral variables fixed to the solution, i.e. it only optimizes over the continuous variables. This might improve the solution if one has many continuous variables.</li><li><code>min_fw_iterations</code> the minimum number of Frank-Wolfe iterations performed in the node evaluation.</li><li><code>max_iteration_post</code> maximum number of iterations in the Frank-Wolfe run during postsolve.</li><li><code>dual_tightening</code> flag to decide  whether to use dual tightening techniques at node level. Note that this only porvides valid tightenings if your function is convex!</li><li><code>global_dual_tightening</code> flag to decide whether to generate dual tightenings from new solutions that are gloablly valid.</li><li><code>bnb_callback</code> an optional callback called after every node evaluation.</li><li><code>strong_convexity</code> strong convexity parameter of the objective <code>f</code>, used for tightening the dual bound at every node.</li><li><code>sharpness_constant</code> - the constant <code>M &gt; 0</code> for <code>(θ, M)</code>-sharpness. <code>f</code> is <code>(θ, M)</code>-sharpness: <code>f</code> satisfies <code>min_{x^* ∈ X^*} || x - x^* || ≤ M (f(x) - f^(x^*))^θ</code> where <code>X^*</code> is the set of minimizer of <code>f</code>. Note that tightenings using sharpness are only valid if the problem has a unique minimizer, i.e. <code>f</code> is stricly convex!</li><li><code>sharpness_exponent</code> - the exponent <code>θ ∈ [0, 1/2]</code> for <code>(θ, M)</code>-sharpness.</li><li><code>domain_oracle</code> given a point <code>x</code>: returns <code>true</code> if <code>x</code> is in the domain of <code>f</code>, else false. Per default, it always returns <code>true</code>. In case of the non-trivial domain oracle, the starting point has to be domain feasible for <code>f</code>. Additionally, the user has to provide a function <code>domain_point</code>, see below. Also, depending on the line search method, you might have to provide the domain oracle to it, too.</li><li><code>find_domain_point</code> given the current node bounds return a domain feasible point respecting the bounds. If no such point can be found, return <code>nothing</code>.</li><li><code>start_solution</code> an initial solution can be provided if known. It will be used as the initial incumbent.</li><li><code>fw_verbose</code> if <code>true</code>, the Frank-Wolfe logs are printed at each node. Mostly meant for debugging.</li><li><code>use_shadow_set</code> the shadow set is the set of discarded vertices which is inherited by the children nodes. It is used to avoid recomputing of vertices in case the BLMO is expensive. In case of a cheap BLMO, performance might improve by disabling this option.</li><li><code>custom_heuristics</code> list of custom heuristics from the user. </li><li><code>prob_rounding</code> the probability for calling the simple rounding heuristic. Since the feasibility has to be checked, it might be expensive to do this for every node. Per default, this is activated for every node.</li><li><code>clean_solutions</code> flag deciding whether new solutions should be polished. They will be rounded and then a quick Frank-Wolfe run will be started.</li><li><code>max_clean_iter</code> maximum number of iterations in the Frank-Wolfe call for polishing new solutions.</li><li><code>use_strong_lazy</code> specifies strong lazification in DICG. Otherwise, weak version is used.</li><li><code>use_DICG_warm_start</code> if <code>true</code>, enables DICG-specific warm-start strategy.</li><li><code>use_strong_warm_start</code> if <code>true</code>, performs additional in-face check for vertices.</li><li><code>build_dicg_start_point</code> default generates a random feasible vertex.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ZIB-IOL/Boscia.jl/blob/d1351b73d57135dc086c8a3fd89ddbee0f4941fd/src/interface.jl#L3-L59">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../basics/">« How does it work?</a><a class="docs-footer-nextpage" href="../2_blmo_build/">The Bounded Linear Minimization Oracle (BLMO) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Monday 14 April 2025 09:17">Monday 14 April 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
